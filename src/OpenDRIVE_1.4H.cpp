// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "OpenDRIVE_1.4H.h"

// elementType
// 

elementType::
elementType (value v)
: ::xml_schema::string (_xsd_elementType_literals_[v])
{
}

elementType::
elementType (const char* v)
: ::xml_schema::string (v)
{
}

elementType::
elementType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

elementType::
elementType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

elementType::
elementType (const elementType& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

elementType& elementType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_elementType_literals_[v]);

  return *this;
}


// t_max
//

t_max::
t_max (const char* s)
: ::xml_schema::string (s)
{
}

t_max::
t_max (const ::std::string& s)
: ::xml_schema::string (s)
{
}

t_max::
t_max (const t_max& o,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (o, f, c)
{
}

// contactPoint
// 

contactPoint::
contactPoint (value v)
: ::xml_schema::string (_xsd_contactPoint_literals_[v])
{
}

contactPoint::
contactPoint (const char* v)
: ::xml_schema::string (v)
{
}

contactPoint::
contactPoint (const ::std::string& v)
: ::xml_schema::string (v)
{
}

contactPoint::
contactPoint (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

contactPoint::
contactPoint (const contactPoint& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

contactPoint& contactPoint::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_contactPoint_literals_[v]);

  return *this;
}


// side
// 

side::
side (value v)
: ::xml_schema::string (_xsd_side_literals_[v])
{
}

side::
side (const char* v)
: ::xml_schema::string (v)
{
}

side::
side (const ::std::string& v)
: ::xml_schema::string (v)
{
}

side::
side (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

side::
side (const side& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

side& side::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_side_literals_[v]);

  return *this;
}


// direction
// 

direction::
direction (value v)
: ::xml_schema::string (_xsd_direction_literals_[v])
{
}

direction::
direction (const char* v)
: ::xml_schema::string (v)
{
}

direction::
direction (const ::std::string& v)
: ::xml_schema::string (v)
{
}

direction::
direction (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

direction::
direction (const direction& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

direction& direction::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_direction_literals_[v]);

  return *this;
}


// roadType
// 

roadType::
roadType (value v)
: ::xml_schema::string (_xsd_roadType_literals_[v])
{
}

roadType::
roadType (const char* v)
: ::xml_schema::string (v)
{
}

roadType::
roadType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

roadType::
roadType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

roadType::
roadType (const roadType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

roadType& roadType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_roadType_literals_[v]);

  return *this;
}


// unit
// 

unit::
unit (value v)
: ::xml_schema::string (_xsd_unit_literals_[v])
{
}

unit::
unit (const char* v)
: ::xml_schema::string (v)
{
}

unit::
unit (const ::std::string& v)
: ::xml_schema::string (v)
{
}

unit::
unit (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

unit::
unit (const unit& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

unit& unit::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_unit_literals_[v]);

  return *this;
}


// pRange
// 

pRange::
pRange (value v)
: ::xml_schema::string (_xsd_pRange_literals_[v])
{
}

pRange::
pRange (const char* v)
: ::xml_schema::string (v)
{
}

pRange::
pRange (const ::std::string& v)
: ::xml_schema::string (v)
{
}

pRange::
pRange (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

pRange::
pRange (const pRange& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

pRange& pRange::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_pRange_literals_[v]);

  return *this;
}


// crossfallSide
// 

crossfallSide::
crossfallSide (value v)
: ::xml_schema::string (_xsd_crossfallSide_literals_[v])
{
}

crossfallSide::
crossfallSide (const char* v)
: ::xml_schema::string (v)
{
}

crossfallSide::
crossfallSide (const ::std::string& v)
: ::xml_schema::string (v)
{
}

crossfallSide::
crossfallSide (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

crossfallSide::
crossfallSide (const crossfallSide& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

crossfallSide& crossfallSide::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_crossfallSide_literals_[v]);

  return *this;
}


// singleSide
// 

singleSide::
singleSide (value v)
: ::xml_schema::string (_xsd_singleSide_literals_[v])
{
}

singleSide::
singleSide (const char* v)
: ::xml_schema::string (v)
{
}

singleSide::
singleSide (const ::std::string& v)
: ::xml_schema::string (v)
{
}

singleSide::
singleSide (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

singleSide::
singleSide (const singleSide& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

singleSide& singleSide::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_singleSide_literals_[v]);

  return *this;
}


// laneType
// 

laneType::
laneType (value v)
: ::xml_schema::string (_xsd_laneType_literals_[v])
{
}

laneType::
laneType (const char* v)
: ::xml_schema::string (v)
{
}

laneType::
laneType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

laneType::
laneType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

laneType::
laneType (const laneType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

laneType& laneType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_laneType_literals_[v]);

  return *this;
}


// roadmarkType
// 

roadmarkType::
roadmarkType (value v)
: ::xml_schema::string (_xsd_roadmarkType_literals_[v])
{
}

roadmarkType::
roadmarkType (const char* v)
: ::xml_schema::string (v)
{
}

roadmarkType::
roadmarkType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

roadmarkType::
roadmarkType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

roadmarkType::
roadmarkType (const roadmarkType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

roadmarkType& roadmarkType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_roadmarkType_literals_[v]);

  return *this;
}


// weight
// 

weight::
weight (value v)
: ::xml_schema::string (_xsd_weight_literals_[v])
{
}

weight::
weight (const char* v)
: ::xml_schema::string (v)
{
}

weight::
weight (const ::std::string& v)
: ::xml_schema::string (v)
{
}

weight::
weight (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

weight::
weight (const weight& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

weight& weight::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_weight_literals_[v]);

  return *this;
}


// color
// 

color::
color (value v)
: ::xml_schema::string (_xsd_color_literals_[v])
{
}

color::
color (const char* v)
: ::xml_schema::string (v)
{
}

color::
color (const ::std::string& v)
: ::xml_schema::string (v)
{
}

color::
color (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

color::
color (const color& v,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

color& color::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_color_literals_[v]);

  return *this;
}


// restriction
// 

restriction::
restriction (value v)
: ::xml_schema::string (_xsd_restriction_literals_[v])
{
}

restriction::
restriction (const char* v)
: ::xml_schema::string (v)
{
}

restriction::
restriction (const ::std::string& v)
: ::xml_schema::string (v)
{
}

restriction::
restriction (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

restriction::
restriction (const restriction& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

restriction& restriction::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_restriction_literals_[v]);

  return *this;
}


// laneChange
// 

laneChange::
laneChange (value v)
: ::xml_schema::string (_xsd_laneChange_literals_[v])
{
}

laneChange::
laneChange (const char* v)
: ::xml_schema::string (v)
{
}

laneChange::
laneChange (const ::std::string& v)
: ::xml_schema::string (v)
{
}

laneChange::
laneChange (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

laneChange::
laneChange (const laneChange& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

laneChange& laneChange::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_laneChange_literals_[v]);

  return *this;
}


// rule
// 

rule::
rule (value v)
: ::xml_schema::string (_xsd_rule_literals_[v])
{
}

rule::
rule (const char* v)
: ::xml_schema::string (v)
{
}

rule::
rule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

rule::
rule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

rule::
rule (const rule& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

rule& rule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_rule_literals_[v]);

  return *this;
}


// orientation
// 

orientation::
orientation (value v)
: ::xml_schema::string (_xsd_orientation_literals_[v])
{
}

orientation::
orientation (const char* v)
: ::xml_schema::string (v)
{
}

orientation::
orientation (const ::std::string& v)
: ::xml_schema::string (v)
{
}

orientation::
orientation (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

orientation::
orientation (const orientation& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

orientation& orientation::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_orientation_literals_[v]);

  return *this;
}


// tunnelType
// 

tunnelType::
tunnelType (value v)
: ::xml_schema::string (_xsd_tunnelType_literals_[v])
{
}

tunnelType::
tunnelType (const char* v)
: ::xml_schema::string (v)
{
}

tunnelType::
tunnelType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

tunnelType::
tunnelType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

tunnelType::
tunnelType (const tunnelType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

tunnelType& tunnelType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_tunnelType_literals_[v]);

  return *this;
}


// bridgeType
// 

bridgeType::
bridgeType (value v)
: ::xml_schema::string (_xsd_bridgeType_literals_[v])
{
}

bridgeType::
bridgeType (const char* v)
: ::xml_schema::string (v)
{
}

bridgeType::
bridgeType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

bridgeType::
bridgeType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

bridgeType::
bridgeType (const bridgeType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

bridgeType& bridgeType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_bridgeType_literals_[v]);

  return *this;
}


// parkingSpace_access
// 

parkingSpace_access::
parkingSpace_access (value v)
: ::xml_schema::string (_xsd_parkingSpace_access_literals_[v])
{
}

parkingSpace_access::
parkingSpace_access (const char* v)
: ::xml_schema::string (v)
{
}

parkingSpace_access::
parkingSpace_access (const ::std::string& v)
: ::xml_schema::string (v)
{
}

parkingSpace_access::
parkingSpace_access (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

parkingSpace_access::
parkingSpace_access (const parkingSpace_access& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

parkingSpace_access& parkingSpace_access::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_parkingSpace_access_literals_[v]);

  return *this;
}


// parkingSpacemarkingSide
// 

parkingSpacemarkingSide::
parkingSpacemarkingSide (value v)
: ::xml_schema::string (_xsd_parkingSpacemarkingSide_literals_[v])
{
}

parkingSpacemarkingSide::
parkingSpacemarkingSide (const char* v)
: ::xml_schema::string (v)
{
}

parkingSpacemarkingSide::
parkingSpacemarkingSide (const ::std::string& v)
: ::xml_schema::string (v)
{
}

parkingSpacemarkingSide::
parkingSpacemarkingSide (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

parkingSpacemarkingSide::
parkingSpacemarkingSide (const parkingSpacemarkingSide& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

parkingSpacemarkingSide& parkingSpacemarkingSide::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_parkingSpacemarkingSide_literals_[v]);

  return *this;
}


// dynamic
// 

dynamic::
dynamic (value v)
: ::xml_schema::string (_xsd_dynamic_literals_[v])
{
}

dynamic::
dynamic (const char* v)
: ::xml_schema::string (v)
{
}

dynamic::
dynamic (const ::std::string& v)
: ::xml_schema::string (v)
{
}

dynamic::
dynamic (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

dynamic::
dynamic (const dynamic& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

dynamic& dynamic::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_dynamic_literals_[v]);

  return *this;
}


// surfaceOrientation
// 

surfaceOrientation::
surfaceOrientation (value v)
: ::xml_schema::string (_xsd_surfaceOrientation_literals_[v])
{
}

surfaceOrientation::
surfaceOrientation (const char* v)
: ::xml_schema::string (v)
{
}

surfaceOrientation::
surfaceOrientation (const ::std::string& v)
: ::xml_schema::string (v)
{
}

surfaceOrientation::
surfaceOrientation (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

surfaceOrientation::
surfaceOrientation (const surfaceOrientation& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

surfaceOrientation& surfaceOrientation::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_surfaceOrientation_literals_[v]);

  return *this;
}


// mode
// 

mode::
mode (value v)
: ::xml_schema::string (_xsd_mode_literals_[v])
{
}

mode::
mode (const char* v)
: ::xml_schema::string (v)
{
}

mode::
mode (const ::std::string& v)
: ::xml_schema::string (v)
{
}

mode::
mode (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

mode::
mode (const mode& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

mode& mode::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_mode_literals_[v]);

  return *this;
}


// purpose
// 

purpose::
purpose (value v)
: ::xml_schema::string (_xsd_purpose_literals_[v])
{
}

purpose::
purpose (const char* v)
: ::xml_schema::string (v)
{
}

purpose::
purpose (const ::std::string& v)
: ::xml_schema::string (v)
{
}

purpose::
purpose (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

purpose::
purpose (const purpose& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

purpose& purpose::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_purpose_literals_[v]);

  return *this;
}


// position
// 

position::
position (value v)
: ::xml_schema::string (_xsd_position_literals_[v])
{
}

position::
position (const char* v)
: ::xml_schema::string (v)
{
}

position::
position (const ::std::string& v)
: ::xml_schema::string (v)
{
}

position::
position (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

position::
position (const position& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

position& position::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_position_literals_[v]);

  return *this;
}


// dir
// 

dir::
dir (value v)
: ::xml_schema::string (_xsd_dir_literals_[v])
{
}

dir::
dir (const char* v)
: ::xml_schema::string (v)
{
}

dir::
dir (const ::std::string& v)
: ::xml_schema::string (v)
{
}

dir::
dir (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

dir::
dir (const dir& v,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

dir& dir::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_dir_literals_[v]);

  return *this;
}


// junctionGroupType
// 

junctionGroupType::
junctionGroupType (value v)
: ::xml_schema::string (_xsd_junctionGroupType_literals_[v])
{
}

junctionGroupType::
junctionGroupType (const char* v)
: ::xml_schema::string (v)
{
}

junctionGroupType::
junctionGroupType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

junctionGroupType::
junctionGroupType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

junctionGroupType::
junctionGroupType (const junctionGroupType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

junctionGroupType& junctionGroupType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_junctionGroupType_literals_[v]);

  return *this;
}


// stationType
// 

stationType::
stationType (value v)
: ::xml_schema::string (_xsd_stationType_literals_[v])
{
}

stationType::
stationType (const char* v)
: ::xml_schema::string (v)
{
}

stationType::
stationType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

stationType::
stationType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

stationType::
stationType (const stationType& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

stationType& stationType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_stationType_literals_[v]);

  return *this;
}


// userData
// 

const userData::code_optional& userData::
code () const
{
  return this->code_;
}

userData::code_optional& userData::
code ()
{
  return this->code_;
}

void userData::
code (const code_type& x)
{
  this->code_.set (x);
}

void userData::
code (const code_optional& x)
{
  this->code_ = x;
}

void userData::
code (::std::auto_ptr< code_type > x)
{
  this->code_.set (x);
}

const userData::value_optional& userData::
value () const
{
  return this->value_;
}

userData::value_optional& userData::
value ()
{
  return this->value_;
}

void userData::
value (const value_type& x)
{
  this->value_.set (x);
}

void userData::
value (const value_optional& x)
{
  this->value_ = x;
}

void userData::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// include
// 

const include::file_optional& include::
file () const
{
  return this->file_;
}

include::file_optional& include::
file ()
{
  return this->file_;
}

void include::
file (const file_type& x)
{
  this->file_.set (x);
}

void include::
file (const file_optional& x)
{
  this->file_ = x;
}

void include::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}


// laneValidity
// 

const laneValidity::userData_sequence& laneValidity::
userData () const
{
  return this->userData_;
}

laneValidity::userData_sequence& laneValidity::
userData ()
{
  return this->userData_;
}

void laneValidity::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const laneValidity::include_sequence& laneValidity::
include () const
{
  return this->include_;
}

laneValidity::include_sequence& laneValidity::
include ()
{
  return this->include_;
}

void laneValidity::
include (const include_sequence& s)
{
  this->include_ = s;
}

const laneValidity::fromLane_optional& laneValidity::
fromLane () const
{
  return this->fromLane_;
}

laneValidity::fromLane_optional& laneValidity::
fromLane ()
{
  return this->fromLane_;
}

void laneValidity::
fromLane (const fromLane_type& x)
{
  this->fromLane_.set (x);
}

void laneValidity::
fromLane (const fromLane_optional& x)
{
  this->fromLane_ = x;
}

const laneValidity::toLane_optional& laneValidity::
toLane () const
{
  return this->toLane_;
}

laneValidity::toLane_optional& laneValidity::
toLane ()
{
  return this->toLane_;
}

void laneValidity::
toLane (const toLane_type& x)
{
  this->toLane_.set (x);
}

void laneValidity::
toLane (const toLane_optional& x)
{
  this->toLane_ = x;
}


// parkingSpace
// 

const parkingSpace::marking_sequence& parkingSpace::
marking () const
{
  return this->marking_;
}

parkingSpace::marking_sequence& parkingSpace::
marking ()
{
  return this->marking_;
}

void parkingSpace::
marking (const marking_sequence& s)
{
  this->marking_ = s;
}

const parkingSpace::userData_sequence& parkingSpace::
userData () const
{
  return this->userData_;
}

parkingSpace::userData_sequence& parkingSpace::
userData ()
{
  return this->userData_;
}

void parkingSpace::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const parkingSpace::include_sequence& parkingSpace::
include () const
{
  return this->include_;
}

parkingSpace::include_sequence& parkingSpace::
include ()
{
  return this->include_;
}

void parkingSpace::
include (const include_sequence& s)
{
  this->include_ = s;
}

const parkingSpace::access_optional& parkingSpace::
parkingSpace_access () const
{
  return this->parkingSpace_access_;
}

parkingSpace::access_optional& parkingSpace::
parkingSpace_access ()
{
  return this->parkingSpace_access_;
}

void parkingSpace::
parkingSpace_access (const access_type& x)
{
  this->parkingSpace_access_.set (x);
}

void parkingSpace::
parkingSpace_access (const access_optional& x)
{
  this->parkingSpace_access_ = x;
}

void parkingSpace::
parkingSpace_access (::std::auto_ptr< access_type > x)
{
  this->parkingSpace_access_.set (x);
}

const parkingSpace::restrictions_optional& parkingSpace::
restrictions () const
{
  return this->restrictions_;
}

parkingSpace::restrictions_optional& parkingSpace::
restrictions ()
{
  return this->restrictions_;
}

void parkingSpace::
restrictions (const restrictions_type& x)
{
  this->restrictions_.set (x);
}

void parkingSpace::
restrictions (const restrictions_optional& x)
{
  this->restrictions_ = x;
}

void parkingSpace::
restrictions (::std::auto_ptr< restrictions_type > x)
{
  this->restrictions_.set (x);
}


// lane
// 

const lane::link_optional& lane::
lane_link () const
{
  return this->lane_link_;
}

lane::link_optional& lane::
lane_link ()
{
  return this->lane_link_;
}

void lane::
lane_link (const link_type& x)
{
  this->lane_link_.set (x);
}

void lane::
lane_link (const link_optional& x)
{
  this->lane_link_ = x;
}

void lane::
lane_link (::std::auto_ptr< link_type > x)
{
  this->lane_link_.set (x);
}

const lane::width_sequence& lane::
width () const
{
  return this->width_;
}

lane::width_sequence& lane::
width ()
{
  return this->width_;
}

void lane::
width (const width_sequence& s)
{
  this->width_ = s;
}

const lane::border_sequence& lane::
border () const
{
  return this->border_;
}

lane::border_sequence& lane::
border ()
{
  return this->border_;
}

void lane::
border (const border_sequence& s)
{
  this->border_ = s;
}

const lane::roadMark_sequence& lane::
roadMark () const
{
  return this->roadMark_;
}

lane::roadMark_sequence& lane::
roadMark ()
{
  return this->roadMark_;
}

void lane::
roadMark (const roadMark_sequence& s)
{
  this->roadMark_ = s;
}

const lane::material_sequence& lane::
material () const
{
  return this->material_;
}

lane::material_sequence& lane::
material ()
{
  return this->material_;
}

void lane::
material (const material_sequence& s)
{
  this->material_ = s;
}

const lane::visibility_sequence& lane::
visibility () const
{
  return this->visibility_;
}

lane::visibility_sequence& lane::
visibility ()
{
  return this->visibility_;
}

void lane::
visibility (const visibility_sequence& s)
{
  this->visibility_ = s;
}

const lane::speed_sequence& lane::
speed () const
{
  return this->speed_;
}

lane::speed_sequence& lane::
speed ()
{
  return this->speed_;
}

void lane::
speed (const speed_sequence& s)
{
  this->speed_ = s;
}

const lane::access_sequence& lane::
parkingSpace_access () const
{
  return this->parkingSpace_access_;
}

lane::access_sequence& lane::
parkingSpace_access ()
{
  return this->parkingSpace_access_;
}

void lane::
parkingSpace_access (const access_sequence& s)
{
  this->parkingSpace_access_ = s;
}

const lane::height_sequence& lane::
height () const
{
  return this->height_;
}

lane::height_sequence& lane::
height ()
{
  return this->height_;
}

void lane::
height (const height_sequence& s)
{
  this->height_ = s;
}

const lane::rule_sequence& lane::
rule () const
{
  return this->rule_;
}

lane::rule_sequence& lane::
rule ()
{
  return this->rule_;
}

void lane::
rule (const rule_sequence& s)
{
  this->rule_ = s;
}

const lane::userData_sequence& lane::
userData () const
{
  return this->userData_;
}

lane::userData_sequence& lane::
userData ()
{
  return this->userData_;
}

void lane::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const lane::include_sequence& lane::
include () const
{
  return this->include_;
}

lane::include_sequence& lane::
include ()
{
  return this->include_;
}

void lane::
include (const include_sequence& s)
{
  this->include_ = s;
}

const lane::id_optional& lane::
id () const
{
  return this->id_;
}

lane::id_optional& lane::
id ()
{
  return this->id_;
}

void lane::
id (const id_type& x)
{
  this->id_.set (x);
}

void lane::
id (const id_optional& x)
{
  this->id_ = x;
}

const lane::type_optional& lane::
type () const
{
  return this->type_;
}

lane::type_optional& lane::
type ()
{
  return this->type_;
}

void lane::
type (const type_type& x)
{
  this->type_.set (x);
}

void lane::
type (const type_optional& x)
{
  this->type_ = x;
}

void lane::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const lane::level_optional& lane::
level () const
{
  return this->level_;
}

lane::level_optional& lane::
level ()
{
  return this->level_;
}

void lane::
level (const level_type& x)
{
  this->level_.set (x);
}

void lane::
level (const level_optional& x)
{
  this->level_ = x;
}

void lane::
level (::std::auto_ptr< level_type > x)
{
  this->level_.set (x);
}


// centerLane
// 

const centerLane::link_optional& centerLane::
lane_link () const
{
  return this->lane_link_;
}

centerLane::link_optional& centerLane::
lane_link ()
{
  return this->lane_link_;
}

void centerLane::
lane_link (const link_type& x)
{
  this->lane_link_.set (x);
}

void centerLane::
lane_link (const link_optional& x)
{
  this->lane_link_ = x;
}

void centerLane::
lane_link (::std::auto_ptr< link_type > x)
{
  this->lane_link_.set (x);
}

const centerLane::roadMark_sequence& centerLane::
roadMark () const
{
  return this->roadMark_;
}

centerLane::roadMark_sequence& centerLane::
roadMark ()
{
  return this->roadMark_;
}

void centerLane::
roadMark (const roadMark_sequence& s)
{
  this->roadMark_ = s;
}

const centerLane::userData_sequence& centerLane::
userData () const
{
  return this->userData_;
}

centerLane::userData_sequence& centerLane::
userData ()
{
  return this->userData_;
}

void centerLane::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const centerLane::include_sequence& centerLane::
include () const
{
  return this->include_;
}

centerLane::include_sequence& centerLane::
include ()
{
  return this->include_;
}

void centerLane::
include (const include_sequence& s)
{
  this->include_ = s;
}

const centerLane::id_optional& centerLane::
id () const
{
  return this->id_;
}

centerLane::id_optional& centerLane::
id ()
{
  return this->id_;
}

void centerLane::
id (const id_type& x)
{
  this->id_.set (x);
}

void centerLane::
id (const id_optional& x)
{
  this->id_ = x;
}

const centerLane::type_optional& centerLane::
type () const
{
  return this->type_;
}

centerLane::type_optional& centerLane::
type ()
{
  return this->type_;
}

void centerLane::
type (const type_type& x)
{
  this->type_.set (x);
}

void centerLane::
type (const type_optional& x)
{
  this->type_ = x;
}

void centerLane::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const centerLane::level_optional& centerLane::
level () const
{
  return this->level_;
}

centerLane::level_optional& centerLane::
level ()
{
  return this->level_;
}

void centerLane::
level (const level_type& x)
{
  this->level_.set (x);
}

void centerLane::
level (const level_optional& x)
{
  this->level_ = x;
}

void centerLane::
level (::std::auto_ptr< level_type > x)
{
  this->level_.set (x);
}


// OpenDRIVE
// 

const OpenDRIVE::header_type& OpenDRIVE::
header () const
{
  return this->header_.get ();
}

OpenDRIVE::header_type& OpenDRIVE::
header ()
{
  return this->header_.get ();
}

void OpenDRIVE::
header (const header_type& x)
{
  this->header_.set (x);
}

void OpenDRIVE::
header (::std::auto_ptr< header_type > x)
{
  this->header_.set (x);
}

const OpenDRIVE::road_sequence& OpenDRIVE::
road () const
{
  return this->road_;
}

OpenDRIVE::road_sequence& OpenDRIVE::
road ()
{
  return this->road_;
}

void OpenDRIVE::
road (const road_sequence& s)
{
  this->road_ = s;
}

const OpenDRIVE::controller_sequence& OpenDRIVE::
controller () const
{
  return this->controller_;
}

OpenDRIVE::controller_sequence& OpenDRIVE::
controller ()
{
  return this->controller_;
}

void OpenDRIVE::
controller (const controller_sequence& s)
{
  this->controller_ = s;
}

const OpenDRIVE::junction_sequence& OpenDRIVE::
junction () const
{
  return this->junction_;
}

OpenDRIVE::junction_sequence& OpenDRIVE::
junction ()
{
  return this->junction_;
}

void OpenDRIVE::
junction (const junction_sequence& s)
{
  this->junction_ = s;
}

const OpenDRIVE::junctionGroup_sequence& OpenDRIVE::
junctionGroup () const
{
  return this->junctionGroup_;
}

OpenDRIVE::junctionGroup_sequence& OpenDRIVE::
junctionGroup ()
{
  return this->junctionGroup_;
}

void OpenDRIVE::
junctionGroup (const junctionGroup_sequence& s)
{
  this->junctionGroup_ = s;
}

const OpenDRIVE::station_sequence& OpenDRIVE::
station () const
{
  return this->station_;
}

OpenDRIVE::station_sequence& OpenDRIVE::
station ()
{
  return this->station_;
}

void OpenDRIVE::
station (const station_sequence& s)
{
  this->station_ = s;
}


// max_member
// 

max_member::
max_member (value v)
: ::xml_schema::string (_xsd_max_member_literals_[v])
{
}

max_member::
max_member (const char* v)
: ::xml_schema::string (v)
{
}

max_member::
max_member (const ::std::string& v)
: ::xml_schema::string (v)
{
}

max_member::
max_member (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

max_member::
max_member (const max_member& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

max_member& max_member::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_max_member_literals_[v]);

  return *this;
}


// max_member1
// 


// marking
// 

const marking::side_optional& marking::
side () const
{
  return this->side_;
}

marking::side_optional& marking::
side ()
{
  return this->side_;
}

void marking::
side (const side_type& x)
{
  this->side_.set (x);
}

void marking::
side (const side_optional& x)
{
  this->side_ = x;
}

void marking::
side (::std::auto_ptr< side_type > x)
{
  this->side_.set (x);
}

const marking::type_optional& marking::
type () const
{
  return this->type_;
}

marking::type_optional& marking::
type ()
{
  return this->type_;
}

void marking::
type (const type_type& x)
{
  this->type_.set (x);
}

void marking::
type (const type_optional& x)
{
  this->type_ = x;
}

void marking::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const marking::width_optional& marking::
width () const
{
  return this->width_;
}

marking::width_optional& marking::
width ()
{
  return this->width_;
}

void marking::
width (const width_type& x)
{
  this->width_.set (x);
}

void marking::
width (const width_optional& x)
{
  this->width_ = x;
}

const marking::color_optional& marking::
color () const
{
  return this->color_;
}

marking::color_optional& marking::
color ()
{
  return this->color_;
}

void marking::
color (const color_type& x)
{
  this->color_.set (x);
}

void marking::
color (const color_optional& x)
{
  this->color_ = x;
}

void marking::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}


// lane_link
// 

const lane_link::predecessor_optional& lane_link::
predecessor () const
{
  return this->predecessor_;
}

lane_link::predecessor_optional& lane_link::
predecessor ()
{
  return this->predecessor_;
}

void lane_link::
predecessor (const predecessor_type& x)
{
  this->predecessor_.set (x);
}

void lane_link::
predecessor (const predecessor_optional& x)
{
  this->predecessor_ = x;
}

void lane_link::
predecessor (::std::auto_ptr< predecessor_type > x)
{
  this->predecessor_.set (x);
}

const lane_link::successor_optional& lane_link::
successor () const
{
  return this->successor_;
}

lane_link::successor_optional& lane_link::
successor ()
{
  return this->successor_;
}

void lane_link::
successor (const successor_type& x)
{
  this->successor_.set (x);
}

void lane_link::
successor (const successor_optional& x)
{
  this->successor_ = x;
}

void lane_link::
successor (::std::auto_ptr< successor_type > x)
{
  this->successor_.set (x);
}

const lane_link::userData_sequence& lane_link::
userData () const
{
  return this->userData_;
}

lane_link::userData_sequence& lane_link::
userData ()
{
  return this->userData_;
}

void lane_link::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const lane_link::include_sequence& lane_link::
include () const
{
  return this->include_;
}

lane_link::include_sequence& lane_link::
include ()
{
  return this->include_;
}

void lane_link::
include (const include_sequence& s)
{
  this->include_ = s;
}


// width
// 

const width::userData_sequence& width::
userData () const
{
  return this->userData_;
}

width::userData_sequence& width::
userData ()
{
  return this->userData_;
}

void width::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const width::include_sequence& width::
include () const
{
  return this->include_;
}

width::include_sequence& width::
include ()
{
  return this->include_;
}

void width::
include (const include_sequence& s)
{
  this->include_ = s;
}

const width::sOffset_optional& width::
sOffset () const
{
  return this->sOffset_;
}

width::sOffset_optional& width::
sOffset ()
{
  return this->sOffset_;
}

void width::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void width::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const width::a_optional& width::
a () const
{
  return this->a_;
}

width::a_optional& width::
a ()
{
  return this->a_;
}

void width::
a (const a_type& x)
{
  this->a_.set (x);
}

void width::
a (const a_optional& x)
{
  this->a_ = x;
}

const width::b_optional& width::
b () const
{
  return this->b_;
}

width::b_optional& width::
b ()
{
  return this->b_;
}

void width::
b (const b_type& x)
{
  this->b_.set (x);
}

void width::
b (const b_optional& x)
{
  this->b_ = x;
}

const width::c_optional& width::
c () const
{
  return this->c_;
}

width::c_optional& width::
c ()
{
  return this->c_;
}

void width::
c (const c_type& x)
{
  this->c_.set (x);
}

void width::
c (const c_optional& x)
{
  this->c_ = x;
}

const width::d_optional& width::
d () const
{
  return this->d_;
}

width::d_optional& width::
d ()
{
  return this->d_;
}

void width::
d (const d_type& x)
{
  this->d_.set (x);
}

void width::
d (const d_optional& x)
{
  this->d_ = x;
}


// border
// 

const border::userData_sequence& border::
userData () const
{
  return this->userData_;
}

border::userData_sequence& border::
userData ()
{
  return this->userData_;
}

void border::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const border::include_sequence& border::
include () const
{
  return this->include_;
}

border::include_sequence& border::
include ()
{
  return this->include_;
}

void border::
include (const include_sequence& s)
{
  this->include_ = s;
}

const border::sOffset_optional& border::
sOffset () const
{
  return this->sOffset_;
}

border::sOffset_optional& border::
sOffset ()
{
  return this->sOffset_;
}

void border::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void border::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const border::a_optional& border::
a () const
{
  return this->a_;
}

border::a_optional& border::
a ()
{
  return this->a_;
}

void border::
a (const a_type& x)
{
  this->a_.set (x);
}

void border::
a (const a_optional& x)
{
  this->a_ = x;
}

const border::b_optional& border::
b () const
{
  return this->b_;
}

border::b_optional& border::
b ()
{
  return this->b_;
}

void border::
b (const b_type& x)
{
  this->b_.set (x);
}

void border::
b (const b_optional& x)
{
  this->b_ = x;
}

const border::c_optional& border::
c () const
{
  return this->c_;
}

border::c_optional& border::
c ()
{
  return this->c_;
}

void border::
c (const c_type& x)
{
  this->c_.set (x);
}

void border::
c (const c_optional& x)
{
  this->c_ = x;
}

const border::d_optional& border::
d () const
{
  return this->d_;
}

border::d_optional& border::
d ()
{
  return this->d_;
}

void border::
d (const d_type& x)
{
  this->d_.set (x);
}

void border::
d (const d_optional& x)
{
  this->d_ = x;
}


// roadMark
// 

const roadMark::type_optional& roadMark::
type () const
{
  return this->type_;
}

roadMark::type_optional& roadMark::
type ()
{
  return this->type_;
}

void roadMark::
type (const type_type& x)
{
  this->type_.set (x);
}

void roadMark::
type (const type_optional& x)
{
  this->type_ = x;
}

void roadMark::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const roadMark::userData_sequence& roadMark::
userData () const
{
  return this->userData_;
}

roadMark::userData_sequence& roadMark::
userData ()
{
  return this->userData_;
}

void roadMark::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const roadMark::include_sequence& roadMark::
include () const
{
  return this->include_;
}

roadMark::include_sequence& roadMark::
include ()
{
  return this->include_;
}

void roadMark::
include (const include_sequence& s)
{
  this->include_ = s;
}

const roadMark::sOffset_optional& roadMark::
sOffset () const
{
  return this->sOffset_;
}

roadMark::sOffset_optional& roadMark::
sOffset ()
{
  return this->sOffset_;
}

void roadMark::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void roadMark::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const roadMark::type1_optional& roadMark::
type1 () const
{
  return this->type1_;
}

roadMark::type1_optional& roadMark::
type1 ()
{
  return this->type1_;
}

void roadMark::
type1 (const type1_type& x)
{
  this->type1_.set (x);
}

void roadMark::
type1 (const type1_optional& x)
{
  this->type1_ = x;
}

void roadMark::
type1 (::std::auto_ptr< type1_type > x)
{
  this->type1_.set (x);
}

const roadMark::weight_optional& roadMark::
weight () const
{
  return this->weight_;
}

roadMark::weight_optional& roadMark::
weight ()
{
  return this->weight_;
}

void roadMark::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void roadMark::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void roadMark::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}

const roadMark::color_optional& roadMark::
color () const
{
  return this->color_;
}

roadMark::color_optional& roadMark::
color ()
{
  return this->color_;
}

void roadMark::
color (const color_type& x)
{
  this->color_.set (x);
}

void roadMark::
color (const color_optional& x)
{
  this->color_ = x;
}

void roadMark::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const roadMark::material_optional& roadMark::
material () const
{
  return this->material_;
}

roadMark::material_optional& roadMark::
material ()
{
  return this->material_;
}

void roadMark::
material (const material_type& x)
{
  this->material_.set (x);
}

void roadMark::
material (const material_optional& x)
{
  this->material_ = x;
}

void roadMark::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}

const roadMark::width_optional& roadMark::
width () const
{
  return this->width_;
}

roadMark::width_optional& roadMark::
width ()
{
  return this->width_;
}

void roadMark::
width (const width_type& x)
{
  this->width_.set (x);
}

void roadMark::
width (const width_optional& x)
{
  this->width_ = x;
}

const roadMark::laneChange_optional& roadMark::
laneChange () const
{
  return this->laneChange_;
}

roadMark::laneChange_optional& roadMark::
laneChange ()
{
  return this->laneChange_;
}

void roadMark::
laneChange (const laneChange_type& x)
{
  this->laneChange_.set (x);
}

void roadMark::
laneChange (const laneChange_optional& x)
{
  this->laneChange_ = x;
}

void roadMark::
laneChange (::std::auto_ptr< laneChange_type > x)
{
  this->laneChange_.set (x);
}

const roadMark::height_optional& roadMark::
height () const
{
  return this->height_;
}

roadMark::height_optional& roadMark::
height ()
{
  return this->height_;
}

void roadMark::
height (const height_type& x)
{
  this->height_.set (x);
}

void roadMark::
height (const height_optional& x)
{
  this->height_ = x;
}


// material
// 

const material::userData_sequence& material::
userData () const
{
  return this->userData_;
}

material::userData_sequence& material::
userData ()
{
  return this->userData_;
}

void material::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const material::include_sequence& material::
include () const
{
  return this->include_;
}

material::include_sequence& material::
include ()
{
  return this->include_;
}

void material::
include (const include_sequence& s)
{
  this->include_ = s;
}

const material::sOffset_optional& material::
sOffset () const
{
  return this->sOffset_;
}

material::sOffset_optional& material::
sOffset ()
{
  return this->sOffset_;
}

void material::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void material::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const material::surface_optional& material::
surface () const
{
  return this->surface_;
}

material::surface_optional& material::
surface ()
{
  return this->surface_;
}

void material::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void material::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void material::
surface (::std::auto_ptr< surface_type > x)
{
  this->surface_.set (x);
}

const material::friction_optional& material::
friction () const
{
  return this->friction_;
}

material::friction_optional& material::
friction ()
{
  return this->friction_;
}

void material::
friction (const friction_type& x)
{
  this->friction_.set (x);
}

void material::
friction (const friction_optional& x)
{
  this->friction_ = x;
}

const material::roughness_optional& material::
roughness () const
{
  return this->roughness_;
}

material::roughness_optional& material::
roughness ()
{
  return this->roughness_;
}

void material::
roughness (const roughness_type& x)
{
  this->roughness_.set (x);
}

void material::
roughness (const roughness_optional& x)
{
  this->roughness_ = x;
}


// visibility
// 

const visibility::userData_sequence& visibility::
userData () const
{
  return this->userData_;
}

visibility::userData_sequence& visibility::
userData ()
{
  return this->userData_;
}

void visibility::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const visibility::include_sequence& visibility::
include () const
{
  return this->include_;
}

visibility::include_sequence& visibility::
include ()
{
  return this->include_;
}

void visibility::
include (const include_sequence& s)
{
  this->include_ = s;
}

const visibility::sOffset_optional& visibility::
sOffset () const
{
  return this->sOffset_;
}

visibility::sOffset_optional& visibility::
sOffset ()
{
  return this->sOffset_;
}

void visibility::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void visibility::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const visibility::forward_optional& visibility::
forward () const
{
  return this->forward_;
}

visibility::forward_optional& visibility::
forward ()
{
  return this->forward_;
}

void visibility::
forward (const forward_type& x)
{
  this->forward_.set (x);
}

void visibility::
forward (const forward_optional& x)
{
  this->forward_ = x;
}

const visibility::back_optional& visibility::
back () const
{
  return this->back_;
}

visibility::back_optional& visibility::
back ()
{
  return this->back_;
}

void visibility::
back (const back_type& x)
{
  this->back_.set (x);
}

void visibility::
back (const back_optional& x)
{
  this->back_ = x;
}

const visibility::left_optional& visibility::
left () const
{
  return this->left_;
}

visibility::left_optional& visibility::
left ()
{
  return this->left_;
}

void visibility::
left (const left_type& x)
{
  this->left_.set (x);
}

void visibility::
left (const left_optional& x)
{
  this->left_ = x;
}

const visibility::right_optional& visibility::
right () const
{
  return this->right_;
}

visibility::right_optional& visibility::
right ()
{
  return this->right_;
}

void visibility::
right (const right_type& x)
{
  this->right_.set (x);
}

void visibility::
right (const right_optional& x)
{
  this->right_ = x;
}


// speed
// 

const speed::userData_sequence& speed::
userData () const
{
  return this->userData_;
}

speed::userData_sequence& speed::
userData ()
{
  return this->userData_;
}

void speed::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const speed::include_sequence& speed::
include () const
{
  return this->include_;
}

speed::include_sequence& speed::
include ()
{
  return this->include_;
}

void speed::
include (const include_sequence& s)
{
  this->include_ = s;
}

const speed::sOffset_optional& speed::
sOffset () const
{
  return this->sOffset_;
}

speed::sOffset_optional& speed::
sOffset ()
{
  return this->sOffset_;
}

void speed::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void speed::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const speed::max_optional& speed::
t_max () const
{
  return this->t_max_;
}

speed::max_optional& speed::
t_max ()
{
  return this->t_max_;
}

void speed::
t_max (const max_type& x)
{
  this->t_max_.set (x);
}

void speed::
t_max (const max_optional& x)
{
  this->t_max_ = x;
}

const speed::unit_optional& speed::
unit () const
{
  return this->unit_;
}

speed::unit_optional& speed::
unit ()
{
  return this->unit_;
}

void speed::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void speed::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void speed::
unit (::std::auto_ptr< unit_type > x)
{
  this->unit_.set (x);
}


// access1
// 

const access1::userData_sequence& access1::
userData () const
{
  return this->userData_;
}

access1::userData_sequence& access1::
userData ()
{
  return this->userData_;
}

void access1::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const access1::include_sequence& access1::
include () const
{
  return this->include_;
}

access1::include_sequence& access1::
include ()
{
  return this->include_;
}

void access1::
include (const include_sequence& s)
{
  this->include_ = s;
}

const access1::sOffset_optional& access1::
sOffset () const
{
  return this->sOffset_;
}

access1::sOffset_optional& access1::
sOffset ()
{
  return this->sOffset_;
}

void access1::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void access1::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const access1::restriction_optional& access1::
restriction () const
{
  return this->restriction_;
}

access1::restriction_optional& access1::
restriction ()
{
  return this->restriction_;
}

void access1::
restriction (const restriction_type& x)
{
  this->restriction_.set (x);
}

void access1::
restriction (const restriction_optional& x)
{
  this->restriction_ = x;
}

void access1::
restriction (::std::auto_ptr< restriction_type > x)
{
  this->restriction_.set (x);
}


// height
// 

const height::userData_sequence& height::
userData () const
{
  return this->userData_;
}

height::userData_sequence& height::
userData ()
{
  return this->userData_;
}

void height::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const height::include_sequence& height::
include () const
{
  return this->include_;
}

height::include_sequence& height::
include ()
{
  return this->include_;
}

void height::
include (const include_sequence& s)
{
  this->include_ = s;
}

const height::sOffset_optional& height::
sOffset () const
{
  return this->sOffset_;
}

height::sOffset_optional& height::
sOffset ()
{
  return this->sOffset_;
}

void height::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void height::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const height::inner_optional& height::
inner () const
{
  return this->inner_;
}

height::inner_optional& height::
inner ()
{
  return this->inner_;
}

void height::
inner (const inner_type& x)
{
  this->inner_.set (x);
}

void height::
inner (const inner_optional& x)
{
  this->inner_ = x;
}

const height::outer_optional& height::
outer () const
{
  return this->outer_;
}

height::outer_optional& height::
outer ()
{
  return this->outer_;
}

void height::
outer (const outer_type& x)
{
  this->outer_.set (x);
}

void height::
outer (const outer_optional& x)
{
  this->outer_ = x;
}


// rule1
// 

const rule1::userData_sequence& rule1::
userData () const
{
  return this->userData_;
}

rule1::userData_sequence& rule1::
userData ()
{
  return this->userData_;
}

void rule1::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const rule1::include_sequence& rule1::
include () const
{
  return this->include_;
}

rule1::include_sequence& rule1::
include ()
{
  return this->include_;
}

void rule1::
include (const include_sequence& s)
{
  this->include_ = s;
}

const rule1::sOffset_optional& rule1::
sOffset () const
{
  return this->sOffset_;
}

rule1::sOffset_optional& rule1::
sOffset ()
{
  return this->sOffset_;
}

void rule1::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void rule1::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const rule1::value_optional& rule1::
value () const
{
  return this->value_;
}

rule1::value_optional& rule1::
value ()
{
  return this->value_;
}

void rule1::
value (const value_type& x)
{
  this->value_.set (x);
}

void rule1::
value (const value_optional& x)
{
  this->value_ = x;
}

void rule1::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// link1
// 

const link1::predecessor_optional& link1::
predecessor () const
{
  return this->predecessor_;
}

link1::predecessor_optional& link1::
predecessor ()
{
  return this->predecessor_;
}

void link1::
predecessor (const predecessor_type& x)
{
  this->predecessor_.set (x);
}

void link1::
predecessor (const predecessor_optional& x)
{
  this->predecessor_ = x;
}

void link1::
predecessor (::std::auto_ptr< predecessor_type > x)
{
  this->predecessor_.set (x);
}

const link1::successor_optional& link1::
successor () const
{
  return this->successor_;
}

link1::successor_optional& link1::
successor ()
{
  return this->successor_;
}

void link1::
successor (const successor_type& x)
{
  this->successor_.set (x);
}

void link1::
successor (const successor_optional& x)
{
  this->successor_ = x;
}

void link1::
successor (::std::auto_ptr< successor_type > x)
{
  this->successor_.set (x);
}

const link1::userData_sequence& link1::
userData () const
{
  return this->userData_;
}

link1::userData_sequence& link1::
userData ()
{
  return this->userData_;
}

void link1::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const link1::include_sequence& link1::
include () const
{
  return this->include_;
}

link1::include_sequence& link1::
include ()
{
  return this->include_;
}

void link1::
include (const include_sequence& s)
{
  this->include_ = s;
}


// roadMark1
// 

const roadMark1::type_optional& roadMark1::
type () const
{
  return this->type_;
}

roadMark1::type_optional& roadMark1::
type ()
{
  return this->type_;
}

void roadMark1::
type (const type_type& x)
{
  this->type_.set (x);
}

void roadMark1::
type (const type_optional& x)
{
  this->type_ = x;
}

void roadMark1::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const roadMark1::userData_sequence& roadMark1::
userData () const
{
  return this->userData_;
}

roadMark1::userData_sequence& roadMark1::
userData ()
{
  return this->userData_;
}

void roadMark1::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const roadMark1::include_sequence& roadMark1::
include () const
{
  return this->include_;
}

roadMark1::include_sequence& roadMark1::
include ()
{
  return this->include_;
}

void roadMark1::
include (const include_sequence& s)
{
  this->include_ = s;
}

const roadMark1::sOffset_optional& roadMark1::
sOffset () const
{
  return this->sOffset_;
}

roadMark1::sOffset_optional& roadMark1::
sOffset ()
{
  return this->sOffset_;
}

void roadMark1::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void roadMark1::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const roadMark1::type1_optional& roadMark1::
type1 () const
{
  return this->type1_;
}

roadMark1::type1_optional& roadMark1::
type1 ()
{
  return this->type1_;
}

void roadMark1::
type1 (const type1_type& x)
{
  this->type1_.set (x);
}

void roadMark1::
type1 (const type1_optional& x)
{
  this->type1_ = x;
}

void roadMark1::
type1 (::std::auto_ptr< type1_type > x)
{
  this->type1_.set (x);
}

const roadMark1::weight_optional& roadMark1::
weight () const
{
  return this->weight_;
}

roadMark1::weight_optional& roadMark1::
weight ()
{
  return this->weight_;
}

void roadMark1::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void roadMark1::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void roadMark1::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}

const roadMark1::color_optional& roadMark1::
color () const
{
  return this->color_;
}

roadMark1::color_optional& roadMark1::
color ()
{
  return this->color_;
}

void roadMark1::
color (const color_type& x)
{
  this->color_.set (x);
}

void roadMark1::
color (const color_optional& x)
{
  this->color_ = x;
}

void roadMark1::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const roadMark1::material_optional& roadMark1::
material () const
{
  return this->material_;
}

roadMark1::material_optional& roadMark1::
material ()
{
  return this->material_;
}

void roadMark1::
material (const material_type& x)
{
  this->material_.set (x);
}

void roadMark1::
material (const material_optional& x)
{
  this->material_ = x;
}

void roadMark1::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}

const roadMark1::width_optional& roadMark1::
width () const
{
  return this->width_;
}

roadMark1::width_optional& roadMark1::
width ()
{
  return this->width_;
}

void roadMark1::
width (const width_type& x)
{
  this->width_.set (x);
}

void roadMark1::
width (const width_optional& x)
{
  this->width_ = x;
}

const roadMark1::laneChange_optional& roadMark1::
laneChange () const
{
  return this->laneChange_;
}

roadMark1::laneChange_optional& roadMark1::
laneChange ()
{
  return this->laneChange_;
}

void roadMark1::
laneChange (const laneChange_type& x)
{
  this->laneChange_.set (x);
}

void roadMark1::
laneChange (const laneChange_optional& x)
{
  this->laneChange_ = x;
}

void roadMark1::
laneChange (::std::auto_ptr< laneChange_type > x)
{
  this->laneChange_.set (x);
}

const roadMark1::height_optional& roadMark1::
height () const
{
  return this->height_;
}

roadMark1::height_optional& roadMark1::
height ()
{
  return this->height_;
}

void roadMark1::
height (const height_type& x)
{
  this->height_.set (x);
}

void roadMark1::
height (const height_optional& x)
{
  this->height_ = x;
}


// header
// 

const header::geoReference_optional& header::
geoReference () const
{
  return this->geoReference_;
}

header::geoReference_optional& header::
geoReference ()
{
  return this->geoReference_;
}

void header::
geoReference (const geoReference_type& x)
{
  this->geoReference_.set (x);
}

void header::
geoReference (const geoReference_optional& x)
{
  this->geoReference_ = x;
}

void header::
geoReference (::std::auto_ptr< geoReference_type > x)
{
  this->geoReference_.set (x);
}

const header::userData_sequence& header::
userData () const
{
  return this->userData_;
}

header::userData_sequence& header::
userData ()
{
  return this->userData_;
}

void header::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const header::include_sequence& header::
include () const
{
  return this->include_;
}

header::include_sequence& header::
include ()
{
  return this->include_;
}

void header::
include (const include_sequence& s)
{
  this->include_ = s;
}

const header::revMajor_optional& header::
revMajor () const
{
  return this->revMajor_;
}

header::revMajor_optional& header::
revMajor ()
{
  return this->revMajor_;
}

void header::
revMajor (const revMajor_type& x)
{
  this->revMajor_.set (x);
}

void header::
revMajor (const revMajor_optional& x)
{
  this->revMajor_ = x;
}

const header::revMinor_optional& header::
revMinor () const
{
  return this->revMinor_;
}

header::revMinor_optional& header::
revMinor ()
{
  return this->revMinor_;
}

void header::
revMinor (const revMinor_type& x)
{
  this->revMinor_.set (x);
}

void header::
revMinor (const revMinor_optional& x)
{
  this->revMinor_ = x;
}

const header::name_optional& header::
name () const
{
  return this->name_;
}

header::name_optional& header::
name ()
{
  return this->name_;
}

void header::
name (const name_type& x)
{
  this->name_.set (x);
}

void header::
name (const name_optional& x)
{
  this->name_ = x;
}

void header::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const header::version_optional& header::
version () const
{
  return this->version_;
}

header::version_optional& header::
version ()
{
  return this->version_;
}

void header::
version (const version_type& x)
{
  this->version_.set (x);
}

void header::
version (const version_optional& x)
{
  this->version_ = x;
}

const header::date_optional& header::
date () const
{
  return this->date_;
}

header::date_optional& header::
date ()
{
  return this->date_;
}

void header::
date (const date_type& x)
{
  this->date_.set (x);
}

void header::
date (const date_optional& x)
{
  this->date_ = x;
}

void header::
date (::std::auto_ptr< date_type > x)
{
  this->date_.set (x);
}

const header::north_optional& header::
north () const
{
  return this->north_;
}

header::north_optional& header::
north ()
{
  return this->north_;
}

void header::
north (const north_type& x)
{
  this->north_.set (x);
}

void header::
north (const north_optional& x)
{
  this->north_ = x;
}

const header::south_optional& header::
south () const
{
  return this->south_;
}

header::south_optional& header::
south ()
{
  return this->south_;
}

void header::
south (const south_type& x)
{
  this->south_.set (x);
}

void header::
south (const south_optional& x)
{
  this->south_ = x;
}

const header::east_optional& header::
east () const
{
  return this->east_;
}

header::east_optional& header::
east ()
{
  return this->east_;
}

void header::
east (const east_type& x)
{
  this->east_.set (x);
}

void header::
east (const east_optional& x)
{
  this->east_ = x;
}

const header::west_optional& header::
west () const
{
  return this->west_;
}

header::west_optional& header::
west ()
{
  return this->west_;
}

void header::
west (const west_type& x)
{
  this->west_.set (x);
}

void header::
west (const west_optional& x)
{
  this->west_ = x;
}

const header::vendor_optional& header::
vendor () const
{
  return this->vendor_;
}

header::vendor_optional& header::
vendor ()
{
  return this->vendor_;
}

void header::
vendor (const vendor_type& x)
{
  this->vendor_.set (x);
}

void header::
vendor (const vendor_optional& x)
{
  this->vendor_ = x;
}

void header::
vendor (::std::auto_ptr< vendor_type > x)
{
  this->vendor_.set (x);
}


// road
// 

const road::link_optional& road::
lane_link () const
{
  return this->lane_link_;
}

road::link_optional& road::
lane_link ()
{
  return this->lane_link_;
}

void road::
lane_link (const link_type& x)
{
  this->lane_link_.set (x);
}

void road::
lane_link (const link_optional& x)
{
  this->lane_link_ = x;
}

void road::
lane_link (::std::auto_ptr< link_type > x)
{
  this->lane_link_.set (x);
}

const road::type_sequence& road::
type () const
{
  return this->type_;
}

road::type_sequence& road::
type ()
{
  return this->type_;
}

void road::
type (const type_sequence& s)
{
  this->type_ = s;
}

const road::planView_type& road::
planView () const
{
  return this->planView_.get ();
}

road::planView_type& road::
planView ()
{
  return this->planView_.get ();
}

void road::
planView (const planView_type& x)
{
  this->planView_.set (x);
}

void road::
planView (::std::auto_ptr< planView_type > x)
{
  this->planView_.set (x);
}

const road::elevationProfile_optional& road::
elevationProfile () const
{
  return this->elevationProfile_;
}

road::elevationProfile_optional& road::
elevationProfile ()
{
  return this->elevationProfile_;
}

void road::
elevationProfile (const elevationProfile_type& x)
{
  this->elevationProfile_.set (x);
}

void road::
elevationProfile (const elevationProfile_optional& x)
{
  this->elevationProfile_ = x;
}

void road::
elevationProfile (::std::auto_ptr< elevationProfile_type > x)
{
  this->elevationProfile_.set (x);
}

const road::lateralProfile_optional& road::
lateralProfile () const
{
  return this->lateralProfile_;
}

road::lateralProfile_optional& road::
lateralProfile ()
{
  return this->lateralProfile_;
}

void road::
lateralProfile (const lateralProfile_type& x)
{
  this->lateralProfile_.set (x);
}

void road::
lateralProfile (const lateralProfile_optional& x)
{
  this->lateralProfile_ = x;
}

void road::
lateralProfile (::std::auto_ptr< lateralProfile_type > x)
{
  this->lateralProfile_.set (x);
}

const road::lanes_type& road::
lanes () const
{
  return this->lanes_.get ();
}

road::lanes_type& road::
lanes ()
{
  return this->lanes_.get ();
}

void road::
lanes (const lanes_type& x)
{
  this->lanes_.set (x);
}

void road::
lanes (::std::auto_ptr< lanes_type > x)
{
  this->lanes_.set (x);
}

const road::objects_optional& road::
objects () const
{
  return this->objects_;
}

road::objects_optional& road::
objects ()
{
  return this->objects_;
}

void road::
objects (const objects_type& x)
{
  this->objects_.set (x);
}

void road::
objects (const objects_optional& x)
{
  this->objects_ = x;
}

void road::
objects (::std::auto_ptr< objects_type > x)
{
  this->objects_.set (x);
}

const road::signals_optional& road::
signals () const
{
  return this->signals_;
}

road::signals_optional& road::
signals ()
{
  return this->signals_;
}

void road::
signals (const signals_type& x)
{
  this->signals_.set (x);
}

void road::
signals (const signals_optional& x)
{
  this->signals_ = x;
}

void road::
signals (::std::auto_ptr< signals_type > x)
{
  this->signals_.set (x);
}

const road::surface_optional& road::
surface () const
{
  return this->surface_;
}

road::surface_optional& road::
surface ()
{
  return this->surface_;
}

void road::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void road::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void road::
surface (::std::auto_ptr< surface_type > x)
{
  this->surface_.set (x);
}

const road::railroad_optional& road::
railroad () const
{
  return this->railroad_;
}

road::railroad_optional& road::
railroad ()
{
  return this->railroad_;
}

void road::
railroad (const railroad_type& x)
{
  this->railroad_.set (x);
}

void road::
railroad (const railroad_optional& x)
{
  this->railroad_ = x;
}

void road::
railroad (::std::auto_ptr< railroad_type > x)
{
  this->railroad_.set (x);
}

const road::userData_sequence& road::
userData () const
{
  return this->userData_;
}

road::userData_sequence& road::
userData ()
{
  return this->userData_;
}

void road::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const road::include_sequence& road::
include () const
{
  return this->include_;
}

road::include_sequence& road::
include ()
{
  return this->include_;
}

void road::
include (const include_sequence& s)
{
  this->include_ = s;
}

const road::name_optional& road::
name () const
{
  return this->name_;
}

road::name_optional& road::
name ()
{
  return this->name_;
}

void road::
name (const name_type& x)
{
  this->name_.set (x);
}

void road::
name (const name_optional& x)
{
  this->name_ = x;
}

void road::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const road::length_optional& road::
length () const
{
  return this->length_;
}

road::length_optional& road::
length ()
{
  return this->length_;
}

void road::
length (const length_type& x)
{
  this->length_.set (x);
}

void road::
length (const length_optional& x)
{
  this->length_ = x;
}

const road::id_optional& road::
id () const
{
  return this->id_;
}

road::id_optional& road::
id ()
{
  return this->id_;
}

void road::
id (const id_type& x)
{
  this->id_.set (x);
}

void road::
id (const id_optional& x)
{
  this->id_ = x;
}

void road::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const road::junction_optional& road::
junction () const
{
  return this->junction_;
}

road::junction_optional& road::
junction ()
{
  return this->junction_;
}

void road::
junction (const junction_type& x)
{
  this->junction_.set (x);
}

void road::
junction (const junction_optional& x)
{
  this->junction_ = x;
}

void road::
junction (::std::auto_ptr< junction_type > x)
{
  this->junction_.set (x);
}


// controller
// 

const controller::control_sequence& controller::
control () const
{
  return this->control_;
}

controller::control_sequence& controller::
control ()
{
  return this->control_;
}

void controller::
control (const control_sequence& s)
{
  this->control_ = s;
}

const controller::userData_sequence& controller::
userData () const
{
  return this->userData_;
}

controller::userData_sequence& controller::
userData ()
{
  return this->userData_;
}

void controller::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const controller::include_sequence& controller::
include () const
{
  return this->include_;
}

controller::include_sequence& controller::
include ()
{
  return this->include_;
}

void controller::
include (const include_sequence& s)
{
  this->include_ = s;
}

const controller::id_optional& controller::
id () const
{
  return this->id_;
}

controller::id_optional& controller::
id ()
{
  return this->id_;
}

void controller::
id (const id_type& x)
{
  this->id_.set (x);
}

void controller::
id (const id_optional& x)
{
  this->id_ = x;
}

void controller::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const controller::name_optional& controller::
name () const
{
  return this->name_;
}

controller::name_optional& controller::
name ()
{
  return this->name_;
}

void controller::
name (const name_type& x)
{
  this->name_.set (x);
}

void controller::
name (const name_optional& x)
{
  this->name_ = x;
}

void controller::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const controller::sequence_optional& controller::
sequence () const
{
  return this->sequence_;
}

controller::sequence_optional& controller::
sequence ()
{
  return this->sequence_;
}

void controller::
sequence (const sequence_type& x)
{
  this->sequence_.set (x);
}

void controller::
sequence (const sequence_optional& x)
{
  this->sequence_ = x;
}


// junction
// 

const junction::connection_sequence& junction::
connection () const
{
  return this->connection_;
}

junction::connection_sequence& junction::
connection ()
{
  return this->connection_;
}

void junction::
connection (const connection_sequence& s)
{
  this->connection_ = s;
}

const junction::priority_sequence& junction::
priority () const
{
  return this->priority_;
}

junction::priority_sequence& junction::
priority ()
{
  return this->priority_;
}

void junction::
priority (const priority_sequence& s)
{
  this->priority_ = s;
}

const junction::controller_sequence& junction::
controller () const
{
  return this->controller_;
}

junction::controller_sequence& junction::
controller ()
{
  return this->controller_;
}

void junction::
controller (const controller_sequence& s)
{
  this->controller_ = s;
}

const junction::userData_sequence& junction::
userData () const
{
  return this->userData_;
}

junction::userData_sequence& junction::
userData ()
{
  return this->userData_;
}

void junction::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const junction::include_sequence& junction::
include () const
{
  return this->include_;
}

junction::include_sequence& junction::
include ()
{
  return this->include_;
}

void junction::
include (const include_sequence& s)
{
  this->include_ = s;
}

const junction::name_optional& junction::
name () const
{
  return this->name_;
}

junction::name_optional& junction::
name ()
{
  return this->name_;
}

void junction::
name (const name_type& x)
{
  this->name_.set (x);
}

void junction::
name (const name_optional& x)
{
  this->name_ = x;
}

void junction::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const junction::id_optional& junction::
id () const
{
  return this->id_;
}

junction::id_optional& junction::
id ()
{
  return this->id_;
}

void junction::
id (const id_type& x)
{
  this->id_.set (x);
}

void junction::
id (const id_optional& x)
{
  this->id_ = x;
}

void junction::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}


// junctionGroup
// 

const junctionGroup::junctionReference_sequence& junctionGroup::
junctionReference () const
{
  return this->junctionReference_;
}

junctionGroup::junctionReference_sequence& junctionGroup::
junctionReference ()
{
  return this->junctionReference_;
}

void junctionGroup::
junctionReference (const junctionReference_sequence& s)
{
  this->junctionReference_ = s;
}

const junctionGroup::userData_sequence& junctionGroup::
userData () const
{
  return this->userData_;
}

junctionGroup::userData_sequence& junctionGroup::
userData ()
{
  return this->userData_;
}

void junctionGroup::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const junctionGroup::include_sequence& junctionGroup::
include () const
{
  return this->include_;
}

junctionGroup::include_sequence& junctionGroup::
include ()
{
  return this->include_;
}

void junctionGroup::
include (const include_sequence& s)
{
  this->include_ = s;
}

const junctionGroup::name_optional& junctionGroup::
name () const
{
  return this->name_;
}

junctionGroup::name_optional& junctionGroup::
name ()
{
  return this->name_;
}

void junctionGroup::
name (const name_type& x)
{
  this->name_.set (x);
}

void junctionGroup::
name (const name_optional& x)
{
  this->name_ = x;
}

void junctionGroup::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const junctionGroup::id_optional& junctionGroup::
id () const
{
  return this->id_;
}

junctionGroup::id_optional& junctionGroup::
id ()
{
  return this->id_;
}

void junctionGroup::
id (const id_type& x)
{
  this->id_.set (x);
}

void junctionGroup::
id (const id_optional& x)
{
  this->id_ = x;
}

void junctionGroup::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const junctionGroup::type_optional& junctionGroup::
type () const
{
  return this->type_;
}

junctionGroup::type_optional& junctionGroup::
type ()
{
  return this->type_;
}

void junctionGroup::
type (const type_type& x)
{
  this->type_.set (x);
}

void junctionGroup::
type (const type_optional& x)
{
  this->type_ = x;
}

void junctionGroup::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// station
// 

const station::platform_sequence& station::
platform () const
{
  return this->platform_;
}

station::platform_sequence& station::
platform ()
{
  return this->platform_;
}

void station::
platform (const platform_sequence& s)
{
  this->platform_ = s;
}

const station::userData_sequence& station::
userData () const
{
  return this->userData_;
}

station::userData_sequence& station::
userData ()
{
  return this->userData_;
}

void station::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const station::include_sequence& station::
include () const
{
  return this->include_;
}

station::include_sequence& station::
include ()
{
  return this->include_;
}

void station::
include (const include_sequence& s)
{
  this->include_ = s;
}

const station::name_optional& station::
name () const
{
  return this->name_;
}

station::name_optional& station::
name ()
{
  return this->name_;
}

void station::
name (const name_type& x)
{
  this->name_.set (x);
}

void station::
name (const name_optional& x)
{
  this->name_ = x;
}

void station::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const station::id_optional& station::
id () const
{
  return this->id_;
}

station::id_optional& station::
id ()
{
  return this->id_;
}

void station::
id (const id_type& x)
{
  this->id_.set (x);
}

void station::
id (const id_optional& x)
{
  this->id_ = x;
}

void station::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const station::type_optional& station::
type () const
{
  return this->type_;
}

station::type_optional& station::
type ()
{
  return this->type_;
}

void station::
type (const type_type& x)
{
  this->type_.set (x);
}

void station::
type (const type_optional& x)
{
  this->type_ = x;
}

void station::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// predecessor
// 

const predecessor::id_optional& predecessor::
id () const
{
  return this->id_;
}

predecessor::id_optional& predecessor::
id ()
{
  return this->id_;
}

void predecessor::
id (const id_type& x)
{
  this->id_.set (x);
}

void predecessor::
id (const id_optional& x)
{
  this->id_ = x;
}


// successor
// 

const successor::id_optional& successor::
id () const
{
  return this->id_;
}

successor::id_optional& successor::
id ()
{
  return this->id_;
}

void successor::
id (const id_type& x)
{
  this->id_.set (x);
}

void successor::
id (const id_optional& x)
{
  this->id_ = x;
}


// type
// 

const type::line_sequence& type::
line () const
{
  return this->line_;
}

type::line_sequence& type::
line ()
{
  return this->line_;
}

void type::
line (const line_sequence& s)
{
  this->line_ = s;
}

const type::name_optional& type::
name () const
{
  return this->name_;
}

type::name_optional& type::
name ()
{
  return this->name_;
}

void type::
name (const name_type& x)
{
  this->name_.set (x);
}

void type::
name (const name_optional& x)
{
  this->name_ = x;
}

void type::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const type::width_optional& type::
width () const
{
  return this->width_;
}

type::width_optional& type::
width ()
{
  return this->width_;
}

void type::
width (const width_type& x)
{
  this->width_.set (x);
}

void type::
width (const width_optional& x)
{
  this->width_ = x;
}


// type1
// 

const type1::line_sequence& type1::
line () const
{
  return this->line_;
}

type1::line_sequence& type1::
line ()
{
  return this->line_;
}

void type1::
line (const line_sequence& s)
{
  this->line_ = s;
}

const type1::name_optional& type1::
name () const
{
  return this->name_;
}

type1::name_optional& type1::
name ()
{
  return this->name_;
}

void type1::
name (const name_type& x)
{
  this->name_.set (x);
}

void type1::
name (const name_optional& x)
{
  this->name_ = x;
}

void type1::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const type1::width_optional& type1::
width () const
{
  return this->width_;
}

type1::width_optional& type1::
width ()
{
  return this->width_;
}

void type1::
width (const width_type& x)
{
  this->width_.set (x);
}

void type1::
width (const width_optional& x)
{
  this->width_ = x;
}


// link2
// 

const link2::predecessor_optional& link2::
predecessor () const
{
  return this->predecessor_;
}

link2::predecessor_optional& link2::
predecessor ()
{
  return this->predecessor_;
}

void link2::
predecessor (const predecessor_type& x)
{
  this->predecessor_.set (x);
}

void link2::
predecessor (const predecessor_optional& x)
{
  this->predecessor_ = x;
}

void link2::
predecessor (::std::auto_ptr< predecessor_type > x)
{
  this->predecessor_.set (x);
}

const link2::successor_optional& link2::
successor () const
{
  return this->successor_;
}

link2::successor_optional& link2::
successor ()
{
  return this->successor_;
}

void link2::
successor (const successor_type& x)
{
  this->successor_.set (x);
}

void link2::
successor (const successor_optional& x)
{
  this->successor_ = x;
}

void link2::
successor (::std::auto_ptr< successor_type > x)
{
  this->successor_.set (x);
}

const link2::neighbor_sequence& link2::
neighbor () const
{
  return this->neighbor_;
}

link2::neighbor_sequence& link2::
neighbor ()
{
  return this->neighbor_;
}

void link2::
neighbor (const neighbor_sequence& s)
{
  this->neighbor_ = s;
}

const link2::userData_sequence& link2::
userData () const
{
  return this->userData_;
}

link2::userData_sequence& link2::
userData ()
{
  return this->userData_;
}

void link2::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const link2::include_sequence& link2::
include () const
{
  return this->include_;
}

link2::include_sequence& link2::
include ()
{
  return this->include_;
}

void link2::
include (const include_sequence& s)
{
  this->include_ = s;
}


// type2
// 

const type2::speed_optional& type2::
speed () const
{
  return this->speed_;
}

type2::speed_optional& type2::
speed ()
{
  return this->speed_;
}

void type2::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

void type2::
speed (const speed_optional& x)
{
  this->speed_ = x;
}

void type2::
speed (::std::auto_ptr< speed_type > x)
{
  this->speed_.set (x);
}

const type2::userData_sequence& type2::
userData () const
{
  return this->userData_;
}

type2::userData_sequence& type2::
userData ()
{
  return this->userData_;
}

void type2::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const type2::include_sequence& type2::
include () const
{
  return this->include_;
}

type2::include_sequence& type2::
include ()
{
  return this->include_;
}

void type2::
include (const include_sequence& s)
{
  this->include_ = s;
}

const type2::s_optional& type2::
s () const
{
  return this->s_;
}

type2::s_optional& type2::
s ()
{
  return this->s_;
}

void type2::
s (const s_type& x)
{
  this->s_.set (x);
}

void type2::
s (const s_optional& x)
{
  this->s_ = x;
}

const type2::type_optional& type2::
type () const
{
  return this->type_;
}

type2::type_optional& type2::
type ()
{
  return this->type_;
}

void type2::
type (const type_type& x)
{
  this->type_.set (x);
}

void type2::
type (const type_optional& x)
{
  this->type_ = x;
}

void type2::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// planView
// 

const planView::geometry_sequence& planView::
geometry () const
{
  return this->geometry_;
}

planView::geometry_sequence& planView::
geometry ()
{
  return this->geometry_;
}

void planView::
geometry (const geometry_sequence& s)
{
  this->geometry_ = s;
}


// elevationProfile
// 

const elevationProfile::elevation_sequence& elevationProfile::
elevation () const
{
  return this->elevation_;
}

elevationProfile::elevation_sequence& elevationProfile::
elevation ()
{
  return this->elevation_;
}

void elevationProfile::
elevation (const elevation_sequence& s)
{
  this->elevation_ = s;
}

const elevationProfile::userData_sequence& elevationProfile::
userData () const
{
  return this->userData_;
}

elevationProfile::userData_sequence& elevationProfile::
userData ()
{
  return this->userData_;
}

void elevationProfile::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const elevationProfile::include_sequence& elevationProfile::
include () const
{
  return this->include_;
}

elevationProfile::include_sequence& elevationProfile::
include ()
{
  return this->include_;
}

void elevationProfile::
include (const include_sequence& s)
{
  this->include_ = s;
}


// lateralProfile
// 

const lateralProfile::superelevation_sequence& lateralProfile::
superelevation () const
{
  return this->superelevation_;
}

lateralProfile::superelevation_sequence& lateralProfile::
superelevation ()
{
  return this->superelevation_;
}

void lateralProfile::
superelevation (const superelevation_sequence& s)
{
  this->superelevation_ = s;
}

const lateralProfile::crossfall_sequence& lateralProfile::
crossfall () const
{
  return this->crossfall_;
}

lateralProfile::crossfall_sequence& lateralProfile::
crossfall ()
{
  return this->crossfall_;
}

void lateralProfile::
crossfall (const crossfall_sequence& s)
{
  this->crossfall_ = s;
}

const lateralProfile::shape_sequence& lateralProfile::
shape () const
{
  return this->shape_;
}

lateralProfile::shape_sequence& lateralProfile::
shape ()
{
  return this->shape_;
}

void lateralProfile::
shape (const shape_sequence& s)
{
  this->shape_ = s;
}

const lateralProfile::userData_sequence& lateralProfile::
userData () const
{
  return this->userData_;
}

lateralProfile::userData_sequence& lateralProfile::
userData ()
{
  return this->userData_;
}

void lateralProfile::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const lateralProfile::include_sequence& lateralProfile::
include () const
{
  return this->include_;
}

lateralProfile::include_sequence& lateralProfile::
include ()
{
  return this->include_;
}

void lateralProfile::
include (const include_sequence& s)
{
  this->include_ = s;
}


// lanes
// 

const lanes::laneOffset_sequence& lanes::
laneOffset () const
{
  return this->laneOffset_;
}

lanes::laneOffset_sequence& lanes::
laneOffset ()
{
  return this->laneOffset_;
}

void lanes::
laneOffset (const laneOffset_sequence& s)
{
  this->laneOffset_ = s;
}

const lanes::laneSection_sequence& lanes::
laneSection () const
{
  return this->laneSection_;
}

lanes::laneSection_sequence& lanes::
laneSection ()
{
  return this->laneSection_;
}

void lanes::
laneSection (const laneSection_sequence& s)
{
  this->laneSection_ = s;
}


// objects
// 

const objects::object_sequence& objects::
object () const
{
  return this->object_;
}

objects::object_sequence& objects::
object ()
{
  return this->object_;
}

void objects::
object (const object_sequence& s)
{
  this->object_ = s;
}

const objects::objectReference_sequence& objects::
objectReference () const
{
  return this->objectReference_;
}

objects::objectReference_sequence& objects::
objectReference ()
{
  return this->objectReference_;
}

void objects::
objectReference (const objectReference_sequence& s)
{
  this->objectReference_ = s;
}

const objects::tunnel_sequence& objects::
tunnel () const
{
  return this->tunnel_;
}

objects::tunnel_sequence& objects::
tunnel ()
{
  return this->tunnel_;
}

void objects::
tunnel (const tunnel_sequence& s)
{
  this->tunnel_ = s;
}

const objects::bridge_sequence& objects::
bridge () const
{
  return this->bridge_;
}

objects::bridge_sequence& objects::
bridge ()
{
  return this->bridge_;
}

void objects::
bridge (const bridge_sequence& s)
{
  this->bridge_ = s;
}

const objects::userData_sequence& objects::
userData () const
{
  return this->userData_;
}

objects::userData_sequence& objects::
userData ()
{
  return this->userData_;
}

void objects::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const objects::include_sequence& objects::
include () const
{
  return this->include_;
}

objects::include_sequence& objects::
include ()
{
  return this->include_;
}

void objects::
include (const include_sequence& s)
{
  this->include_ = s;
}


// signals
// 

const signals::signal_sequence& signals::
signal () const
{
  return this->signal_;
}

signals::signal_sequence& signals::
signal ()
{
  return this->signal_;
}

void signals::
signal (const signal_sequence& s)
{
  this->signal_ = s;
}

const signals::signalReference_sequence& signals::
signalReference () const
{
  return this->signalReference_;
}

signals::signalReference_sequence& signals::
signalReference ()
{
  return this->signalReference_;
}

void signals::
signalReference (const signalReference_sequence& s)
{
  this->signalReference_ = s;
}

const signals::userData_sequence& signals::
userData () const
{
  return this->userData_;
}

signals::userData_sequence& signals::
userData ()
{
  return this->userData_;
}

void signals::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const signals::include_sequence& signals::
include () const
{
  return this->include_;
}

signals::include_sequence& signals::
include ()
{
  return this->include_;
}

void signals::
include (const include_sequence& s)
{
  this->include_ = s;
}


// surface
// 

const surface::CRG_sequence& surface::
CRG () const
{
  return this->CRG_;
}

surface::CRG_sequence& surface::
CRG ()
{
  return this->CRG_;
}

void surface::
CRG (const CRG_sequence& s)
{
  this->CRG_ = s;
}

const surface::userData_sequence& surface::
userData () const
{
  return this->userData_;
}

surface::userData_sequence& surface::
userData ()
{
  return this->userData_;
}

void surface::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const surface::include_sequence& surface::
include () const
{
  return this->include_;
}

surface::include_sequence& surface::
include ()
{
  return this->include_;
}

void surface::
include (const include_sequence& s)
{
  this->include_ = s;
}


// railroad
// 

const railroad::switch_sequence& railroad::
switch_ () const
{
  return this->switch__;
}

railroad::switch_sequence& railroad::
switch_ ()
{
  return this->switch__;
}

void railroad::
switch_ (const switch_sequence& s)
{
  this->switch__ = s;
}

const railroad::userData_sequence& railroad::
userData () const
{
  return this->userData_;
}

railroad::userData_sequence& railroad::
userData ()
{
  return this->userData_;
}

void railroad::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const railroad::include_sequence& railroad::
include () const
{
  return this->include_;
}

railroad::include_sequence& railroad::
include ()
{
  return this->include_;
}

void railroad::
include (const include_sequence& s)
{
  this->include_ = s;
}


// control
// 

const control::userData_sequence& control::
userData () const
{
  return this->userData_;
}

control::userData_sequence& control::
userData ()
{
  return this->userData_;
}

void control::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const control::include_sequence& control::
include () const
{
  return this->include_;
}

control::include_sequence& control::
include ()
{
  return this->include_;
}

void control::
include (const include_sequence& s)
{
  this->include_ = s;
}

const control::signalId_optional& control::
signalId () const
{
  return this->signalId_;
}

control::signalId_optional& control::
signalId ()
{
  return this->signalId_;
}

void control::
signalId (const signalId_type& x)
{
  this->signalId_.set (x);
}

void control::
signalId (const signalId_optional& x)
{
  this->signalId_ = x;
}

void control::
signalId (::std::auto_ptr< signalId_type > x)
{
  this->signalId_.set (x);
}

const control::type_optional& control::
type () const
{
  return this->type_;
}

control::type_optional& control::
type ()
{
  return this->type_;
}

void control::
type (const type_type& x)
{
  this->type_.set (x);
}

void control::
type (const type_optional& x)
{
  this->type_ = x;
}

void control::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// connection
// 

const connection::laneLink_sequence& connection::
laneLink () const
{
  return this->laneLink_;
}

connection::laneLink_sequence& connection::
laneLink ()
{
  return this->laneLink_;
}

void connection::
laneLink (const laneLink_sequence& s)
{
  this->laneLink_ = s;
}

const connection::userData_sequence& connection::
userData () const
{
  return this->userData_;
}

connection::userData_sequence& connection::
userData ()
{
  return this->userData_;
}

void connection::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const connection::include_sequence& connection::
include () const
{
  return this->include_;
}

connection::include_sequence& connection::
include ()
{
  return this->include_;
}

void connection::
include (const include_sequence& s)
{
  this->include_ = s;
}

const connection::id_optional& connection::
id () const
{
  return this->id_;
}

connection::id_optional& connection::
id ()
{
  return this->id_;
}

void connection::
id (const id_type& x)
{
  this->id_.set (x);
}

void connection::
id (const id_optional& x)
{
  this->id_ = x;
}

void connection::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const connection::incomingRoad_optional& connection::
incomingRoad () const
{
  return this->incomingRoad_;
}

connection::incomingRoad_optional& connection::
incomingRoad ()
{
  return this->incomingRoad_;
}

void connection::
incomingRoad (const incomingRoad_type& x)
{
  this->incomingRoad_.set (x);
}

void connection::
incomingRoad (const incomingRoad_optional& x)
{
  this->incomingRoad_ = x;
}

void connection::
incomingRoad (::std::auto_ptr< incomingRoad_type > x)
{
  this->incomingRoad_.set (x);
}

const connection::connectingRoad_optional& connection::
connectingRoad () const
{
  return this->connectingRoad_;
}

connection::connectingRoad_optional& connection::
connectingRoad ()
{
  return this->connectingRoad_;
}

void connection::
connectingRoad (const connectingRoad_type& x)
{
  this->connectingRoad_.set (x);
}

void connection::
connectingRoad (const connectingRoad_optional& x)
{
  this->connectingRoad_ = x;
}

void connection::
connectingRoad (::std::auto_ptr< connectingRoad_type > x)
{
  this->connectingRoad_.set (x);
}

const connection::contactPoint_optional& connection::
contactPoint () const
{
  return this->contactPoint_;
}

connection::contactPoint_optional& connection::
contactPoint ()
{
  return this->contactPoint_;
}

void connection::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void connection::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void connection::
contactPoint (::std::auto_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (x);
}


// priority
// 

const priority::userData_sequence& priority::
userData () const
{
  return this->userData_;
}

priority::userData_sequence& priority::
userData ()
{
  return this->userData_;
}

void priority::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const priority::include_sequence& priority::
include () const
{
  return this->include_;
}

priority::include_sequence& priority::
include ()
{
  return this->include_;
}

void priority::
include (const include_sequence& s)
{
  this->include_ = s;
}

const priority::high_optional& priority::
high () const
{
  return this->high_;
}

priority::high_optional& priority::
high ()
{
  return this->high_;
}

void priority::
high (const high_type& x)
{
  this->high_.set (x);
}

void priority::
high (const high_optional& x)
{
  this->high_ = x;
}

void priority::
high (::std::auto_ptr< high_type > x)
{
  this->high_.set (x);
}

const priority::low_optional& priority::
low () const
{
  return this->low_;
}

priority::low_optional& priority::
low ()
{
  return this->low_;
}

void priority::
low (const low_type& x)
{
  this->low_.set (x);
}

void priority::
low (const low_optional& x)
{
  this->low_ = x;
}

void priority::
low (::std::auto_ptr< low_type > x)
{
  this->low_.set (x);
}


// controller1
// 

const controller1::userData_sequence& controller1::
userData () const
{
  return this->userData_;
}

controller1::userData_sequence& controller1::
userData ()
{
  return this->userData_;
}

void controller1::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const controller1::include_sequence& controller1::
include () const
{
  return this->include_;
}

controller1::include_sequence& controller1::
include ()
{
  return this->include_;
}

void controller1::
include (const include_sequence& s)
{
  this->include_ = s;
}

const controller1::id_optional& controller1::
id () const
{
  return this->id_;
}

controller1::id_optional& controller1::
id ()
{
  return this->id_;
}

void controller1::
id (const id_type& x)
{
  this->id_.set (x);
}

void controller1::
id (const id_optional& x)
{
  this->id_ = x;
}

void controller1::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const controller1::type_optional& controller1::
type () const
{
  return this->type_;
}

controller1::type_optional& controller1::
type ()
{
  return this->type_;
}

void controller1::
type (const type_type& x)
{
  this->type_.set (x);
}

void controller1::
type (const type_optional& x)
{
  this->type_ = x;
}

void controller1::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const controller1::sequence_optional& controller1::
sequence () const
{
  return this->sequence_;
}

controller1::sequence_optional& controller1::
sequence ()
{
  return this->sequence_;
}

void controller1::
sequence (const sequence_type& x)
{
  this->sequence_.set (x);
}

void controller1::
sequence (const sequence_optional& x)
{
  this->sequence_ = x;
}


// junctionReference
// 

const junctionReference::junction_optional& junctionReference::
junction () const
{
  return this->junction_;
}

junctionReference::junction_optional& junctionReference::
junction ()
{
  return this->junction_;
}

void junctionReference::
junction (const junction_type& x)
{
  this->junction_.set (x);
}

void junctionReference::
junction (const junction_optional& x)
{
  this->junction_ = x;
}

void junctionReference::
junction (::std::auto_ptr< junction_type > x)
{
  this->junction_.set (x);
}


// platform
// 

const platform::segment_sequence& platform::
segment () const
{
  return this->segment_;
}

platform::segment_sequence& platform::
segment ()
{
  return this->segment_;
}

void platform::
segment (const segment_sequence& s)
{
  this->segment_ = s;
}

const platform::name_optional& platform::
name () const
{
  return this->name_;
}

platform::name_optional& platform::
name ()
{
  return this->name_;
}

void platform::
name (const name_type& x)
{
  this->name_.set (x);
}

void platform::
name (const name_optional& x)
{
  this->name_ = x;
}

void platform::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const platform::id_optional& platform::
id () const
{
  return this->id_;
}

platform::id_optional& platform::
id ()
{
  return this->id_;
}

void platform::
id (const id_type& x)
{
  this->id_.set (x);
}

void platform::
id (const id_optional& x)
{
  this->id_ = x;
}

void platform::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}


// line
// 

const line::length_optional& line::
length () const
{
  return this->length_;
}

line::length_optional& line::
length ()
{
  return this->length_;
}

void line::
length (const length_type& x)
{
  this->length_.set (x);
}

void line::
length (const length_optional& x)
{
  this->length_ = x;
}

const line::space_optional& line::
space () const
{
  return this->space_;
}

line::space_optional& line::
space ()
{
  return this->space_;
}

void line::
space (const space_type& x)
{
  this->space_.set (x);
}

void line::
space (const space_optional& x)
{
  this->space_ = x;
}

const line::tOffset_optional& line::
tOffset () const
{
  return this->tOffset_;
}

line::tOffset_optional& line::
tOffset ()
{
  return this->tOffset_;
}

void line::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

void line::
tOffset (const tOffset_optional& x)
{
  this->tOffset_ = x;
}

const line::sOffset_optional& line::
sOffset () const
{
  return this->sOffset_;
}

line::sOffset_optional& line::
sOffset ()
{
  return this->sOffset_;
}

void line::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void line::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const line::rule_optional& line::
rule () const
{
  return this->rule_;
}

line::rule_optional& line::
rule ()
{
  return this->rule_;
}

void line::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void line::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void line::
rule (::std::auto_ptr< rule_type > x)
{
  this->rule_.set (x);
}

const line::width_optional& line::
width () const
{
  return this->width_;
}

line::width_optional& line::
width ()
{
  return this->width_;
}

void line::
width (const width_type& x)
{
  this->width_.set (x);
}

void line::
width (const width_optional& x)
{
  this->width_ = x;
}


// predecessor1
// 

const predecessor1::elementType_optional& predecessor1::
elementType () const
{
  return this->elementType_;
}

predecessor1::elementType_optional& predecessor1::
elementType ()
{
  return this->elementType_;
}

void predecessor1::
elementType (const elementType_type& x)
{
  this->elementType_.set (x);
}

void predecessor1::
elementType (const elementType_optional& x)
{
  this->elementType_ = x;
}

void predecessor1::
elementType (::std::auto_ptr< elementType_type > x)
{
  this->elementType_.set (x);
}

const predecessor1::elementId_optional& predecessor1::
elementId () const
{
  return this->elementId_;
}

predecessor1::elementId_optional& predecessor1::
elementId ()
{
  return this->elementId_;
}

void predecessor1::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void predecessor1::
elementId (const elementId_optional& x)
{
  this->elementId_ = x;
}

void predecessor1::
elementId (::std::auto_ptr< elementId_type > x)
{
  this->elementId_.set (x);
}

const predecessor1::contactPoint_optional& predecessor1::
contactPoint () const
{
  return this->contactPoint_;
}

predecessor1::contactPoint_optional& predecessor1::
contactPoint ()
{
  return this->contactPoint_;
}

void predecessor1::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void predecessor1::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void predecessor1::
contactPoint (::std::auto_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (x);
}


// successor1
// 

const successor1::elementType_optional& successor1::
elementType () const
{
  return this->elementType_;
}

successor1::elementType_optional& successor1::
elementType ()
{
  return this->elementType_;
}

void successor1::
elementType (const elementType_type& x)
{
  this->elementType_.set (x);
}

void successor1::
elementType (const elementType_optional& x)
{
  this->elementType_ = x;
}

void successor1::
elementType (::std::auto_ptr< elementType_type > x)
{
  this->elementType_.set (x);
}

const successor1::elementId_optional& successor1::
elementId () const
{
  return this->elementId_;
}

successor1::elementId_optional& successor1::
elementId ()
{
  return this->elementId_;
}

void successor1::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void successor1::
elementId (const elementId_optional& x)
{
  this->elementId_ = x;
}

void successor1::
elementId (::std::auto_ptr< elementId_type > x)
{
  this->elementId_.set (x);
}

const successor1::contactPoint_optional& successor1::
contactPoint () const
{
  return this->contactPoint_;
}

successor1::contactPoint_optional& successor1::
contactPoint ()
{
  return this->contactPoint_;
}

void successor1::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void successor1::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void successor1::
contactPoint (::std::auto_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (x);
}


// neighbor
// 

const neighbor::side_optional& neighbor::
side () const
{
  return this->side_;
}

neighbor::side_optional& neighbor::
side ()
{
  return this->side_;
}

void neighbor::
side (const side_type& x)
{
  this->side_.set (x);
}

void neighbor::
side (const side_optional& x)
{
  this->side_ = x;
}

void neighbor::
side (::std::auto_ptr< side_type > x)
{
  this->side_.set (x);
}

const neighbor::elementId_optional& neighbor::
elementId () const
{
  return this->elementId_;
}

neighbor::elementId_optional& neighbor::
elementId ()
{
  return this->elementId_;
}

void neighbor::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void neighbor::
elementId (const elementId_optional& x)
{
  this->elementId_ = x;
}

void neighbor::
elementId (::std::auto_ptr< elementId_type > x)
{
  this->elementId_.set (x);
}

const neighbor::direction_optional& neighbor::
direction () const
{
  return this->direction_;
}

neighbor::direction_optional& neighbor::
direction ()
{
  return this->direction_;
}

void neighbor::
direction (const direction_type& x)
{
  this->direction_.set (x);
}

void neighbor::
direction (const direction_optional& x)
{
  this->direction_ = x;
}

void neighbor::
direction (::std::auto_ptr< direction_type > x)
{
  this->direction_.set (x);
}


// speed1
// 

const speed1::max_optional& speed1::
t_max () const
{
  return this->t_max_;
}

speed1::max_optional& speed1::
t_max ()
{
  return this->t_max_;
}

void speed1::
t_max (const max_type& x)
{
  this->t_max_.set (x);
}

void speed1::
t_max (const max_optional& x)
{
  this->t_max_ = x;
}

void speed1::
t_max (::std::auto_ptr< max_type > x)
{
  this->t_max_.set (x);
}

const speed1::unit_optional& speed1::
unit () const
{
  return this->unit_;
}

speed1::unit_optional& speed1::
unit ()
{
  return this->unit_;
}

void speed1::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void speed1::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void speed1::
unit (::std::auto_ptr< unit_type > x)
{
  this->unit_.set (x);
}


// geometry
// 

const geometry::line_optional& geometry::
line () const
{
  return this->line_;
}

geometry::line_optional& geometry::
line ()
{
  return this->line_;
}

void geometry::
line (const line_type& x)
{
  this->line_.set (x);
}

void geometry::
line (const line_optional& x)
{
  this->line_ = x;
}

void geometry::
line (::std::auto_ptr< line_type > x)
{
  this->line_.set (x);
}

const geometry::spiral_optional& geometry::
spiral () const
{
  return this->spiral_;
}

geometry::spiral_optional& geometry::
spiral ()
{
  return this->spiral_;
}

void geometry::
spiral (const spiral_type& x)
{
  this->spiral_.set (x);
}

void geometry::
spiral (const spiral_optional& x)
{
  this->spiral_ = x;
}

void geometry::
spiral (::std::auto_ptr< spiral_type > x)
{
  this->spiral_.set (x);
}

const geometry::arc_optional& geometry::
arc () const
{
  return this->arc_;
}

geometry::arc_optional& geometry::
arc ()
{
  return this->arc_;
}

void geometry::
arc (const arc_type& x)
{
  this->arc_.set (x);
}

void geometry::
arc (const arc_optional& x)
{
  this->arc_ = x;
}

void geometry::
arc (::std::auto_ptr< arc_type > x)
{
  this->arc_.set (x);
}

const geometry::poly3_optional& geometry::
poly3 () const
{
  return this->poly3_;
}

geometry::poly3_optional& geometry::
poly3 ()
{
  return this->poly3_;
}

void geometry::
poly3 (const poly3_type& x)
{
  this->poly3_.set (x);
}

void geometry::
poly3 (const poly3_optional& x)
{
  this->poly3_ = x;
}

void geometry::
poly3 (::std::auto_ptr< poly3_type > x)
{
  this->poly3_.set (x);
}

const geometry::paramPoly3_optional& geometry::
paramPoly3 () const
{
  return this->paramPoly3_;
}

geometry::paramPoly3_optional& geometry::
paramPoly3 ()
{
  return this->paramPoly3_;
}

void geometry::
paramPoly3 (const paramPoly3_type& x)
{
  this->paramPoly3_.set (x);
}

void geometry::
paramPoly3 (const paramPoly3_optional& x)
{
  this->paramPoly3_ = x;
}

void geometry::
paramPoly3 (::std::auto_ptr< paramPoly3_type > x)
{
  this->paramPoly3_.set (x);
}

const geometry::userData_sequence& geometry::
userData () const
{
  return this->userData_;
}

geometry::userData_sequence& geometry::
userData ()
{
  return this->userData_;
}

void geometry::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const geometry::include_sequence& geometry::
include () const
{
  return this->include_;
}

geometry::include_sequence& geometry::
include ()
{
  return this->include_;
}

void geometry::
include (const include_sequence& s)
{
  this->include_ = s;
}

const geometry::s_optional& geometry::
s () const
{
  return this->s_;
}

geometry::s_optional& geometry::
s ()
{
  return this->s_;
}

void geometry::
s (const s_type& x)
{
  this->s_.set (x);
}

void geometry::
s (const s_optional& x)
{
  this->s_ = x;
}

const geometry::x_optional& geometry::
x () const
{
  return this->x_;
}

geometry::x_optional& geometry::
x ()
{
  return this->x_;
}

void geometry::
x (const x_type& x)
{
  this->x_.set (x);
}

void geometry::
x (const x_optional& x)
{
  this->x_ = x;
}

const geometry::y_optional& geometry::
y () const
{
  return this->y_;
}

geometry::y_optional& geometry::
y ()
{
  return this->y_;
}

void geometry::
y (const y_type& x)
{
  this->y_.set (x);
}

void geometry::
y (const y_optional& x)
{
  this->y_ = x;
}

const geometry::hdg_optional& geometry::
hdg () const
{
  return this->hdg_;
}

geometry::hdg_optional& geometry::
hdg ()
{
  return this->hdg_;
}

void geometry::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}

void geometry::
hdg (const hdg_optional& x)
{
  this->hdg_ = x;
}

const geometry::length_optional& geometry::
length () const
{
  return this->length_;
}

geometry::length_optional& geometry::
length ()
{
  return this->length_;
}

void geometry::
length (const length_type& x)
{
  this->length_.set (x);
}

void geometry::
length (const length_optional& x)
{
  this->length_ = x;
}


// elevation
// 

const elevation::userData_sequence& elevation::
userData () const
{
  return this->userData_;
}

elevation::userData_sequence& elevation::
userData ()
{
  return this->userData_;
}

void elevation::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const elevation::include_sequence& elevation::
include () const
{
  return this->include_;
}

elevation::include_sequence& elevation::
include ()
{
  return this->include_;
}

void elevation::
include (const include_sequence& s)
{
  this->include_ = s;
}

const elevation::s_optional& elevation::
s () const
{
  return this->s_;
}

elevation::s_optional& elevation::
s ()
{
  return this->s_;
}

void elevation::
s (const s_type& x)
{
  this->s_.set (x);
}

void elevation::
s (const s_optional& x)
{
  this->s_ = x;
}

const elevation::a_optional& elevation::
a () const
{
  return this->a_;
}

elevation::a_optional& elevation::
a ()
{
  return this->a_;
}

void elevation::
a (const a_type& x)
{
  this->a_.set (x);
}

void elevation::
a (const a_optional& x)
{
  this->a_ = x;
}

const elevation::b_optional& elevation::
b () const
{
  return this->b_;
}

elevation::b_optional& elevation::
b ()
{
  return this->b_;
}

void elevation::
b (const b_type& x)
{
  this->b_.set (x);
}

void elevation::
b (const b_optional& x)
{
  this->b_ = x;
}

const elevation::c_optional& elevation::
c () const
{
  return this->c_;
}

elevation::c_optional& elevation::
c ()
{
  return this->c_;
}

void elevation::
c (const c_type& x)
{
  this->c_.set (x);
}

void elevation::
c (const c_optional& x)
{
  this->c_ = x;
}

const elevation::d_optional& elevation::
d () const
{
  return this->d_;
}

elevation::d_optional& elevation::
d ()
{
  return this->d_;
}

void elevation::
d (const d_type& x)
{
  this->d_.set (x);
}

void elevation::
d (const d_optional& x)
{
  this->d_ = x;
}


// superelevation
// 

const superelevation::userData_sequence& superelevation::
userData () const
{
  return this->userData_;
}

superelevation::userData_sequence& superelevation::
userData ()
{
  return this->userData_;
}

void superelevation::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const superelevation::include_sequence& superelevation::
include () const
{
  return this->include_;
}

superelevation::include_sequence& superelevation::
include ()
{
  return this->include_;
}

void superelevation::
include (const include_sequence& s)
{
  this->include_ = s;
}

const superelevation::s_optional& superelevation::
s () const
{
  return this->s_;
}

superelevation::s_optional& superelevation::
s ()
{
  return this->s_;
}

void superelevation::
s (const s_type& x)
{
  this->s_.set (x);
}

void superelevation::
s (const s_optional& x)
{
  this->s_ = x;
}

const superelevation::a_optional& superelevation::
a () const
{
  return this->a_;
}

superelevation::a_optional& superelevation::
a ()
{
  return this->a_;
}

void superelevation::
a (const a_type& x)
{
  this->a_.set (x);
}

void superelevation::
a (const a_optional& x)
{
  this->a_ = x;
}

const superelevation::b_optional& superelevation::
b () const
{
  return this->b_;
}

superelevation::b_optional& superelevation::
b ()
{
  return this->b_;
}

void superelevation::
b (const b_type& x)
{
  this->b_.set (x);
}

void superelevation::
b (const b_optional& x)
{
  this->b_ = x;
}

const superelevation::c_optional& superelevation::
c () const
{
  return this->c_;
}

superelevation::c_optional& superelevation::
c ()
{
  return this->c_;
}

void superelevation::
c (const c_type& x)
{
  this->c_.set (x);
}

void superelevation::
c (const c_optional& x)
{
  this->c_ = x;
}

const superelevation::d_optional& superelevation::
d () const
{
  return this->d_;
}

superelevation::d_optional& superelevation::
d ()
{
  return this->d_;
}

void superelevation::
d (const d_type& x)
{
  this->d_.set (x);
}

void superelevation::
d (const d_optional& x)
{
  this->d_ = x;
}


// crossfall
// 

const crossfall::userData_sequence& crossfall::
userData () const
{
  return this->userData_;
}

crossfall::userData_sequence& crossfall::
userData ()
{
  return this->userData_;
}

void crossfall::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const crossfall::include_sequence& crossfall::
include () const
{
  return this->include_;
}

crossfall::include_sequence& crossfall::
include ()
{
  return this->include_;
}

void crossfall::
include (const include_sequence& s)
{
  this->include_ = s;
}

const crossfall::side_optional& crossfall::
side () const
{
  return this->side_;
}

crossfall::side_optional& crossfall::
side ()
{
  return this->side_;
}

void crossfall::
side (const side_type& x)
{
  this->side_.set (x);
}

void crossfall::
side (const side_optional& x)
{
  this->side_ = x;
}

void crossfall::
side (::std::auto_ptr< side_type > x)
{
  this->side_.set (x);
}

const crossfall::s_optional& crossfall::
s () const
{
  return this->s_;
}

crossfall::s_optional& crossfall::
s ()
{
  return this->s_;
}

void crossfall::
s (const s_type& x)
{
  this->s_.set (x);
}

void crossfall::
s (const s_optional& x)
{
  this->s_ = x;
}

const crossfall::a_optional& crossfall::
a () const
{
  return this->a_;
}

crossfall::a_optional& crossfall::
a ()
{
  return this->a_;
}

void crossfall::
a (const a_type& x)
{
  this->a_.set (x);
}

void crossfall::
a (const a_optional& x)
{
  this->a_ = x;
}

const crossfall::b_optional& crossfall::
b () const
{
  return this->b_;
}

crossfall::b_optional& crossfall::
b ()
{
  return this->b_;
}

void crossfall::
b (const b_type& x)
{
  this->b_.set (x);
}

void crossfall::
b (const b_optional& x)
{
  this->b_ = x;
}

const crossfall::c_optional& crossfall::
c () const
{
  return this->c_;
}

crossfall::c_optional& crossfall::
c ()
{
  return this->c_;
}

void crossfall::
c (const c_type& x)
{
  this->c_.set (x);
}

void crossfall::
c (const c_optional& x)
{
  this->c_ = x;
}

const crossfall::d_optional& crossfall::
d () const
{
  return this->d_;
}

crossfall::d_optional& crossfall::
d ()
{
  return this->d_;
}

void crossfall::
d (const d_type& x)
{
  this->d_.set (x);
}

void crossfall::
d (const d_optional& x)
{
  this->d_ = x;
}


// shape
// 

const shape::userData_sequence& shape::
userData () const
{
  return this->userData_;
}

shape::userData_sequence& shape::
userData ()
{
  return this->userData_;
}

void shape::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const shape::include_sequence& shape::
include () const
{
  return this->include_;
}

shape::include_sequence& shape::
include ()
{
  return this->include_;
}

void shape::
include (const include_sequence& s)
{
  this->include_ = s;
}

const shape::s_optional& shape::
s () const
{
  return this->s_;
}

shape::s_optional& shape::
s ()
{
  return this->s_;
}

void shape::
s (const s_type& x)
{
  this->s_.set (x);
}

void shape::
s (const s_optional& x)
{
  this->s_ = x;
}

const shape::t_optional& shape::
t () const
{
  return this->t_;
}

shape::t_optional& shape::
t ()
{
  return this->t_;
}

void shape::
t (const t_type& x)
{
  this->t_.set (x);
}

void shape::
t (const t_optional& x)
{
  this->t_ = x;
}

const shape::a_optional& shape::
a () const
{
  return this->a_;
}

shape::a_optional& shape::
a ()
{
  return this->a_;
}

void shape::
a (const a_type& x)
{
  this->a_.set (x);
}

void shape::
a (const a_optional& x)
{
  this->a_ = x;
}

const shape::b_optional& shape::
b () const
{
  return this->b_;
}

shape::b_optional& shape::
b ()
{
  return this->b_;
}

void shape::
b (const b_type& x)
{
  this->b_.set (x);
}

void shape::
b (const b_optional& x)
{
  this->b_ = x;
}

const shape::c_optional& shape::
c () const
{
  return this->c_;
}

shape::c_optional& shape::
c ()
{
  return this->c_;
}

void shape::
c (const c_type& x)
{
  this->c_.set (x);
}

void shape::
c (const c_optional& x)
{
  this->c_ = x;
}

const shape::d_optional& shape::
d () const
{
  return this->d_;
}

shape::d_optional& shape::
d ()
{
  return this->d_;
}

void shape::
d (const d_type& x)
{
  this->d_.set (x);
}

void shape::
d (const d_optional& x)
{
  this->d_ = x;
}


// laneOffset
// 

const laneOffset::userData_sequence& laneOffset::
userData () const
{
  return this->userData_;
}

laneOffset::userData_sequence& laneOffset::
userData ()
{
  return this->userData_;
}

void laneOffset::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const laneOffset::include_sequence& laneOffset::
include () const
{
  return this->include_;
}

laneOffset::include_sequence& laneOffset::
include ()
{
  return this->include_;
}

void laneOffset::
include (const include_sequence& s)
{
  this->include_ = s;
}

const laneOffset::s_optional& laneOffset::
s () const
{
  return this->s_;
}

laneOffset::s_optional& laneOffset::
s ()
{
  return this->s_;
}

void laneOffset::
s (const s_type& x)
{
  this->s_.set (x);
}

void laneOffset::
s (const s_optional& x)
{
  this->s_ = x;
}

const laneOffset::a_optional& laneOffset::
a () const
{
  return this->a_;
}

laneOffset::a_optional& laneOffset::
a ()
{
  return this->a_;
}

void laneOffset::
a (const a_type& x)
{
  this->a_.set (x);
}

void laneOffset::
a (const a_optional& x)
{
  this->a_ = x;
}

const laneOffset::b_optional& laneOffset::
b () const
{
  return this->b_;
}

laneOffset::b_optional& laneOffset::
b ()
{
  return this->b_;
}

void laneOffset::
b (const b_type& x)
{
  this->b_.set (x);
}

void laneOffset::
b (const b_optional& x)
{
  this->b_ = x;
}

const laneOffset::c_optional& laneOffset::
c () const
{
  return this->c_;
}

laneOffset::c_optional& laneOffset::
c ()
{
  return this->c_;
}

void laneOffset::
c (const c_type& x)
{
  this->c_.set (x);
}

void laneOffset::
c (const c_optional& x)
{
  this->c_ = x;
}

const laneOffset::d_optional& laneOffset::
d () const
{
  return this->d_;
}

laneOffset::d_optional& laneOffset::
d ()
{
  return this->d_;
}

void laneOffset::
d (const d_type& x)
{
  this->d_.set (x);
}

void laneOffset::
d (const d_optional& x)
{
  this->d_ = x;
}


// laneSection
// 

const laneSection::left_optional& laneSection::
left () const
{
  return this->left_;
}

laneSection::left_optional& laneSection::
left ()
{
  return this->left_;
}

void laneSection::
left (const left_type& x)
{
  this->left_.set (x);
}

void laneSection::
left (const left_optional& x)
{
  this->left_ = x;
}

void laneSection::
left (::std::auto_ptr< left_type > x)
{
  this->left_.set (x);
}

const laneSection::center_type& laneSection::
center () const
{
  return this->center_.get ();
}

laneSection::center_type& laneSection::
center ()
{
  return this->center_.get ();
}

void laneSection::
center (const center_type& x)
{
  this->center_.set (x);
}

void laneSection::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const laneSection::right_optional& laneSection::
right () const
{
  return this->right_;
}

laneSection::right_optional& laneSection::
right ()
{
  return this->right_;
}

void laneSection::
right (const right_type& x)
{
  this->right_.set (x);
}

void laneSection::
right (const right_optional& x)
{
  this->right_ = x;
}

void laneSection::
right (::std::auto_ptr< right_type > x)
{
  this->right_.set (x);
}

const laneSection::userData_sequence& laneSection::
userData () const
{
  return this->userData_;
}

laneSection::userData_sequence& laneSection::
userData ()
{
  return this->userData_;
}

void laneSection::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const laneSection::include_sequence& laneSection::
include () const
{
  return this->include_;
}

laneSection::include_sequence& laneSection::
include ()
{
  return this->include_;
}

void laneSection::
include (const include_sequence& s)
{
  this->include_ = s;
}

const laneSection::s_optional& laneSection::
s () const
{
  return this->s_;
}

laneSection::s_optional& laneSection::
s ()
{
  return this->s_;
}

void laneSection::
s (const s_type& x)
{
  this->s_.set (x);
}

void laneSection::
s (const s_optional& x)
{
  this->s_ = x;
}

const laneSection::singleSide_optional& laneSection::
singleSide () const
{
  return this->singleSide_;
}

laneSection::singleSide_optional& laneSection::
singleSide ()
{
  return this->singleSide_;
}

void laneSection::
singleSide (const singleSide_type& x)
{
  this->singleSide_.set (x);
}

void laneSection::
singleSide (const singleSide_optional& x)
{
  this->singleSide_ = x;
}

void laneSection::
singleSide (::std::auto_ptr< singleSide_type > x)
{
  this->singleSide_.set (x);
}


// object
// 

const object::repeat_sequence& object::
repeat () const
{
  return this->repeat_;
}

object::repeat_sequence& object::
repeat ()
{
  return this->repeat_;
}

void object::
repeat (const repeat_sequence& s)
{
  this->repeat_ = s;
}

const object::outline_optional& object::
outline () const
{
  return this->outline_;
}

object::outline_optional& object::
outline ()
{
  return this->outline_;
}

void object::
outline (const outline_type& x)
{
  this->outline_.set (x);
}

void object::
outline (const outline_optional& x)
{
  this->outline_ = x;
}

void object::
outline (::std::auto_ptr< outline_type > x)
{
  this->outline_.set (x);
}

const object::material_optional& object::
material () const
{
  return this->material_;
}

object::material_optional& object::
material ()
{
  return this->material_;
}

void object::
material (const material_type& x)
{
  this->material_.set (x);
}

void object::
material (const material_optional& x)
{
  this->material_ = x;
}

void object::
material (::std::auto_ptr< material_type > x)
{
  this->material_.set (x);
}

const object::validity_sequence& object::
validity () const
{
  return this->validity_;
}

object::validity_sequence& object::
validity ()
{
  return this->validity_;
}

void object::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const object::parkingSpace_optional& object::
parkingSpace () const
{
  return this->parkingSpace_;
}

object::parkingSpace_optional& object::
parkingSpace ()
{
  return this->parkingSpace_;
}

void object::
parkingSpace (const parkingSpace_type& x)
{
  this->parkingSpace_.set (x);
}

void object::
parkingSpace (const parkingSpace_optional& x)
{
  this->parkingSpace_ = x;
}

void object::
parkingSpace (::std::auto_ptr< parkingSpace_type > x)
{
  this->parkingSpace_.set (x);
}

const object::userData_sequence& object::
userData () const
{
  return this->userData_;
}

object::userData_sequence& object::
userData ()
{
  return this->userData_;
}

void object::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const object::include_sequence& object::
include () const
{
  return this->include_;
}

object::include_sequence& object::
include ()
{
  return this->include_;
}

void object::
include (const include_sequence& s)
{
  this->include_ = s;
}

const object::type_optional& object::
type () const
{
  return this->type_;
}

object::type_optional& object::
type ()
{
  return this->type_;
}

void object::
type (const type_type& x)
{
  this->type_.set (x);
}

void object::
type (const type_optional& x)
{
  this->type_ = x;
}

void object::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const object::name_optional& object::
name () const
{
  return this->name_;
}

object::name_optional& object::
name ()
{
  return this->name_;
}

void object::
name (const name_type& x)
{
  this->name_.set (x);
}

void object::
name (const name_optional& x)
{
  this->name_ = x;
}

void object::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const object::id_optional& object::
id () const
{
  return this->id_;
}

object::id_optional& object::
id ()
{
  return this->id_;
}

void object::
id (const id_type& x)
{
  this->id_.set (x);
}

void object::
id (const id_optional& x)
{
  this->id_ = x;
}

void object::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const object::s_optional& object::
s () const
{
  return this->s_;
}

object::s_optional& object::
s ()
{
  return this->s_;
}

void object::
s (const s_type& x)
{
  this->s_.set (x);
}

void object::
s (const s_optional& x)
{
  this->s_ = x;
}

const object::t_optional& object::
t () const
{
  return this->t_;
}

object::t_optional& object::
t ()
{
  return this->t_;
}

void object::
t (const t_type& x)
{
  this->t_.set (x);
}

void object::
t (const t_optional& x)
{
  this->t_ = x;
}

const object::zOffset_optional& object::
zOffset () const
{
  return this->zOffset_;
}

object::zOffset_optional& object::
zOffset ()
{
  return this->zOffset_;
}

void object::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void object::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const object::validLength_optional& object::
validLength () const
{
  return this->validLength_;
}

object::validLength_optional& object::
validLength ()
{
  return this->validLength_;
}

void object::
validLength (const validLength_type& x)
{
  this->validLength_.set (x);
}

void object::
validLength (const validLength_optional& x)
{
  this->validLength_ = x;
}

const object::orientation_optional& object::
orientation () const
{
  return this->orientation_;
}

object::orientation_optional& object::
orientation ()
{
  return this->orientation_;
}

void object::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void object::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void object::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const object::length_optional& object::
length () const
{
  return this->length_;
}

object::length_optional& object::
length ()
{
  return this->length_;
}

void object::
length (const length_type& x)
{
  this->length_.set (x);
}

void object::
length (const length_optional& x)
{
  this->length_ = x;
}

const object::width_optional& object::
width () const
{
  return this->width_;
}

object::width_optional& object::
width ()
{
  return this->width_;
}

void object::
width (const width_type& x)
{
  this->width_.set (x);
}

void object::
width (const width_optional& x)
{
  this->width_ = x;
}

const object::radius_optional& object::
radius () const
{
  return this->radius_;
}

object::radius_optional& object::
radius ()
{
  return this->radius_;
}

void object::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void object::
radius (const radius_optional& x)
{
  this->radius_ = x;
}

const object::height_optional& object::
height () const
{
  return this->height_;
}

object::height_optional& object::
height ()
{
  return this->height_;
}

void object::
height (const height_type& x)
{
  this->height_.set (x);
}

void object::
height (const height_optional& x)
{
  this->height_ = x;
}

const object::hdg_optional& object::
hdg () const
{
  return this->hdg_;
}

object::hdg_optional& object::
hdg ()
{
  return this->hdg_;
}

void object::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}

void object::
hdg (const hdg_optional& x)
{
  this->hdg_ = x;
}

const object::pitch_optional& object::
pitch () const
{
  return this->pitch_;
}

object::pitch_optional& object::
pitch ()
{
  return this->pitch_;
}

void object::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void object::
pitch (const pitch_optional& x)
{
  this->pitch_ = x;
}

const object::roll_optional& object::
roll () const
{
  return this->roll_;
}

object::roll_optional& object::
roll ()
{
  return this->roll_;
}

void object::
roll (const roll_type& x)
{
  this->roll_.set (x);
}

void object::
roll (const roll_optional& x)
{
  this->roll_ = x;
}


// objectReference
// 

const objectReference::validity_sequence& objectReference::
validity () const
{
  return this->validity_;
}

objectReference::validity_sequence& objectReference::
validity ()
{
  return this->validity_;
}

void objectReference::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const objectReference::userData_sequence& objectReference::
userData () const
{
  return this->userData_;
}

objectReference::userData_sequence& objectReference::
userData ()
{
  return this->userData_;
}

void objectReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const objectReference::include_sequence& objectReference::
include () const
{
  return this->include_;
}

objectReference::include_sequence& objectReference::
include ()
{
  return this->include_;
}

void objectReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const objectReference::s_optional& objectReference::
s () const
{
  return this->s_;
}

objectReference::s_optional& objectReference::
s ()
{
  return this->s_;
}

void objectReference::
s (const s_type& x)
{
  this->s_.set (x);
}

void objectReference::
s (const s_optional& x)
{
  this->s_ = x;
}

const objectReference::t_optional& objectReference::
t () const
{
  return this->t_;
}

objectReference::t_optional& objectReference::
t ()
{
  return this->t_;
}

void objectReference::
t (const t_type& x)
{
  this->t_.set (x);
}

void objectReference::
t (const t_optional& x)
{
  this->t_ = x;
}

const objectReference::id_optional& objectReference::
id () const
{
  return this->id_;
}

objectReference::id_optional& objectReference::
id ()
{
  return this->id_;
}

void objectReference::
id (const id_type& x)
{
  this->id_.set (x);
}

void objectReference::
id (const id_optional& x)
{
  this->id_ = x;
}

void objectReference::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const objectReference::zOffset_optional& objectReference::
zOffset () const
{
  return this->zOffset_;
}

objectReference::zOffset_optional& objectReference::
zOffset ()
{
  return this->zOffset_;
}

void objectReference::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void objectReference::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const objectReference::validLength_optional& objectReference::
validLength () const
{
  return this->validLength_;
}

objectReference::validLength_optional& objectReference::
validLength ()
{
  return this->validLength_;
}

void objectReference::
validLength (const validLength_type& x)
{
  this->validLength_.set (x);
}

void objectReference::
validLength (const validLength_optional& x)
{
  this->validLength_ = x;
}

const objectReference::orientation_optional& objectReference::
orientation () const
{
  return this->orientation_;
}

objectReference::orientation_optional& objectReference::
orientation ()
{
  return this->orientation_;
}

void objectReference::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void objectReference::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void objectReference::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}


// tunnel
// 

const tunnel::validity_sequence& tunnel::
validity () const
{
  return this->validity_;
}

tunnel::validity_sequence& tunnel::
validity ()
{
  return this->validity_;
}

void tunnel::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const tunnel::userData_sequence& tunnel::
userData () const
{
  return this->userData_;
}

tunnel::userData_sequence& tunnel::
userData ()
{
  return this->userData_;
}

void tunnel::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const tunnel::include_sequence& tunnel::
include () const
{
  return this->include_;
}

tunnel::include_sequence& tunnel::
include ()
{
  return this->include_;
}

void tunnel::
include (const include_sequence& s)
{
  this->include_ = s;
}

const tunnel::s_optional& tunnel::
s () const
{
  return this->s_;
}

tunnel::s_optional& tunnel::
s ()
{
  return this->s_;
}

void tunnel::
s (const s_type& x)
{
  this->s_.set (x);
}

void tunnel::
s (const s_optional& x)
{
  this->s_ = x;
}

const tunnel::length_optional& tunnel::
length () const
{
  return this->length_;
}

tunnel::length_optional& tunnel::
length ()
{
  return this->length_;
}

void tunnel::
length (const length_type& x)
{
  this->length_.set (x);
}

void tunnel::
length (const length_optional& x)
{
  this->length_ = x;
}

const tunnel::name_optional& tunnel::
name () const
{
  return this->name_;
}

tunnel::name_optional& tunnel::
name ()
{
  return this->name_;
}

void tunnel::
name (const name_type& x)
{
  this->name_.set (x);
}

void tunnel::
name (const name_optional& x)
{
  this->name_ = x;
}

void tunnel::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const tunnel::id_optional& tunnel::
id () const
{
  return this->id_;
}

tunnel::id_optional& tunnel::
id ()
{
  return this->id_;
}

void tunnel::
id (const id_type& x)
{
  this->id_.set (x);
}

void tunnel::
id (const id_optional& x)
{
  this->id_ = x;
}

void tunnel::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const tunnel::type_optional& tunnel::
type () const
{
  return this->type_;
}

tunnel::type_optional& tunnel::
type ()
{
  return this->type_;
}

void tunnel::
type (const type_type& x)
{
  this->type_.set (x);
}

void tunnel::
type (const type_optional& x)
{
  this->type_ = x;
}

void tunnel::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const tunnel::lighting_optional& tunnel::
lighting () const
{
  return this->lighting_;
}

tunnel::lighting_optional& tunnel::
lighting ()
{
  return this->lighting_;
}

void tunnel::
lighting (const lighting_type& x)
{
  this->lighting_.set (x);
}

void tunnel::
lighting (const lighting_optional& x)
{
  this->lighting_ = x;
}

const tunnel::daylight_optional& tunnel::
daylight () const
{
  return this->daylight_;
}

tunnel::daylight_optional& tunnel::
daylight ()
{
  return this->daylight_;
}

void tunnel::
daylight (const daylight_type& x)
{
  this->daylight_.set (x);
}

void tunnel::
daylight (const daylight_optional& x)
{
  this->daylight_ = x;
}


// bridge
// 

const bridge::validity_sequence& bridge::
validity () const
{
  return this->validity_;
}

bridge::validity_sequence& bridge::
validity ()
{
  return this->validity_;
}

void bridge::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const bridge::userData_sequence& bridge::
userData () const
{
  return this->userData_;
}

bridge::userData_sequence& bridge::
userData ()
{
  return this->userData_;
}

void bridge::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const bridge::include_sequence& bridge::
include () const
{
  return this->include_;
}

bridge::include_sequence& bridge::
include ()
{
  return this->include_;
}

void bridge::
include (const include_sequence& s)
{
  this->include_ = s;
}

const bridge::s_optional& bridge::
s () const
{
  return this->s_;
}

bridge::s_optional& bridge::
s ()
{
  return this->s_;
}

void bridge::
s (const s_type& x)
{
  this->s_.set (x);
}

void bridge::
s (const s_optional& x)
{
  this->s_ = x;
}

const bridge::length_optional& bridge::
length () const
{
  return this->length_;
}

bridge::length_optional& bridge::
length ()
{
  return this->length_;
}

void bridge::
length (const length_type& x)
{
  this->length_.set (x);
}

void bridge::
length (const length_optional& x)
{
  this->length_ = x;
}

const bridge::name_optional& bridge::
name () const
{
  return this->name_;
}

bridge::name_optional& bridge::
name ()
{
  return this->name_;
}

void bridge::
name (const name_type& x)
{
  this->name_.set (x);
}

void bridge::
name (const name_optional& x)
{
  this->name_ = x;
}

void bridge::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const bridge::id_optional& bridge::
id () const
{
  return this->id_;
}

bridge::id_optional& bridge::
id ()
{
  return this->id_;
}

void bridge::
id (const id_type& x)
{
  this->id_.set (x);
}

void bridge::
id (const id_optional& x)
{
  this->id_ = x;
}

void bridge::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const bridge::type_optional& bridge::
type () const
{
  return this->type_;
}

bridge::type_optional& bridge::
type ()
{
  return this->type_;
}

void bridge::
type (const type_type& x)
{
  this->type_.set (x);
}

void bridge::
type (const type_optional& x)
{
  this->type_ = x;
}

void bridge::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// signal
// 

const signal::validity_sequence& signal::
validity () const
{
  return this->validity_;
}

signal::validity_sequence& signal::
validity ()
{
  return this->validity_;
}

void signal::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const signal::dependency_sequence& signal::
dependency () const
{
  return this->dependency_;
}

signal::dependency_sequence& signal::
dependency ()
{
  return this->dependency_;
}

void signal::
dependency (const dependency_sequence& s)
{
  this->dependency_ = s;
}

const signal::userData_sequence& signal::
userData () const
{
  return this->userData_;
}

signal::userData_sequence& signal::
userData ()
{
  return this->userData_;
}

void signal::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const signal::include_sequence& signal::
include () const
{
  return this->include_;
}

signal::include_sequence& signal::
include ()
{
  return this->include_;
}

void signal::
include (const include_sequence& s)
{
  this->include_ = s;
}

const signal::s_optional& signal::
s () const
{
  return this->s_;
}

signal::s_optional& signal::
s ()
{
  return this->s_;
}

void signal::
s (const s_type& x)
{
  this->s_.set (x);
}

void signal::
s (const s_optional& x)
{
  this->s_ = x;
}

const signal::t_optional& signal::
t () const
{
  return this->t_;
}

signal::t_optional& signal::
t ()
{
  return this->t_;
}

void signal::
t (const t_type& x)
{
  this->t_.set (x);
}

void signal::
t (const t_optional& x)
{
  this->t_ = x;
}

const signal::id_optional& signal::
id () const
{
  return this->id_;
}

signal::id_optional& signal::
id ()
{
  return this->id_;
}

void signal::
id (const id_type& x)
{
  this->id_.set (x);
}

void signal::
id (const id_optional& x)
{
  this->id_ = x;
}

void signal::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const signal::name_optional& signal::
name () const
{
  return this->name_;
}

signal::name_optional& signal::
name ()
{
  return this->name_;
}

void signal::
name (const name_type& x)
{
  this->name_.set (x);
}

void signal::
name (const name_optional& x)
{
  this->name_ = x;
}

void signal::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const signal::dynamic_optional& signal::
dynamic () const
{
  return this->dynamic_;
}

signal::dynamic_optional& signal::
dynamic ()
{
  return this->dynamic_;
}

void signal::
dynamic (const dynamic_type& x)
{
  this->dynamic_.set (x);
}

void signal::
dynamic (const dynamic_optional& x)
{
  this->dynamic_ = x;
}

void signal::
dynamic (::std::auto_ptr< dynamic_type > x)
{
  this->dynamic_.set (x);
}

const signal::orientation_optional& signal::
orientation () const
{
  return this->orientation_;
}

signal::orientation_optional& signal::
orientation ()
{
  return this->orientation_;
}

void signal::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void signal::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void signal::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const signal::zOffset_optional& signal::
zOffset () const
{
  return this->zOffset_;
}

signal::zOffset_optional& signal::
zOffset ()
{
  return this->zOffset_;
}

void signal::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void signal::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const signal::country_optional& signal::
country () const
{
  return this->country_;
}

signal::country_optional& signal::
country ()
{
  return this->country_;
}

void signal::
country (const country_type& x)
{
  this->country_.set (x);
}

void signal::
country (const country_optional& x)
{
  this->country_ = x;
}

void signal::
country (::std::auto_ptr< country_type > x)
{
  this->country_.set (x);
}

const signal::type_optional& signal::
type () const
{
  return this->type_;
}

signal::type_optional& signal::
type ()
{
  return this->type_;
}

void signal::
type (const type_type& x)
{
  this->type_.set (x);
}

void signal::
type (const type_optional& x)
{
  this->type_ = x;
}

void signal::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const signal::subtype_optional& signal::
subtype () const
{
  return this->subtype_;
}

signal::subtype_optional& signal::
subtype ()
{
  return this->subtype_;
}

void signal::
subtype (const subtype_type& x)
{
  this->subtype_.set (x);
}

void signal::
subtype (const subtype_optional& x)
{
  this->subtype_ = x;
}

void signal::
subtype (::std::auto_ptr< subtype_type > x)
{
  this->subtype_.set (x);
}

const signal::value_optional& signal::
value () const
{
  return this->value_;
}

signal::value_optional& signal::
value ()
{
  return this->value_;
}

void signal::
value (const value_type& x)
{
  this->value_.set (x);
}

void signal::
value (const value_optional& x)
{
  this->value_ = x;
}

const signal::unit_optional& signal::
unit () const
{
  return this->unit_;
}

signal::unit_optional& signal::
unit ()
{
  return this->unit_;
}

void signal::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void signal::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void signal::
unit (::std::auto_ptr< unit_type > x)
{
  this->unit_.set (x);
}

const signal::height_optional& signal::
height () const
{
  return this->height_;
}

signal::height_optional& signal::
height ()
{
  return this->height_;
}

void signal::
height (const height_type& x)
{
  this->height_.set (x);
}

void signal::
height (const height_optional& x)
{
  this->height_ = x;
}

const signal::width_optional& signal::
width () const
{
  return this->width_;
}

signal::width_optional& signal::
width ()
{
  return this->width_;
}

void signal::
width (const width_type& x)
{
  this->width_.set (x);
}

void signal::
width (const width_optional& x)
{
  this->width_ = x;
}

const signal::text_optional& signal::
text () const
{
  return this->text_;
}

signal::text_optional& signal::
text ()
{
  return this->text_;
}

void signal::
text (const text_type& x)
{
  this->text_.set (x);
}

void signal::
text (const text_optional& x)
{
  this->text_ = x;
}

void signal::
text (::std::auto_ptr< text_type > x)
{
  this->text_.set (x);
}

const signal::hOffset_optional& signal::
hOffset () const
{
  return this->hOffset_;
}

signal::hOffset_optional& signal::
hOffset ()
{
  return this->hOffset_;
}

void signal::
hOffset (const hOffset_type& x)
{
  this->hOffset_.set (x);
}

void signal::
hOffset (const hOffset_optional& x)
{
  this->hOffset_ = x;
}

const signal::pitch_optional& signal::
pitch () const
{
  return this->pitch_;
}

signal::pitch_optional& signal::
pitch ()
{
  return this->pitch_;
}

void signal::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void signal::
pitch (const pitch_optional& x)
{
  this->pitch_ = x;
}

const signal::roll_optional& signal::
roll () const
{
  return this->roll_;
}

signal::roll_optional& signal::
roll ()
{
  return this->roll_;
}

void signal::
roll (const roll_type& x)
{
  this->roll_.set (x);
}

void signal::
roll (const roll_optional& x)
{
  this->roll_ = x;
}


// signalReference
// 

const signalReference::validity_sequence& signalReference::
validity () const
{
  return this->validity_;
}

signalReference::validity_sequence& signalReference::
validity ()
{
  return this->validity_;
}

void signalReference::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const signalReference::userData_sequence& signalReference::
userData () const
{
  return this->userData_;
}

signalReference::userData_sequence& signalReference::
userData ()
{
  return this->userData_;
}

void signalReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const signalReference::include_sequence& signalReference::
include () const
{
  return this->include_;
}

signalReference::include_sequence& signalReference::
include ()
{
  return this->include_;
}

void signalReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const signalReference::s_optional& signalReference::
s () const
{
  return this->s_;
}

signalReference::s_optional& signalReference::
s ()
{
  return this->s_;
}

void signalReference::
s (const s_type& x)
{
  this->s_.set (x);
}

void signalReference::
s (const s_optional& x)
{
  this->s_ = x;
}

const signalReference::t_optional& signalReference::
t () const
{
  return this->t_;
}

signalReference::t_optional& signalReference::
t ()
{
  return this->t_;
}

void signalReference::
t (const t_type& x)
{
  this->t_.set (x);
}

void signalReference::
t (const t_optional& x)
{
  this->t_ = x;
}

const signalReference::id_optional& signalReference::
id () const
{
  return this->id_;
}

signalReference::id_optional& signalReference::
id ()
{
  return this->id_;
}

void signalReference::
id (const id_type& x)
{
  this->id_.set (x);
}

void signalReference::
id (const id_optional& x)
{
  this->id_ = x;
}

void signalReference::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const signalReference::orientation_optional& signalReference::
orientation () const
{
  return this->orientation_;
}

signalReference::orientation_optional& signalReference::
orientation ()
{
  return this->orientation_;
}

void signalReference::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void signalReference::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void signalReference::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}


// CRG
// 

const CRG::userData_sequence& CRG::
userData () const
{
  return this->userData_;
}

CRG::userData_sequence& CRG::
userData ()
{
  return this->userData_;
}

void CRG::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const CRG::include_sequence& CRG::
include () const
{
  return this->include_;
}

CRG::include_sequence& CRG::
include ()
{
  return this->include_;
}

void CRG::
include (const include_sequence& s)
{
  this->include_ = s;
}

const CRG::file_optional& CRG::
file () const
{
  return this->file_;
}

CRG::file_optional& CRG::
file ()
{
  return this->file_;
}

void CRG::
file (const file_type& x)
{
  this->file_.set (x);
}

void CRG::
file (const file_optional& x)
{
  this->file_ = x;
}

void CRG::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}

const CRG::sStart_optional& CRG::
sStart () const
{
  return this->sStart_;
}

CRG::sStart_optional& CRG::
sStart ()
{
  return this->sStart_;
}

void CRG::
sStart (const sStart_type& x)
{
  this->sStart_.set (x);
}

void CRG::
sStart (const sStart_optional& x)
{
  this->sStart_ = x;
}

const CRG::sEnd_optional& CRG::
sEnd () const
{
  return this->sEnd_;
}

CRG::sEnd_optional& CRG::
sEnd ()
{
  return this->sEnd_;
}

void CRG::
sEnd (const sEnd_type& x)
{
  this->sEnd_.set (x);
}

void CRG::
sEnd (const sEnd_optional& x)
{
  this->sEnd_ = x;
}

const CRG::orientation_optional& CRG::
orientation () const
{
  return this->orientation_;
}

CRG::orientation_optional& CRG::
orientation ()
{
  return this->orientation_;
}

void CRG::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void CRG::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void CRG::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const CRG::mode_optional& CRG::
mode () const
{
  return this->mode_;
}

CRG::mode_optional& CRG::
mode ()
{
  return this->mode_;
}

void CRG::
mode (const mode_type& x)
{
  this->mode_.set (x);
}

void CRG::
mode (const mode_optional& x)
{
  this->mode_ = x;
}

void CRG::
mode (::std::auto_ptr< mode_type > x)
{
  this->mode_.set (x);
}

const CRG::purpose_optional& CRG::
purpose () const
{
  return this->purpose_;
}

CRG::purpose_optional& CRG::
purpose ()
{
  return this->purpose_;
}

void CRG::
purpose (const purpose_type& x)
{
  this->purpose_.set (x);
}

void CRG::
purpose (const purpose_optional& x)
{
  this->purpose_ = x;
}

void CRG::
purpose (::std::auto_ptr< purpose_type > x)
{
  this->purpose_.set (x);
}

const CRG::sOffset_optional& CRG::
sOffset () const
{
  return this->sOffset_;
}

CRG::sOffset_optional& CRG::
sOffset ()
{
  return this->sOffset_;
}

void CRG::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void CRG::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const CRG::tOffset_optional& CRG::
tOffset () const
{
  return this->tOffset_;
}

CRG::tOffset_optional& CRG::
tOffset ()
{
  return this->tOffset_;
}

void CRG::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

void CRG::
tOffset (const tOffset_optional& x)
{
  this->tOffset_ = x;
}

const CRG::zOffset_optional& CRG::
zOffset () const
{
  return this->zOffset_;
}

CRG::zOffset_optional& CRG::
zOffset ()
{
  return this->zOffset_;
}

void CRG::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void CRG::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const CRG::zScale_optional& CRG::
zScale () const
{
  return this->zScale_;
}

CRG::zScale_optional& CRG::
zScale ()
{
  return this->zScale_;
}

void CRG::
zScale (const zScale_type& x)
{
  this->zScale_.set (x);
}

void CRG::
zScale (const zScale_optional& x)
{
  this->zScale_ = x;
}

const CRG::hOffset_optional& CRG::
hOffset () const
{
  return this->hOffset_;
}

CRG::hOffset_optional& CRG::
hOffset ()
{
  return this->hOffset_;
}

void CRG::
hOffset (const hOffset_type& x)
{
  this->hOffset_.set (x);
}

void CRG::
hOffset (const hOffset_optional& x)
{
  this->hOffset_ = x;
}


// switch_
// 

const switch_::mainTrack_type& switch_::
mainTrack () const
{
  return this->mainTrack_.get ();
}

switch_::mainTrack_type& switch_::
mainTrack ()
{
  return this->mainTrack_.get ();
}

void switch_::
mainTrack (const mainTrack_type& x)
{
  this->mainTrack_.set (x);
}

void switch_::
mainTrack (::std::auto_ptr< mainTrack_type > x)
{
  this->mainTrack_.set (x);
}

const switch_::sideTrack_type& switch_::
sideTrack () const
{
  return this->sideTrack_.get ();
}

switch_::sideTrack_type& switch_::
sideTrack ()
{
  return this->sideTrack_.get ();
}

void switch_::
sideTrack (const sideTrack_type& x)
{
  this->sideTrack_.set (x);
}

void switch_::
sideTrack (::std::auto_ptr< sideTrack_type > x)
{
  this->sideTrack_.set (x);
}

const switch_::partner_optional& switch_::
partner () const
{
  return this->partner_;
}

switch_::partner_optional& switch_::
partner ()
{
  return this->partner_;
}

void switch_::
partner (const partner_type& x)
{
  this->partner_.set (x);
}

void switch_::
partner (const partner_optional& x)
{
  this->partner_ = x;
}

void switch_::
partner (::std::auto_ptr< partner_type > x)
{
  this->partner_.set (x);
}

const switch_::userData_sequence& switch_::
userData () const
{
  return this->userData_;
}

switch_::userData_sequence& switch_::
userData ()
{
  return this->userData_;
}

void switch_::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const switch_::include_sequence& switch_::
include () const
{
  return this->include_;
}

switch_::include_sequence& switch_::
include ()
{
  return this->include_;
}

void switch_::
include (const include_sequence& s)
{
  this->include_ = s;
}

const switch_::name_optional& switch_::
name () const
{
  return this->name_;
}

switch_::name_optional& switch_::
name ()
{
  return this->name_;
}

void switch_::
name (const name_type& x)
{
  this->name_.set (x);
}

void switch_::
name (const name_optional& x)
{
  this->name_ = x;
}

void switch_::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const switch_::id_optional& switch_::
id () const
{
  return this->id_;
}

switch_::id_optional& switch_::
id ()
{
  return this->id_;
}

void switch_::
id (const id_type& x)
{
  this->id_.set (x);
}

void switch_::
id (const id_optional& x)
{
  this->id_ = x;
}

void switch_::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const switch_::position_optional& switch_::
position () const
{
  return this->position_;
}

switch_::position_optional& switch_::
position ()
{
  return this->position_;
}

void switch_::
position (const position_type& x)
{
  this->position_.set (x);
}

void switch_::
position (const position_optional& x)
{
  this->position_ = x;
}

void switch_::
position (::std::auto_ptr< position_type > x)
{
  this->position_.set (x);
}


// laneLink
// 

const laneLink::userData_sequence& laneLink::
userData () const
{
  return this->userData_;
}

laneLink::userData_sequence& laneLink::
userData ()
{
  return this->userData_;
}

void laneLink::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const laneLink::include_sequence& laneLink::
include () const
{
  return this->include_;
}

laneLink::include_sequence& laneLink::
include ()
{
  return this->include_;
}

void laneLink::
include (const include_sequence& s)
{
  this->include_ = s;
}

const laneLink::from_optional& laneLink::
from () const
{
  return this->from_;
}

laneLink::from_optional& laneLink::
from ()
{
  return this->from_;
}

void laneLink::
from (const from_type& x)
{
  this->from_.set (x);
}

void laneLink::
from (const from_optional& x)
{
  this->from_ = x;
}

const laneLink::to_optional& laneLink::
to () const
{
  return this->to_;
}

laneLink::to_optional& laneLink::
to ()
{
  return this->to_;
}

void laneLink::
to (const to_type& x)
{
  this->to_.set (x);
}

void laneLink::
to (const to_optional& x)
{
  this->to_ = x;
}


// segment
// 

const segment::userData_sequence& segment::
userData () const
{
  return this->userData_;
}

segment::userData_sequence& segment::
userData ()
{
  return this->userData_;
}

void segment::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const segment::include_sequence& segment::
include () const
{
  return this->include_;
}

segment::include_sequence& segment::
include ()
{
  return this->include_;
}

void segment::
include (const include_sequence& s)
{
  this->include_ = s;
}

const segment::roadId_optional& segment::
roadId () const
{
  return this->roadId_;
}

segment::roadId_optional& segment::
roadId ()
{
  return this->roadId_;
}

void segment::
roadId (const roadId_type& x)
{
  this->roadId_.set (x);
}

void segment::
roadId (const roadId_optional& x)
{
  this->roadId_ = x;
}

void segment::
roadId (::std::auto_ptr< roadId_type > x)
{
  this->roadId_.set (x);
}

const segment::sStart_optional& segment::
sStart () const
{
  return this->sStart_;
}

segment::sStart_optional& segment::
sStart ()
{
  return this->sStart_;
}

void segment::
sStart (const sStart_type& x)
{
  this->sStart_.set (x);
}

void segment::
sStart (const sStart_optional& x)
{
  this->sStart_ = x;
}

const segment::sEnd_optional& segment::
sEnd () const
{
  return this->sEnd_;
}

segment::sEnd_optional& segment::
sEnd ()
{
  return this->sEnd_;
}

void segment::
sEnd (const sEnd_type& x)
{
  this->sEnd_.set (x);
}

void segment::
sEnd (const sEnd_optional& x)
{
  this->sEnd_ = x;
}

const segment::side_optional& segment::
side () const
{
  return this->side_;
}

segment::side_optional& segment::
side ()
{
  return this->side_;
}

void segment::
side (const side_type& x)
{
  this->side_.set (x);
}

void segment::
side (const side_optional& x)
{
  this->side_ = x;
}

void segment::
side (::std::auto_ptr< side_type > x)
{
  this->side_.set (x);
}


// line1
// 

const line1::userData_sequence& line1::
userData () const
{
  return this->userData_;
}

line1::userData_sequence& line1::
userData ()
{
  return this->userData_;
}

void line1::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const line1::include_sequence& line1::
include () const
{
  return this->include_;
}

line1::include_sequence& line1::
include ()
{
  return this->include_;
}

void line1::
include (const include_sequence& s)
{
  this->include_ = s;
}


// spiral
// 

const spiral::userData_sequence& spiral::
userData () const
{
  return this->userData_;
}

spiral::userData_sequence& spiral::
userData ()
{
  return this->userData_;
}

void spiral::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const spiral::include_sequence& spiral::
include () const
{
  return this->include_;
}

spiral::include_sequence& spiral::
include ()
{
  return this->include_;
}

void spiral::
include (const include_sequence& s)
{
  this->include_ = s;
}

const spiral::curvStart_optional& spiral::
curvStart () const
{
  return this->curvStart_;
}

spiral::curvStart_optional& spiral::
curvStart ()
{
  return this->curvStart_;
}

void spiral::
curvStart (const curvStart_type& x)
{
  this->curvStart_.set (x);
}

void spiral::
curvStart (const curvStart_optional& x)
{
  this->curvStart_ = x;
}

const spiral::curvEnd_optional& spiral::
curvEnd () const
{
  return this->curvEnd_;
}

spiral::curvEnd_optional& spiral::
curvEnd ()
{
  return this->curvEnd_;
}

void spiral::
curvEnd (const curvEnd_type& x)
{
  this->curvEnd_.set (x);
}

void spiral::
curvEnd (const curvEnd_optional& x)
{
  this->curvEnd_ = x;
}


// arc
// 

const arc::userData_sequence& arc::
userData () const
{
  return this->userData_;
}

arc::userData_sequence& arc::
userData ()
{
  return this->userData_;
}

void arc::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const arc::include_sequence& arc::
include () const
{
  return this->include_;
}

arc::include_sequence& arc::
include ()
{
  return this->include_;
}

void arc::
include (const include_sequence& s)
{
  this->include_ = s;
}

const arc::curvature_optional& arc::
curvature () const
{
  return this->curvature_;
}

arc::curvature_optional& arc::
curvature ()
{
  return this->curvature_;
}

void arc::
curvature (const curvature_type& x)
{
  this->curvature_.set (x);
}

void arc::
curvature (const curvature_optional& x)
{
  this->curvature_ = x;
}


// poly3
// 

const poly3::userData_sequence& poly3::
userData () const
{
  return this->userData_;
}

poly3::userData_sequence& poly3::
userData ()
{
  return this->userData_;
}

void poly3::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const poly3::include_sequence& poly3::
include () const
{
  return this->include_;
}

poly3::include_sequence& poly3::
include ()
{
  return this->include_;
}

void poly3::
include (const include_sequence& s)
{
  this->include_ = s;
}

const poly3::a_optional& poly3::
a () const
{
  return this->a_;
}

poly3::a_optional& poly3::
a ()
{
  return this->a_;
}

void poly3::
a (const a_type& x)
{
  this->a_.set (x);
}

void poly3::
a (const a_optional& x)
{
  this->a_ = x;
}

const poly3::b_optional& poly3::
b () const
{
  return this->b_;
}

poly3::b_optional& poly3::
b ()
{
  return this->b_;
}

void poly3::
b (const b_type& x)
{
  this->b_.set (x);
}

void poly3::
b (const b_optional& x)
{
  this->b_ = x;
}

const poly3::c_optional& poly3::
c () const
{
  return this->c_;
}

poly3::c_optional& poly3::
c ()
{
  return this->c_;
}

void poly3::
c (const c_type& x)
{
  this->c_.set (x);
}

void poly3::
c (const c_optional& x)
{
  this->c_ = x;
}

const poly3::d_optional& poly3::
d () const
{
  return this->d_;
}

poly3::d_optional& poly3::
d ()
{
  return this->d_;
}

void poly3::
d (const d_type& x)
{
  this->d_.set (x);
}

void poly3::
d (const d_optional& x)
{
  this->d_ = x;
}


// paramPoly3
// 

const paramPoly3::userData_sequence& paramPoly3::
userData () const
{
  return this->userData_;
}

paramPoly3::userData_sequence& paramPoly3::
userData ()
{
  return this->userData_;
}

void paramPoly3::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const paramPoly3::include_sequence& paramPoly3::
include () const
{
  return this->include_;
}

paramPoly3::include_sequence& paramPoly3::
include ()
{
  return this->include_;
}

void paramPoly3::
include (const include_sequence& s)
{
  this->include_ = s;
}

const paramPoly3::aU_optional& paramPoly3::
aU () const
{
  return this->aU_;
}

paramPoly3::aU_optional& paramPoly3::
aU ()
{
  return this->aU_;
}

void paramPoly3::
aU (const aU_type& x)
{
  this->aU_.set (x);
}

void paramPoly3::
aU (const aU_optional& x)
{
  this->aU_ = x;
}

const paramPoly3::bU_optional& paramPoly3::
bU () const
{
  return this->bU_;
}

paramPoly3::bU_optional& paramPoly3::
bU ()
{
  return this->bU_;
}

void paramPoly3::
bU (const bU_type& x)
{
  this->bU_.set (x);
}

void paramPoly3::
bU (const bU_optional& x)
{
  this->bU_ = x;
}

const paramPoly3::cU_optional& paramPoly3::
cU () const
{
  return this->cU_;
}

paramPoly3::cU_optional& paramPoly3::
cU ()
{
  return this->cU_;
}

void paramPoly3::
cU (const cU_type& x)
{
  this->cU_.set (x);
}

void paramPoly3::
cU (const cU_optional& x)
{
  this->cU_ = x;
}

const paramPoly3::dU_optional& paramPoly3::
dU () const
{
  return this->dU_;
}

paramPoly3::dU_optional& paramPoly3::
dU ()
{
  return this->dU_;
}

void paramPoly3::
dU (const dU_type& x)
{
  this->dU_.set (x);
}

void paramPoly3::
dU (const dU_optional& x)
{
  this->dU_ = x;
}

const paramPoly3::aV_optional& paramPoly3::
aV () const
{
  return this->aV_;
}

paramPoly3::aV_optional& paramPoly3::
aV ()
{
  return this->aV_;
}

void paramPoly3::
aV (const aV_type& x)
{
  this->aV_.set (x);
}

void paramPoly3::
aV (const aV_optional& x)
{
  this->aV_ = x;
}

const paramPoly3::bV_optional& paramPoly3::
bV () const
{
  return this->bV_;
}

paramPoly3::bV_optional& paramPoly3::
bV ()
{
  return this->bV_;
}

void paramPoly3::
bV (const bV_type& x)
{
  this->bV_.set (x);
}

void paramPoly3::
bV (const bV_optional& x)
{
  this->bV_ = x;
}

const paramPoly3::cV_optional& paramPoly3::
cV () const
{
  return this->cV_;
}

paramPoly3::cV_optional& paramPoly3::
cV ()
{
  return this->cV_;
}

void paramPoly3::
cV (const cV_type& x)
{
  this->cV_.set (x);
}

void paramPoly3::
cV (const cV_optional& x)
{
  this->cV_ = x;
}

const paramPoly3::dV_optional& paramPoly3::
dV () const
{
  return this->dV_;
}

paramPoly3::dV_optional& paramPoly3::
dV ()
{
  return this->dV_;
}

void paramPoly3::
dV (const dV_type& x)
{
  this->dV_.set (x);
}

void paramPoly3::
dV (const dV_optional& x)
{
  this->dV_ = x;
}

const paramPoly3::pRange_optional& paramPoly3::
pRange () const
{
  return this->pRange_;
}

paramPoly3::pRange_optional& paramPoly3::
pRange ()
{
  return this->pRange_;
}

void paramPoly3::
pRange (const pRange_type& x)
{
  this->pRange_.set (x);
}

void paramPoly3::
pRange (const pRange_optional& x)
{
  this->pRange_ = x;
}

void paramPoly3::
pRange (::std::auto_ptr< pRange_type > x)
{
  this->pRange_.set (x);
}


// left
// 

const left::lane_sequence& left::
lane () const
{
  return this->lane_;
}

left::lane_sequence& left::
lane ()
{
  return this->lane_;
}

void left::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const left::userData_sequence& left::
userData () const
{
  return this->userData_;
}

left::userData_sequence& left::
userData ()
{
  return this->userData_;
}

void left::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const left::include_sequence& left::
include () const
{
  return this->include_;
}

left::include_sequence& left::
include ()
{
  return this->include_;
}

void left::
include (const include_sequence& s)
{
  this->include_ = s;
}


// center
// 

const center::lane_optional& center::
lane () const
{
  return this->lane_;
}

center::lane_optional& center::
lane ()
{
  return this->lane_;
}

void center::
lane (const lane_type& x)
{
  this->lane_.set (x);
}

void center::
lane (const lane_optional& x)
{
  this->lane_ = x;
}

void center::
lane (::std::auto_ptr< lane_type > x)
{
  this->lane_.set (x);
}

const center::userData_sequence& center::
userData () const
{
  return this->userData_;
}

center::userData_sequence& center::
userData ()
{
  return this->userData_;
}

void center::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const center::include_sequence& center::
include () const
{
  return this->include_;
}

center::include_sequence& center::
include ()
{
  return this->include_;
}

void center::
include (const include_sequence& s)
{
  this->include_ = s;
}


// right
// 

const right::lane_sequence& right::
lane () const
{
  return this->lane_;
}

right::lane_sequence& right::
lane ()
{
  return this->lane_;
}

void right::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const right::userData_sequence& right::
userData () const
{
  return this->userData_;
}

right::userData_sequence& right::
userData ()
{
  return this->userData_;
}

void right::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const right::include_sequence& right::
include () const
{
  return this->include_;
}

right::include_sequence& right::
include ()
{
  return this->include_;
}

void right::
include (const include_sequence& s)
{
  this->include_ = s;
}


// repeat
// 

const repeat::userData_sequence& repeat::
userData () const
{
  return this->userData_;
}

repeat::userData_sequence& repeat::
userData ()
{
  return this->userData_;
}

void repeat::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const repeat::include_sequence& repeat::
include () const
{
  return this->include_;
}

repeat::include_sequence& repeat::
include ()
{
  return this->include_;
}

void repeat::
include (const include_sequence& s)
{
  this->include_ = s;
}

const repeat::s_optional& repeat::
s () const
{
  return this->s_;
}

repeat::s_optional& repeat::
s ()
{
  return this->s_;
}

void repeat::
s (const s_type& x)
{
  this->s_.set (x);
}

void repeat::
s (const s_optional& x)
{
  this->s_ = x;
}

const repeat::length_optional& repeat::
length () const
{
  return this->length_;
}

repeat::length_optional& repeat::
length ()
{
  return this->length_;
}

void repeat::
length (const length_type& x)
{
  this->length_.set (x);
}

void repeat::
length (const length_optional& x)
{
  this->length_ = x;
}

const repeat::distance_optional& repeat::
distance () const
{
  return this->distance_;
}

repeat::distance_optional& repeat::
distance ()
{
  return this->distance_;
}

void repeat::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void repeat::
distance (const distance_optional& x)
{
  this->distance_ = x;
}

const repeat::tStart_optional& repeat::
tStart () const
{
  return this->tStart_;
}

repeat::tStart_optional& repeat::
tStart ()
{
  return this->tStart_;
}

void repeat::
tStart (const tStart_type& x)
{
  this->tStart_.set (x);
}

void repeat::
tStart (const tStart_optional& x)
{
  this->tStart_ = x;
}

const repeat::tEnd_optional& repeat::
tEnd () const
{
  return this->tEnd_;
}

repeat::tEnd_optional& repeat::
tEnd ()
{
  return this->tEnd_;
}

void repeat::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

void repeat::
tEnd (const tEnd_optional& x)
{
  this->tEnd_ = x;
}

const repeat::widthStart_optional& repeat::
widthStart () const
{
  return this->widthStart_;
}

repeat::widthStart_optional& repeat::
widthStart ()
{
  return this->widthStart_;
}

void repeat::
widthStart (const widthStart_type& x)
{
  this->widthStart_.set (x);
}

void repeat::
widthStart (const widthStart_optional& x)
{
  this->widthStart_ = x;
}

const repeat::widthEnd_optional& repeat::
widthEnd () const
{
  return this->widthEnd_;
}

repeat::widthEnd_optional& repeat::
widthEnd ()
{
  return this->widthEnd_;
}

void repeat::
widthEnd (const widthEnd_type& x)
{
  this->widthEnd_.set (x);
}

void repeat::
widthEnd (const widthEnd_optional& x)
{
  this->widthEnd_ = x;
}

const repeat::heightStart_optional& repeat::
heightStart () const
{
  return this->heightStart_;
}

repeat::heightStart_optional& repeat::
heightStart ()
{
  return this->heightStart_;
}

void repeat::
heightStart (const heightStart_type& x)
{
  this->heightStart_.set (x);
}

void repeat::
heightStart (const heightStart_optional& x)
{
  this->heightStart_ = x;
}

const repeat::heightEnd_optional& repeat::
heightEnd () const
{
  return this->heightEnd_;
}

repeat::heightEnd_optional& repeat::
heightEnd ()
{
  return this->heightEnd_;
}

void repeat::
heightEnd (const heightEnd_type& x)
{
  this->heightEnd_.set (x);
}

void repeat::
heightEnd (const heightEnd_optional& x)
{
  this->heightEnd_ = x;
}

const repeat::zOffsetStart_optional& repeat::
zOffsetStart () const
{
  return this->zOffsetStart_;
}

repeat::zOffsetStart_optional& repeat::
zOffsetStart ()
{
  return this->zOffsetStart_;
}

void repeat::
zOffsetStart (const zOffsetStart_type& x)
{
  this->zOffsetStart_.set (x);
}

void repeat::
zOffsetStart (const zOffsetStart_optional& x)
{
  this->zOffsetStart_ = x;
}

const repeat::zOffsetEnd_optional& repeat::
zOffsetEnd () const
{
  return this->zOffsetEnd_;
}

repeat::zOffsetEnd_optional& repeat::
zOffsetEnd ()
{
  return this->zOffsetEnd_;
}

void repeat::
zOffsetEnd (const zOffsetEnd_type& x)
{
  this->zOffsetEnd_.set (x);
}

void repeat::
zOffsetEnd (const zOffsetEnd_optional& x)
{
  this->zOffsetEnd_ = x;
}


// outline
// 

const outline::cornerRoad_sequence& outline::
cornerRoad () const
{
  return this->cornerRoad_;
}

outline::cornerRoad_sequence& outline::
cornerRoad ()
{
  return this->cornerRoad_;
}

void outline::
cornerRoad (const cornerRoad_sequence& s)
{
  this->cornerRoad_ = s;
}

const outline::cornerLocal_sequence& outline::
cornerLocal () const
{
  return this->cornerLocal_;
}

outline::cornerLocal_sequence& outline::
cornerLocal ()
{
  return this->cornerLocal_;
}

void outline::
cornerLocal (const cornerLocal_sequence& s)
{
  this->cornerLocal_ = s;
}

const outline::userData_sequence& outline::
userData () const
{
  return this->userData_;
}

outline::userData_sequence& outline::
userData ()
{
  return this->userData_;
}

void outline::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const outline::include_sequence& outline::
include () const
{
  return this->include_;
}

outline::include_sequence& outline::
include ()
{
  return this->include_;
}

void outline::
include (const include_sequence& s)
{
  this->include_ = s;
}


// material1
// 

const material1::userData_sequence& material1::
userData () const
{
  return this->userData_;
}

material1::userData_sequence& material1::
userData ()
{
  return this->userData_;
}

void material1::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const material1::include_sequence& material1::
include () const
{
  return this->include_;
}

material1::include_sequence& material1::
include ()
{
  return this->include_;
}

void material1::
include (const include_sequence& s)
{
  this->include_ = s;
}

const material1::surface_optional& material1::
surface () const
{
  return this->surface_;
}

material1::surface_optional& material1::
surface ()
{
  return this->surface_;
}

void material1::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void material1::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void material1::
surface (::std::auto_ptr< surface_type > x)
{
  this->surface_.set (x);
}

const material1::friction_optional& material1::
friction () const
{
  return this->friction_;
}

material1::friction_optional& material1::
friction ()
{
  return this->friction_;
}

void material1::
friction (const friction_type& x)
{
  this->friction_.set (x);
}

void material1::
friction (const friction_optional& x)
{
  this->friction_ = x;
}

const material1::roughness_optional& material1::
roughness () const
{
  return this->roughness_;
}

material1::roughness_optional& material1::
roughness ()
{
  return this->roughness_;
}

void material1::
roughness (const roughness_type& x)
{
  this->roughness_.set (x);
}

void material1::
roughness (const roughness_optional& x)
{
  this->roughness_ = x;
}


// dependency
// 

const dependency::userData_sequence& dependency::
userData () const
{
  return this->userData_;
}

dependency::userData_sequence& dependency::
userData ()
{
  return this->userData_;
}

void dependency::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const dependency::include_sequence& dependency::
include () const
{
  return this->include_;
}

dependency::include_sequence& dependency::
include ()
{
  return this->include_;
}

void dependency::
include (const include_sequence& s)
{
  this->include_ = s;
}

const dependency::id_optional& dependency::
id () const
{
  return this->id_;
}

dependency::id_optional& dependency::
id ()
{
  return this->id_;
}

void dependency::
id (const id_type& x)
{
  this->id_.set (x);
}

void dependency::
id (const id_optional& x)
{
  this->id_ = x;
}

void dependency::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const dependency::type_optional& dependency::
type () const
{
  return this->type_;
}

dependency::type_optional& dependency::
type ()
{
  return this->type_;
}

void dependency::
type (const type_type& x)
{
  this->type_.set (x);
}

void dependency::
type (const type_optional& x)
{
  this->type_ = x;
}

void dependency::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// mainTrack
// 

const mainTrack::id_optional& mainTrack::
id () const
{
  return this->id_;
}

mainTrack::id_optional& mainTrack::
id ()
{
  return this->id_;
}

void mainTrack::
id (const id_type& x)
{
  this->id_.set (x);
}

void mainTrack::
id (const id_optional& x)
{
  this->id_ = x;
}

void mainTrack::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const mainTrack::s_optional& mainTrack::
s () const
{
  return this->s_;
}

mainTrack::s_optional& mainTrack::
s ()
{
  return this->s_;
}

void mainTrack::
s (const s_type& x)
{
  this->s_.set (x);
}

void mainTrack::
s (const s_optional& x)
{
  this->s_ = x;
}

const mainTrack::dir_optional& mainTrack::
dir () const
{
  return this->dir_;
}

mainTrack::dir_optional& mainTrack::
dir ()
{
  return this->dir_;
}

void mainTrack::
dir (const dir_type& x)
{
  this->dir_.set (x);
}

void mainTrack::
dir (const dir_optional& x)
{
  this->dir_ = x;
}

void mainTrack::
dir (::std::auto_ptr< dir_type > x)
{
  this->dir_.set (x);
}


// sideTrack
// 

const sideTrack::id_optional& sideTrack::
id () const
{
  return this->id_;
}

sideTrack::id_optional& sideTrack::
id ()
{
  return this->id_;
}

void sideTrack::
id (const id_type& x)
{
  this->id_.set (x);
}

void sideTrack::
id (const id_optional& x)
{
  this->id_ = x;
}

void sideTrack::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const sideTrack::s_optional& sideTrack::
s () const
{
  return this->s_;
}

sideTrack::s_optional& sideTrack::
s ()
{
  return this->s_;
}

void sideTrack::
s (const s_type& x)
{
  this->s_.set (x);
}

void sideTrack::
s (const s_optional& x)
{
  this->s_ = x;
}

const sideTrack::dir_optional& sideTrack::
dir () const
{
  return this->dir_;
}

sideTrack::dir_optional& sideTrack::
dir ()
{
  return this->dir_;
}

void sideTrack::
dir (const dir_type& x)
{
  this->dir_.set (x);
}

void sideTrack::
dir (const dir_optional& x)
{
  this->dir_ = x;
}

void sideTrack::
dir (::std::auto_ptr< dir_type > x)
{
  this->dir_.set (x);
}


// partner
// 

const partner::name_optional& partner::
name () const
{
  return this->name_;
}

partner::name_optional& partner::
name ()
{
  return this->name_;
}

void partner::
name (const name_type& x)
{
  this->name_.set (x);
}

void partner::
name (const name_optional& x)
{
  this->name_ = x;
}

void partner::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const partner::id_optional& partner::
id () const
{
  return this->id_;
}

partner::id_optional& partner::
id ()
{
  return this->id_;
}

void partner::
id (const id_type& x)
{
  this->id_.set (x);
}

void partner::
id (const id_optional& x)
{
  this->id_ = x;
}

void partner::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}


// cornerRoad
// 

const cornerRoad::userData_sequence& cornerRoad::
userData () const
{
  return this->userData_;
}

cornerRoad::userData_sequence& cornerRoad::
userData ()
{
  return this->userData_;
}

void cornerRoad::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const cornerRoad::include_sequence& cornerRoad::
include () const
{
  return this->include_;
}

cornerRoad::include_sequence& cornerRoad::
include ()
{
  return this->include_;
}

void cornerRoad::
include (const include_sequence& s)
{
  this->include_ = s;
}

const cornerRoad::s_optional& cornerRoad::
s () const
{
  return this->s_;
}

cornerRoad::s_optional& cornerRoad::
s ()
{
  return this->s_;
}

void cornerRoad::
s (const s_type& x)
{
  this->s_.set (x);
}

void cornerRoad::
s (const s_optional& x)
{
  this->s_ = x;
}

const cornerRoad::t_optional& cornerRoad::
t () const
{
  return this->t_;
}

cornerRoad::t_optional& cornerRoad::
t ()
{
  return this->t_;
}

void cornerRoad::
t (const t_type& x)
{
  this->t_.set (x);
}

void cornerRoad::
t (const t_optional& x)
{
  this->t_ = x;
}

const cornerRoad::dz_optional& cornerRoad::
dz () const
{
  return this->dz_;
}

cornerRoad::dz_optional& cornerRoad::
dz ()
{
  return this->dz_;
}

void cornerRoad::
dz (const dz_type& x)
{
  this->dz_.set (x);
}

void cornerRoad::
dz (const dz_optional& x)
{
  this->dz_ = x;
}

const cornerRoad::height_optional& cornerRoad::
height () const
{
  return this->height_;
}

cornerRoad::height_optional& cornerRoad::
height ()
{
  return this->height_;
}

void cornerRoad::
height (const height_type& x)
{
  this->height_.set (x);
}

void cornerRoad::
height (const height_optional& x)
{
  this->height_ = x;
}


// cornerLocal
// 

const cornerLocal::userData_sequence& cornerLocal::
userData () const
{
  return this->userData_;
}

cornerLocal::userData_sequence& cornerLocal::
userData ()
{
  return this->userData_;
}

void cornerLocal::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const cornerLocal::include_sequence& cornerLocal::
include () const
{
  return this->include_;
}

cornerLocal::include_sequence& cornerLocal::
include ()
{
  return this->include_;
}

void cornerLocal::
include (const include_sequence& s)
{
  this->include_ = s;
}

const cornerLocal::u_optional& cornerLocal::
u () const
{
  return this->u_;
}

cornerLocal::u_optional& cornerLocal::
u ()
{
  return this->u_;
}

void cornerLocal::
u (const u_type& x)
{
  this->u_.set (x);
}

void cornerLocal::
u (const u_optional& x)
{
  this->u_ = x;
}

const cornerLocal::v_optional& cornerLocal::
v () const
{
  return this->v_;
}

cornerLocal::v_optional& cornerLocal::
v ()
{
  return this->v_;
}

void cornerLocal::
v (const v_type& x)
{
  this->v_.set (x);
}

void cornerLocal::
v (const v_optional& x)
{
  this->v_ = x;
}

const cornerLocal::z_optional& cornerLocal::
z () const
{
  return this->z_;
}

cornerLocal::z_optional& cornerLocal::
z ()
{
  return this->z_;
}

void cornerLocal::
z (const z_type& x)
{
  this->z_.set (x);
}

void cornerLocal::
z (const z_optional& x)
{
  this->z_ = x;
}

const cornerLocal::height_optional& cornerLocal::
height () const
{
  return this->height_;
}

cornerLocal::height_optional& cornerLocal::
height ()
{
  return this->height_;
}

void cornerLocal::
height (const height_type& x)
{
  this->height_.set (x);
}

void cornerLocal::
height (const height_optional& x)
{
  this->height_ = x;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// elementType
//

elementType::
elementType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_elementType_convert ();
}

elementType::
elementType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_elementType_convert ();
}

elementType::
elementType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_elementType_convert ();
}

elementType* elementType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class elementType (*this, f, c);
}

elementType::value elementType::
_xsd_elementType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_elementType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_elementType_indexes_,
                    _xsd_elementType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_elementType_indexes_ + 2 || _xsd_elementType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const elementType::
_xsd_elementType_literals_[2] =
{
  "road",
  "junction"
};

const elementType::value elementType::
_xsd_elementType_indexes_[2] =
{
  ::elementType::junction,
  ::elementType::road
};

// t_max
//

t_max::
t_max (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

t_max::
t_max (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

t_max::
t_max (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

t_max* t_max::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_max (*this, f, c);
}

// contactPoint
//

contactPoint::
contactPoint (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_contactPoint_convert ();
}

contactPoint::
contactPoint (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_contactPoint_convert ();
}

contactPoint::
contactPoint (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_contactPoint_convert ();
}

contactPoint* contactPoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class contactPoint (*this, f, c);
}

contactPoint::value contactPoint::
_xsd_contactPoint_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_contactPoint_literals_);
  const value* i (::std::lower_bound (
                    _xsd_contactPoint_indexes_,
                    _xsd_contactPoint_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_contactPoint_indexes_ + 2 || _xsd_contactPoint_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const contactPoint::
_xsd_contactPoint_literals_[2] =
{
  "start",
  "end"
};

const contactPoint::value contactPoint::
_xsd_contactPoint_indexes_[2] =
{
  ::contactPoint::end,
  ::contactPoint::start
};

// side
//

side::
side (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_side_convert ();
}

side::
side (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_side_convert ();
}

side::
side (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_side_convert ();
}

side* side::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class side (*this, f, c);
}

side::value side::
_xsd_side_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_side_literals_);
  const value* i (::std::lower_bound (
                    _xsd_side_indexes_,
                    _xsd_side_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_side_indexes_ + 2 || _xsd_side_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const side::
_xsd_side_literals_[2] =
{
  "left",
  "right"
};

const side::value side::
_xsd_side_indexes_[2] =
{
  ::side::left,
  ::side::right
};

// direction
//

direction::
direction (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_direction_convert ();
}

direction::
direction (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_direction_convert ();
}

direction::
direction (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_direction_convert ();
}

direction* direction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class direction (*this, f, c);
}

direction::value direction::
_xsd_direction_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_direction_literals_);
  const value* i (::std::lower_bound (
                    _xsd_direction_indexes_,
                    _xsd_direction_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_direction_indexes_ + 2 || _xsd_direction_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const direction::
_xsd_direction_literals_[2] =
{
  "same",
  "opposite"
};

const direction::value direction::
_xsd_direction_indexes_[2] =
{
  ::direction::opposite,
  ::direction::same
};

// roadType
//

roadType::
roadType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_roadType_convert ();
}

roadType::
roadType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_roadType_convert ();
}

roadType::
roadType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_roadType_convert ();
}

roadType* roadType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class roadType (*this, f, c);
}

roadType::value roadType::
_xsd_roadType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_roadType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_roadType_indexes_,
                    _xsd_roadType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_roadType_indexes_ + 7 || _xsd_roadType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const roadType::
_xsd_roadType_literals_[7] =
{
  "unknown",
  "rural",
  "motorway",
  "town",
  "lowSpeed",
  "pedestrian",
  "bicycle"
};

const roadType::value roadType::
_xsd_roadType_indexes_[7] =
{
  ::roadType::bicycle,
  ::roadType::lowSpeed,
  ::roadType::motorway,
  ::roadType::pedestrian,
  ::roadType::rural,
  ::roadType::town,
  ::roadType::unknown
};

// unit
//

unit::
unit (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_unit_convert ();
}

unit::
unit (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_unit_convert ();
}

unit::
unit (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_unit_convert ();
}

unit* unit::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class unit (*this, f, c);
}

unit::value unit::
_xsd_unit_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_unit_literals_);
  const value* i (::std::lower_bound (
                    _xsd_unit_indexes_,
                    _xsd_unit_indexes_ + 10,
                    *this,
                    c));

  if (i == _xsd_unit_indexes_ + 10 || _xsd_unit_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const unit::
_xsd_unit_literals_[10] =
{
  "m",
  "km",
  "ft",
  "mile",
  "m/s",
  "mph",
  "km/h",
  "kg",
  "t",
  "%"
};

const unit::value unit::
_xsd_unit_indexes_[10] =
{
  ::unit::cxx_,
  ::unit::ft,
  ::unit::kg,
  ::unit::km,
  ::unit::km_h,
  ::unit::m,
  ::unit::m_s,
  ::unit::mile,
  ::unit::mph,
  ::unit::t
};

// pRange
//

pRange::
pRange (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_pRange_convert ();
}

pRange::
pRange (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_pRange_convert ();
}

pRange::
pRange (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_pRange_convert ();
}

pRange* pRange::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class pRange (*this, f, c);
}

pRange::value pRange::
_xsd_pRange_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_pRange_literals_);
  const value* i (::std::lower_bound (
                    _xsd_pRange_indexes_,
                    _xsd_pRange_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_pRange_indexes_ + 2 || _xsd_pRange_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const pRange::
_xsd_pRange_literals_[2] =
{
  "arcLength",
  "normalized"
};

const pRange::value pRange::
_xsd_pRange_indexes_[2] =
{
  ::pRange::arcLength,
  ::pRange::normalized
};

// crossfallSide
//

crossfallSide::
crossfallSide (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_crossfallSide_convert ();
}

crossfallSide::
crossfallSide (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_crossfallSide_convert ();
}

crossfallSide::
crossfallSide (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_crossfallSide_convert ();
}

crossfallSide* crossfallSide::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class crossfallSide (*this, f, c);
}

crossfallSide::value crossfallSide::
_xsd_crossfallSide_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_crossfallSide_literals_);
  const value* i (::std::lower_bound (
                    _xsd_crossfallSide_indexes_,
                    _xsd_crossfallSide_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_crossfallSide_indexes_ + 3 || _xsd_crossfallSide_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const crossfallSide::
_xsd_crossfallSide_literals_[3] =
{
  "left",
  "right",
  "both"
};

const crossfallSide::value crossfallSide::
_xsd_crossfallSide_indexes_[3] =
{
  ::crossfallSide::both,
  ::crossfallSide::left,
  ::crossfallSide::right
};

// singleSide
//

singleSide::
singleSide (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_singleSide_convert ();
}

singleSide::
singleSide (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_singleSide_convert ();
}

singleSide::
singleSide (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_singleSide_convert ();
}

singleSide* singleSide::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class singleSide (*this, f, c);
}

singleSide::value singleSide::
_xsd_singleSide_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_singleSide_literals_);
  const value* i (::std::lower_bound (
                    _xsd_singleSide_indexes_,
                    _xsd_singleSide_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_singleSide_indexes_ + 2 || _xsd_singleSide_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const singleSide::
_xsd_singleSide_literals_[2] =
{
  "true",
  "false"
};

const singleSide::value singleSide::
_xsd_singleSide_indexes_[2] =
{
  ::singleSide::false_,
  ::singleSide::true_
};

// laneType
//

laneType::
laneType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_laneType_convert ();
}

laneType::
laneType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_laneType_convert ();
}

laneType::
laneType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_laneType_convert ();
}

laneType* laneType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneType (*this, f, c);
}

laneType::value laneType::
_xsd_laneType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_laneType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_laneType_indexes_,
                    _xsd_laneType_indexes_ + 21,
                    *this,
                    c));

  if (i == _xsd_laneType_indexes_ + 21 || _xsd_laneType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const laneType::
_xsd_laneType_literals_[21] =
{
  "none",
  "driving",
  "stop",
  "shoulder",
  "biking",
  "sidewalk",
  "border",
  "restricted",
  "parking",
  "bidirectional",
  "median",
  "special1",
  "special2",
  "special3",
  "roadWorks",
  "tram",
  "rail",
  "entry",
  "exit",
  "offRamp",
  "onRamp"
};

const laneType::value laneType::
_xsd_laneType_indexes_[21] =
{
  ::laneType::bidirectional,
  ::laneType::biking,
  ::laneType::border,
  ::laneType::driving,
  ::laneType::entry,
  ::laneType::exit,
  ::laneType::median,
  ::laneType::none,
  ::laneType::offRamp,
  ::laneType::onRamp,
  ::laneType::parking,
  ::laneType::rail,
  ::laneType::restricted,
  ::laneType::roadWorks,
  ::laneType::shoulder,
  ::laneType::sidewalk,
  ::laneType::special1,
  ::laneType::special2,
  ::laneType::special3,
  ::laneType::stop,
  ::laneType::tram
};

// roadmarkType
//

roadmarkType::
roadmarkType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_roadmarkType_convert ();
}

roadmarkType::
roadmarkType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_roadmarkType_convert ();
}

roadmarkType::
roadmarkType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_roadmarkType_convert ();
}

roadmarkType* roadmarkType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class roadmarkType (*this, f, c);
}

roadmarkType::value roadmarkType::
_xsd_roadmarkType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_roadmarkType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_roadmarkType_indexes_,
                    _xsd_roadmarkType_indexes_ + 10,
                    *this,
                    c));

  if (i == _xsd_roadmarkType_indexes_ + 10 || _xsd_roadmarkType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const roadmarkType::
_xsd_roadmarkType_literals_[10] =
{
  "none",
  "solid",
  "broken",
  "solid solid",
  "solid broken",
  "broken solid",
  "broken broken",
  "botts dots",
  "grass",
  "curb"
};

const roadmarkType::value roadmarkType::
_xsd_roadmarkType_indexes_[10] =
{
  ::roadmarkType::botts_dots,
  ::roadmarkType::broken,
  ::roadmarkType::broken_broken,
  ::roadmarkType::broken_solid,
  ::roadmarkType::curb,
  ::roadmarkType::grass,
  ::roadmarkType::none,
  ::roadmarkType::solid,
  ::roadmarkType::solid_broken,
  ::roadmarkType::solid_solid
};

// weight
//

weight::
weight (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_weight_convert ();
}

weight::
weight (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_weight_convert ();
}

weight::
weight (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_weight_convert ();
}

weight* weight::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class weight (*this, f, c);
}

weight::value weight::
_xsd_weight_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_weight_literals_);
  const value* i (::std::lower_bound (
                    _xsd_weight_indexes_,
                    _xsd_weight_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_weight_indexes_ + 2 || _xsd_weight_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const weight::
_xsd_weight_literals_[2] =
{
  "standard",
  "bold"
};

const weight::value weight::
_xsd_weight_indexes_[2] =
{
  ::weight::bold,
  ::weight::standard
};

// color
//

color::
color (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_color_convert ();
}

color::
color (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_color_convert ();
}

color::
color (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_color_convert ();
}

color* color::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class color (*this, f, c);
}

color::value color::
_xsd_color_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_color_literals_);
  const value* i (::std::lower_bound (
                    _xsd_color_indexes_,
                    _xsd_color_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_color_indexes_ + 6 || _xsd_color_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const color::
_xsd_color_literals_[6] =
{
  "standard",
  "blue",
  "green",
  "red",
  "white",
  "yellow"
};

const color::value color::
_xsd_color_indexes_[6] =
{
  ::color::blue,
  ::color::green,
  ::color::red,
  ::color::standard,
  ::color::white,
  ::color::yellow
};

// restriction
//

restriction::
restriction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_restriction_convert ();
}

restriction::
restriction (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_restriction_convert ();
}

restriction::
restriction (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_restriction_convert ();
}

restriction* restriction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class restriction (*this, f, c);
}

restriction::value restriction::
_xsd_restriction_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_restriction_literals_);
  const value* i (::std::lower_bound (
                    _xsd_restriction_indexes_,
                    _xsd_restriction_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_restriction_indexes_ + 4 || _xsd_restriction_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const restriction::
_xsd_restriction_literals_[4] =
{
  "simulator",
  "autonomous traffic",
  "pedestrian",
  "none"
};

const restriction::value restriction::
_xsd_restriction_indexes_[4] =
{
  ::restriction::autonomous_traffic,
  ::restriction::none,
  ::restriction::pedestrian,
  ::restriction::simulator
};

// laneChange
//

laneChange::
laneChange (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_laneChange_convert ();
}

laneChange::
laneChange (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_laneChange_convert ();
}

laneChange::
laneChange (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_laneChange_convert ();
}

laneChange* laneChange::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneChange (*this, f, c);
}

laneChange::value laneChange::
_xsd_laneChange_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_laneChange_literals_);
  const value* i (::std::lower_bound (
                    _xsd_laneChange_indexes_,
                    _xsd_laneChange_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_laneChange_indexes_ + 4 || _xsd_laneChange_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const laneChange::
_xsd_laneChange_literals_[4] =
{
  "increase",
  "decrease",
  "both",
  "none"
};

const laneChange::value laneChange::
_xsd_laneChange_indexes_[4] =
{
  ::laneChange::both,
  ::laneChange::decrease,
  ::laneChange::increase,
  ::laneChange::none
};

// rule
//

rule::
rule (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_rule_convert ();
}

rule::
rule (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_rule_convert ();
}

rule::
rule (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_rule_convert ();
}

rule* rule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class rule (*this, f, c);
}

rule::value rule::
_xsd_rule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_rule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_rule_indexes_,
                    _xsd_rule_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_rule_indexes_ + 3 || _xsd_rule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const rule::
_xsd_rule_literals_[3] =
{
  "no passing",
  "caution",
  "none"
};

const rule::value rule::
_xsd_rule_indexes_[3] =
{
  ::rule::caution,
  ::rule::no_passing,
  ::rule::none
};

// orientation
//

orientation::
orientation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_orientation_convert ();
}

orientation::
orientation (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_orientation_convert ();
}

orientation::
orientation (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_orientation_convert ();
}

orientation* orientation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class orientation (*this, f, c);
}

orientation::value orientation::
_xsd_orientation_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_orientation_literals_);
  const value* i (::std::lower_bound (
                    _xsd_orientation_indexes_,
                    _xsd_orientation_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_orientation_indexes_ + 3 || _xsd_orientation_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const orientation::
_xsd_orientation_literals_[3] =
{
  "+",
  "-",
  "none"
};

const orientation::value orientation::
_xsd_orientation_indexes_[3] =
{
  ::orientation::cxx_,
  ::orientation::cxx_1,
  ::orientation::none
};

// tunnelType
//

tunnelType::
tunnelType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_tunnelType_convert ();
}

tunnelType::
tunnelType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_tunnelType_convert ();
}

tunnelType::
tunnelType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_tunnelType_convert ();
}

tunnelType* tunnelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tunnelType (*this, f, c);
}

tunnelType::value tunnelType::
_xsd_tunnelType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tunnelType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_tunnelType_indexes_,
                    _xsd_tunnelType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_tunnelType_indexes_ + 2 || _xsd_tunnelType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const tunnelType::
_xsd_tunnelType_literals_[2] =
{
  "standard",
  "underpass"
};

const tunnelType::value tunnelType::
_xsd_tunnelType_indexes_[2] =
{
  ::tunnelType::standard,
  ::tunnelType::underpass
};

// bridgeType
//

bridgeType::
bridgeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_bridgeType_convert ();
}

bridgeType::
bridgeType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_bridgeType_convert ();
}

bridgeType::
bridgeType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_bridgeType_convert ();
}

bridgeType* bridgeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class bridgeType (*this, f, c);
}

bridgeType::value bridgeType::
_xsd_bridgeType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bridgeType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_bridgeType_indexes_,
                    _xsd_bridgeType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_bridgeType_indexes_ + 4 || _xsd_bridgeType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const bridgeType::
_xsd_bridgeType_literals_[4] =
{
  "concrete",
  "steel",
  "brick",
  "wood"
};

const bridgeType::value bridgeType::
_xsd_bridgeType_indexes_[4] =
{
  ::bridgeType::brick,
  ::bridgeType::concrete,
  ::bridgeType::steel,
  ::bridgeType::wood
};

// parkingSpace_access
//

parkingSpace_access::
parkingSpace_access (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_parkingSpace_access_convert ();
}

parkingSpace_access::
parkingSpace_access (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_parkingSpace_access_convert ();
}

parkingSpace_access::
parkingSpace_access (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_parkingSpace_access_convert ();
}

parkingSpace_access* parkingSpace_access::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parkingSpace_access (*this, f, c);
}

parkingSpace_access::value parkingSpace_access::
_xsd_parkingSpace_access_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_parkingSpace_access_literals_);
  const value* i (::std::lower_bound (
                    _xsd_parkingSpace_access_indexes_,
                    _xsd_parkingSpace_access_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_parkingSpace_access_indexes_ + 8 || _xsd_parkingSpace_access_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const parkingSpace_access::
_xsd_parkingSpace_access_literals_[8] =
{
  "all",
  "car",
  "women",
  "handicapped",
  "bus",
  "truck",
  "electric",
  "residents"
};

const parkingSpace_access::value parkingSpace_access::
_xsd_parkingSpace_access_indexes_[8] =
{
  ::parkingSpace_access::all,
  ::parkingSpace_access::bus,
  ::parkingSpace_access::car,
  ::parkingSpace_access::electric,
  ::parkingSpace_access::handicapped,
  ::parkingSpace_access::residents,
  ::parkingSpace_access::truck,
  ::parkingSpace_access::women
};

// parkingSpacemarkingSide
//

parkingSpacemarkingSide::
parkingSpacemarkingSide (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_parkingSpacemarkingSide_convert ();
}

parkingSpacemarkingSide::
parkingSpacemarkingSide (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_parkingSpacemarkingSide_convert ();
}

parkingSpacemarkingSide::
parkingSpacemarkingSide (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_parkingSpacemarkingSide_convert ();
}

parkingSpacemarkingSide* parkingSpacemarkingSide::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parkingSpacemarkingSide (*this, f, c);
}

parkingSpacemarkingSide::value parkingSpacemarkingSide::
_xsd_parkingSpacemarkingSide_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_parkingSpacemarkingSide_literals_);
  const value* i (::std::lower_bound (
                    _xsd_parkingSpacemarkingSide_indexes_,
                    _xsd_parkingSpacemarkingSide_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_parkingSpacemarkingSide_indexes_ + 4 || _xsd_parkingSpacemarkingSide_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const parkingSpacemarkingSide::
_xsd_parkingSpacemarkingSide_literals_[4] =
{
  "front",
  "rear",
  "left",
  "right"
};

const parkingSpacemarkingSide::value parkingSpacemarkingSide::
_xsd_parkingSpacemarkingSide_indexes_[4] =
{
  ::parkingSpacemarkingSide::front,
  ::parkingSpacemarkingSide::left,
  ::parkingSpacemarkingSide::rear,
  ::parkingSpacemarkingSide::right
};

// dynamic
//

dynamic::
dynamic (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_dynamic_convert ();
}

dynamic::
dynamic (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_dynamic_convert ();
}

dynamic::
dynamic (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_dynamic_convert ();
}

dynamic* dynamic::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dynamic (*this, f, c);
}

dynamic::value dynamic::
_xsd_dynamic_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dynamic_literals_);
  const value* i (::std::lower_bound (
                    _xsd_dynamic_indexes_,
                    _xsd_dynamic_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_dynamic_indexes_ + 2 || _xsd_dynamic_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const dynamic::
_xsd_dynamic_literals_[2] =
{
  "yes",
  "no"
};

const dynamic::value dynamic::
_xsd_dynamic_indexes_[2] =
{
  ::dynamic::no,
  ::dynamic::yes
};

// surfaceOrientation
//

surfaceOrientation::
surfaceOrientation (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_surfaceOrientation_convert ();
}

surfaceOrientation::
surfaceOrientation (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_surfaceOrientation_convert ();
}

surfaceOrientation::
surfaceOrientation (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_surfaceOrientation_convert ();
}

surfaceOrientation* surfaceOrientation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class surfaceOrientation (*this, f, c);
}

surfaceOrientation::value surfaceOrientation::
_xsd_surfaceOrientation_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_surfaceOrientation_literals_);
  const value* i (::std::lower_bound (
                    _xsd_surfaceOrientation_indexes_,
                    _xsd_surfaceOrientation_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_surfaceOrientation_indexes_ + 2 || _xsd_surfaceOrientation_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const surfaceOrientation::
_xsd_surfaceOrientation_literals_[2] =
{
  "same",
  "opposite"
};

const surfaceOrientation::value surfaceOrientation::
_xsd_surfaceOrientation_indexes_[2] =
{
  ::surfaceOrientation::opposite,
  ::surfaceOrientation::same
};

// mode
//

mode::
mode (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_mode_convert ();
}

mode::
mode (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_mode_convert ();
}

mode::
mode (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_mode_convert ();
}

mode* mode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mode (*this, f, c);
}

mode::value mode::
_xsd_mode_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_mode_literals_);
  const value* i (::std::lower_bound (
                    _xsd_mode_indexes_,
                    _xsd_mode_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_mode_indexes_ + 3 || _xsd_mode_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const mode::
_xsd_mode_literals_[3] =
{
  "attached",
  "attached0",
  "genuine"
};

const mode::value mode::
_xsd_mode_indexes_[3] =
{
  ::mode::attached,
  ::mode::attached0,
  ::mode::genuine
};

// purpose
//

purpose::
purpose (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_purpose_convert ();
}

purpose::
purpose (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_purpose_convert ();
}

purpose::
purpose (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_purpose_convert ();
}

purpose* purpose::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class purpose (*this, f, c);
}

purpose::value purpose::
_xsd_purpose_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_purpose_literals_);
  const value* i (::std::lower_bound (
                    _xsd_purpose_indexes_,
                    _xsd_purpose_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_purpose_indexes_ + 2 || _xsd_purpose_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const purpose::
_xsd_purpose_literals_[2] =
{
  "elevation",
  "friction"
};

const purpose::value purpose::
_xsd_purpose_indexes_[2] =
{
  ::purpose::elevation,
  ::purpose::friction
};

// position
//

position::
position (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_position_convert ();
}

position::
position (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_position_convert ();
}

position::
position (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_position_convert ();
}

position* position::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class position (*this, f, c);
}

position::value position::
_xsd_position_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_position_literals_);
  const value* i (::std::lower_bound (
                    _xsd_position_indexes_,
                    _xsd_position_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_position_indexes_ + 3 || _xsd_position_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const position::
_xsd_position_literals_[3] =
{
  "dynamic",
  "straight",
  "turn"
};

const position::value position::
_xsd_position_indexes_[3] =
{
  ::position::dynamic,
  ::position::straight,
  ::position::turn
};

// dir
//

dir::
dir (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_dir_convert ();
}

dir::
dir (const ::xercesc::DOMAttr& a,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_dir_convert ();
}

dir::
dir (const ::std::string& s,
     const ::xercesc::DOMElement* e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_dir_convert ();
}

dir* dir::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dir (*this, f, c);
}

dir::value dir::
_xsd_dir_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dir_literals_);
  const value* i (::std::lower_bound (
                    _xsd_dir_indexes_,
                    _xsd_dir_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_dir_indexes_ + 2 || _xsd_dir_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const dir::
_xsd_dir_literals_[2] =
{
  "+",
  "-"
};

const dir::value dir::
_xsd_dir_indexes_[2] =
{
  ::dir::cxx_,
  ::dir::cxx_1
};

// junctionGroupType
//

junctionGroupType::
junctionGroupType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_junctionGroupType_convert ();
}

junctionGroupType::
junctionGroupType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_junctionGroupType_convert ();
}

junctionGroupType::
junctionGroupType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_junctionGroupType_convert ();
}

junctionGroupType* junctionGroupType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class junctionGroupType (*this, f, c);
}

junctionGroupType::value junctionGroupType::
_xsd_junctionGroupType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_junctionGroupType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_junctionGroupType_indexes_,
                    _xsd_junctionGroupType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_junctionGroupType_indexes_ + 2 || _xsd_junctionGroupType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const junctionGroupType::
_xsd_junctionGroupType_literals_[2] =
{
  "roundabout",
  "unknown"
};

const junctionGroupType::value junctionGroupType::
_xsd_junctionGroupType_indexes_[2] =
{
  ::junctionGroupType::roundabout,
  ::junctionGroupType::unknown
};

// stationType
//

stationType::
stationType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_stationType_convert ();
}

stationType::
stationType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_stationType_convert ();
}

stationType::
stationType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_stationType_convert ();
}

stationType* stationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class stationType (*this, f, c);
}

stationType::value stationType::
_xsd_stationType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_stationType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_stationType_indexes_,
                    _xsd_stationType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_stationType_indexes_ + 3 || _xsd_stationType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const stationType::
_xsd_stationType_literals_[3] =
{
  "small",
  "medium",
  "large"
};

const stationType::value stationType::
_xsd_stationType_indexes_[3] =
{
  ::stationType::large,
  ::stationType::medium,
  ::stationType::small
};

// userData
//

userData::
userData ()
: ::xml_schema::type (),
  code_ (this),
  value_ (this)
{
}

userData::
userData (const userData& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  code_ (x.code_, f, this),
  value_ (x.value_, f, this)
{
}

userData::
userData (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  code_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void userData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "code" && n.namespace_ ().empty ())
    {
      this->code_.set (code_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }
}

userData* userData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class userData (*this, f, c);
}

userData& userData::
operator= (const userData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->code_ = x.code_;
    this->value_ = x.value_;
  }

  return *this;
}

userData::
~userData ()
{
}

// include
//

include::
include ()
: ::xml_schema::type (),
  file_ (this)
{
}

include::
include (const include& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  file_ (x.file_, f, this)
{
}

include::
include (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  file_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void include::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      this->file_.set (file_traits::create (i, f, this));
      continue;
    }
  }
}

include* include::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class include (*this, f, c);
}

include& include::
operator= (const include& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->file_ = x.file_;
  }

  return *this;
}

include::
~include ()
{
}

// laneValidity
//

laneValidity::
laneValidity ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  fromLane_ (this),
  toLane_ (this)
{
}

laneValidity::
laneValidity (const laneValidity& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  fromLane_ (x.fromLane_, f, this),
  toLane_ (x.toLane_, f, this)
{
}

laneValidity::
laneValidity (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  fromLane_ (this),
  toLane_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void laneValidity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "fromLane" && n.namespace_ ().empty ())
    {
      this->fromLane_.set (fromLane_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "toLane" && n.namespace_ ().empty ())
    {
      this->toLane_.set (toLane_traits::create (i, f, this));
      continue;
    }
  }
}

laneValidity* laneValidity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneValidity (*this, f, c);
}

laneValidity& laneValidity::
operator= (const laneValidity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->fromLane_ = x.fromLane_;
    this->toLane_ = x.toLane_;
  }

  return *this;
}

laneValidity::
~laneValidity ()
{
}

// parkingSpace
//

parkingSpace::
parkingSpace ()
: ::xml_schema::type (),
  marking_ (this),
  userData_ (this),
  include_ (this),
  parkingSpace_access_ (this),
  restrictions_ (this)
{
}

parkingSpace::
parkingSpace (const parkingSpace& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  marking_ (x.marking_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  parkingSpace_access_ (x.parkingSpace_access_, f, this),
  restrictions_ (x.restrictions_, f, this)
{
}

parkingSpace::
parkingSpace (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  marking_ (this),
  userData_ (this),
  include_ (this),
  parkingSpace_access_ (this),
  restrictions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void parkingSpace::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // marking
    //
    if (n.name () == "marking" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< marking_type > r (
        marking_traits::create (i, f, this));

      this->marking_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "access" && n.namespace_ ().empty ())
    {
      this->parkingSpace_access_.set (access_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "restrictions" && n.namespace_ ().empty ())
    {
      this->restrictions_.set (restrictions_traits::create (i, f, this));
      continue;
    }
  }
}

parkingSpace* parkingSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parkingSpace (*this, f, c);
}

parkingSpace& parkingSpace::
operator= (const parkingSpace& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->marking_ = x.marking_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->parkingSpace_access_ = x.parkingSpace_access_;
    this->restrictions_ = x.restrictions_;
  }

  return *this;
}

parkingSpace::
~parkingSpace ()
{
}

// lane
//

lane::
lane ()
: ::xml_schema::type (),
  lane_link_ (this),
  width_ (this),
  border_ (this),
  roadMark_ (this),
  material_ (this),
  visibility_ (this),
  speed_ (this),
  parkingSpace_access_ (this),
  height_ (this),
  rule_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this),
  level_ (this)
{
}

lane::
lane (const lane& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_link_ (x.lane_link_, f, this),
  width_ (x.width_, f, this),
  border_ (x.border_, f, this),
  roadMark_ (x.roadMark_, f, this),
  material_ (x.material_, f, this),
  visibility_ (x.visibility_, f, this),
  speed_ (x.speed_, f, this),
  parkingSpace_access_ (x.parkingSpace_access_, f, this),
  height_ (x.height_, f, this),
  rule_ (x.rule_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  level_ (x.level_, f, this)
{
}

lane::
lane (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_link_ (this),
  width_ (this),
  border_ (this),
  roadMark_ (this),
  material_ (this),
  visibility_ (this),
  speed_ (this),
  parkingSpace_access_ (this),
  height_ (this),
  rule_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this),
  level_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->lane_link_)
      {
        this->lane_link_.set (r);
        continue;
      }
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< width_type > r (
        width_traits::create (i, f, this));

      this->width_.push_back (r);
      continue;
    }

    // border
    //
    if (n.name () == "border" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< border_type > r (
        border_traits::create (i, f, this));

      this->border_.push_back (r);
      continue;
    }

    // roadMark
    //
    if (n.name () == "roadMark" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< roadMark_type > r (
        roadMark_traits::create (i, f, this));

      this->roadMark_.push_back (r);
      continue;
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      this->material_.push_back (r);
      continue;
    }

    // visibility
    //
    if (n.name () == "visibility" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visibility_type > r (
        visibility_traits::create (i, f, this));

      this->visibility_.push_back (r);
      continue;
    }

    // speed
    //
    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      this->speed_.push_back (r);
      continue;
    }

    // access
    //
    if (n.name () == "access" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< access_type > r (
        access_traits::create (i, f, this));

      this->parkingSpace_access_.push_back (r);
      continue;
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< height_type > r (
        height_traits::create (i, f, this));

      this->height_.push_back (r);
      continue;
    }

    // rule
    //
    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rule_type > r (
        rule_traits::create (i, f, this));

      this->rule_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "level" && n.namespace_ ().empty ())
    {
      this->level_.set (level_traits::create (i, f, this));
      continue;
    }
  }
}

lane* lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lane (*this, f, c);
}

lane& lane::
operator= (const lane& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_link_ = x.lane_link_;
    this->width_ = x.width_;
    this->border_ = x.border_;
    this->roadMark_ = x.roadMark_;
    this->material_ = x.material_;
    this->visibility_ = x.visibility_;
    this->speed_ = x.speed_;
    this->parkingSpace_access_ = x.parkingSpace_access_;
    this->height_ = x.height_;
    this->rule_ = x.rule_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->level_ = x.level_;
  }

  return *this;
}

lane::
~lane ()
{
}

// centerLane
//

centerLane::
centerLane ()
: ::xml_schema::type (),
  lane_link_ (this),
  roadMark_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this),
  level_ (this)
{
}

centerLane::
centerLane (const centerLane& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_link_ (x.lane_link_, f, this),
  roadMark_ (x.roadMark_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  level_ (x.level_, f, this)
{
}

centerLane::
centerLane (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_link_ (this),
  roadMark_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this),
  level_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void centerLane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->lane_link_)
      {
        this->lane_link_.set (r);
        continue;
      }
    }

    // roadMark
    //
    if (n.name () == "roadMark" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< roadMark_type > r (
        roadMark_traits::create (i, f, this));

      this->roadMark_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "level" && n.namespace_ ().empty ())
    {
      this->level_.set (level_traits::create (i, f, this));
      continue;
    }
  }
}

centerLane* centerLane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class centerLane (*this, f, c);
}

centerLane& centerLane::
operator= (const centerLane& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_link_ = x.lane_link_;
    this->roadMark_ = x.roadMark_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->level_ = x.level_;
  }

  return *this;
}

centerLane::
~centerLane ()
{
}

// OpenDRIVE
//

OpenDRIVE::
OpenDRIVE (const header_type& header)
: ::xml_schema::type (),
  header_ (header, this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this)
{
}

OpenDRIVE::
OpenDRIVE (::std::auto_ptr< header_type > header)
: ::xml_schema::type (),
  header_ (header, this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this)
{
}

OpenDRIVE::
OpenDRIVE (const OpenDRIVE& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  road_ (x.road_, f, this),
  controller_ (x.controller_, f, this),
  junction_ (x.junction_, f, this),
  junctionGroup_ (x.junctionGroup_, f, this),
  station_ (x.station_, f, this)
{
}

OpenDRIVE::
OpenDRIVE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OpenDRIVE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (r);
        continue;
      }
    }

    // road
    //
    if (n.name () == "road" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< road_type > r (
        road_traits::create (i, f, this));

      this->road_.push_back (r);
      continue;
    }

    // controller
    //
    if (n.name () == "controller" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< controller_type > r (
        controller_traits::create (i, f, this));

      this->controller_.push_back (r);
      continue;
    }

    // junction
    //
    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< junction_type > r (
        junction_traits::create (i, f, this));

      this->junction_.push_back (r);
      continue;
    }

    // junctionGroup
    //
    if (n.name () == "junctionGroup" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< junctionGroup_type > r (
        junctionGroup_traits::create (i, f, this));

      this->junctionGroup_.push_back (r);
      continue;
    }

    // station
    //
    if (n.name () == "station" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< station_type > r (
        station_traits::create (i, f, this));

      this->station_.push_back (r);
      continue;
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }
}

OpenDRIVE* OpenDRIVE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OpenDRIVE (*this, f, c);
}

OpenDRIVE& OpenDRIVE::
operator= (const OpenDRIVE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->road_ = x.road_;
    this->controller_ = x.controller_;
    this->junction_ = x.junction_;
    this->junctionGroup_ = x.junctionGroup_;
    this->station_ = x.station_;
  }

  return *this;
}

OpenDRIVE::
~OpenDRIVE ()
{
}

// max_member
//

max_member::
max_member (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_max_member_convert ();
}

max_member::
max_member (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_max_member_convert ();
}

max_member::
max_member (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_max_member_convert ();
}

max_member* max_member::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class max_member (*this, f, c);
}

max_member::value max_member::
_xsd_max_member_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_max_member_literals_);
  const value* i (::std::lower_bound (
                    _xsd_max_member_indexes_,
                    _xsd_max_member_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_max_member_indexes_ + 2 || _xsd_max_member_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const max_member::
_xsd_max_member_literals_[2] =
{
  "no limit",
  "undefined"
};

const max_member::value max_member::
_xsd_max_member_indexes_[2] =
{
  ::max_member::no_limit,
  ::max_member::undefined
};

// max_member1
//

max_member1::
max_member1 (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

max_member1::
max_member1 (const max_member1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

max_member1::
max_member1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

max_member1::
max_member1 (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

max_member1::
max_member1 (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

max_member1* max_member1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class max_member1 (*this, f, c);
}

max_member1::
~max_member1 ()
{
}

// marking
//

marking::
marking ()
: ::xml_schema::type (),
  side_ (this),
  type_ (this),
  width_ (this),
  color_ (this)
{
}

marking::
marking (const marking& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  side_ (x.side_, f, this),
  type_ (x.type_, f, this),
  width_ (x.width_, f, this),
  color_ (x.color_, f, this)
{
}

marking::
marking (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  side_ (this),
  type_ (this),
  width_ (this),
  color_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void marking::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }
  }
}

marking* marking::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class marking (*this, f, c);
}

marking& marking::
operator= (const marking& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->side_ = x.side_;
    this->type_ = x.type_;
    this->width_ = x.width_;
    this->color_ = x.color_;
  }

  return *this;
}

marking::
~marking ()
{
}

// lane_link
//

lane_link::
lane_link ()
: ::xml_schema::type (),
  predecessor_ (this),
  successor_ (this),
  userData_ (this),
  include_ (this)
{
}

lane_link::
lane_link (const lane_link& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

lane_link::
lane_link (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lane_link::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      if (!this->predecessor_)
      {
        this->predecessor_.set (r);
        continue;
      }
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      if (!this->successor_)
      {
        this->successor_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

lane_link* lane_link::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lane_link (*this, f, c);
}

lane_link& lane_link::
operator= (const lane_link& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

lane_link::
~lane_link ()
{
}

// width
//

width::
width ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

width::
width (const width& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

width::
width (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void width::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

width* width::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class width (*this, f, c);
}

width& width::
operator= (const width& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

width::
~width ()
{
}

// border
//

border::
border ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

border::
border (const border& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

border::
border (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void border::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

border* border::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class border (*this, f, c);
}

border& border::
operator= (const border& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

border::
~border ()
{
}

// roadMark
//

roadMark::
roadMark ()
: ::xml_schema::type (),
  type_ (this),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  type1_ (this),
  weight_ (this),
  color_ (this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
}

roadMark::
roadMark (const roadMark& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  type1_ (x.type1_, f, this),
  weight_ (x.weight_, f, this),
  color_ (x.color_, f, this),
  material_ (x.material_, f, this),
  width_ (x.width_, f, this),
  laneChange_ (x.laneChange_, f, this),
  height_ (x.height_, f, this)
{
}

roadMark::
roadMark (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  type1_ (this),
  weight_ (this),
  color_ (this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void roadMark::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!this->type_)
      {
        this->type_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type1_.set (type1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      this->weight_.set (weight_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      this->material_.set (material_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "laneChange" && n.namespace_ ().empty ())
    {
      this->laneChange_.set (laneChange_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }
  }
}

roadMark* roadMark::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class roadMark (*this, f, c);
}

roadMark& roadMark::
operator= (const roadMark& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->type1_ = x.type1_;
    this->weight_ = x.weight_;
    this->color_ = x.color_;
    this->material_ = x.material_;
    this->width_ = x.width_;
    this->laneChange_ = x.laneChange_;
    this->height_ = x.height_;
  }

  return *this;
}

roadMark::
~roadMark ()
{
}

// material
//

material::
material ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
}

material::
material (const material& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  surface_ (x.surface_, f, this),
  friction_ (x.friction_, f, this),
  roughness_ (x.roughness_, f, this)
{
}

material::
material (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      this->surface_.set (surface_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "friction" && n.namespace_ ().empty ())
    {
      this->friction_.set (friction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roughness" && n.namespace_ ().empty ())
    {
      this->roughness_.set (roughness_traits::create (i, f, this));
      continue;
    }
  }
}

material* material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class material (*this, f, c);
}

material& material::
operator= (const material& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->surface_ = x.surface_;
    this->friction_ = x.friction_;
    this->roughness_ = x.roughness_;
  }

  return *this;
}

material::
~material ()
{
}

// visibility
//

visibility::
visibility ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  forward_ (this),
  back_ (this),
  left_ (this),
  right_ (this)
{
}

visibility::
visibility (const visibility& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  forward_ (x.forward_, f, this),
  back_ (x.back_, f, this),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this)
{
}

visibility::
visibility (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  forward_ (this),
  back_ (this),
  left_ (this),
  right_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void visibility::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "forward" && n.namespace_ ().empty ())
    {
      this->forward_.set (forward_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      this->back_.set (back_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      this->left_.set (left_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      this->right_.set (right_traits::create (i, f, this));
      continue;
    }
  }
}

visibility* visibility::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class visibility (*this, f, c);
}

visibility& visibility::
operator= (const visibility& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->forward_ = x.forward_;
    this->back_ = x.back_;
    this->left_ = x.left_;
    this->right_ = x.right_;
  }

  return *this;
}

visibility::
~visibility ()
{
}

// speed
//

speed::
speed ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  t_max_ (this),
  unit_ (this)
{
}

speed::
speed (const speed& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  t_max_ (x.t_max_, f, this),
  unit_ (x.unit_, f, this)
{
}

speed::
speed (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  t_max_ (this),
  unit_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->t_max_.set (max_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }
  }
}

speed* speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class speed (*this, f, c);
}

speed& speed::
operator= (const speed& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->t_max_ = x.t_max_;
    this->unit_ = x.unit_;
  }

  return *this;
}

speed::
~speed ()
{
}

// access1
//

access1::
access1 ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  restriction_ (this)
{
}

access1::
access1 (const access1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  restriction_ (x.restriction_, f, this)
{
}

access1::
access1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  restriction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void access1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "restriction" && n.namespace_ ().empty ())
    {
      this->restriction_.set (restriction_traits::create (i, f, this));
      continue;
    }
  }
}

access1* access1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class access1 (*this, f, c);
}

access1& access1::
operator= (const access1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->restriction_ = x.restriction_;
  }

  return *this;
}

access1::
~access1 ()
{
}

// height
//

height::
height ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  inner_ (this),
  outer_ (this)
{
}

height::
height (const height& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  inner_ (x.inner_, f, this),
  outer_ (x.outer_, f, this)
{
}

height::
height (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  inner_ (this),
  outer_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void height::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "inner" && n.namespace_ ().empty ())
    {
      this->inner_.set (inner_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outer" && n.namespace_ ().empty ())
    {
      this->outer_.set (outer_traits::create (i, f, this));
      continue;
    }
  }
}

height* height::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class height (*this, f, c);
}

height& height::
operator= (const height& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->inner_ = x.inner_;
    this->outer_ = x.outer_;
  }

  return *this;
}

height::
~height ()
{
}

// rule1
//

rule1::
rule1 ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  value_ (this)
{
}

rule1::
rule1 (const rule1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  value_ (x.value_, f, this)
{
}

rule1::
rule1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void rule1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }
}

rule1* rule1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class rule1 (*this, f, c);
}

rule1& rule1::
operator= (const rule1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->value_ = x.value_;
  }

  return *this;
}

rule1::
~rule1 ()
{
}

// link1
//

link1::
link1 ()
: ::xml_schema::type (),
  predecessor_ (this),
  successor_ (this),
  userData_ (this),
  include_ (this)
{
}

link1::
link1 (const link1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

link1::
link1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void link1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      if (!this->predecessor_)
      {
        this->predecessor_.set (r);
        continue;
      }
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      if (!this->successor_)
      {
        this->successor_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

link1* link1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class link1 (*this, f, c);
}

link1& link1::
operator= (const link1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

link1::
~link1 ()
{
}

// roadMark1
//

roadMark1::
roadMark1 ()
: ::xml_schema::type (),
  type_ (this),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  type1_ (this),
  weight_ (this),
  color_ (this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
}

roadMark1::
roadMark1 (const roadMark1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  sOffset_ (x.sOffset_, f, this),
  type1_ (x.type1_, f, this),
  weight_ (x.weight_, f, this),
  color_ (x.color_, f, this),
  material_ (x.material_, f, this),
  width_ (x.width_, f, this),
  laneChange_ (x.laneChange_, f, this),
  height_ (x.height_, f, this)
{
}

roadMark1::
roadMark1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  userData_ (this),
  include_ (this),
  sOffset_ (this),
  type1_ (this),
  weight_ (this),
  color_ (this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void roadMark1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!this->type_)
      {
        this->type_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type1_.set (type1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      this->weight_.set (weight_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      this->material_.set (material_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "laneChange" && n.namespace_ ().empty ())
    {
      this->laneChange_.set (laneChange_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }
  }
}

roadMark1* roadMark1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class roadMark1 (*this, f, c);
}

roadMark1& roadMark1::
operator= (const roadMark1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->sOffset_ = x.sOffset_;
    this->type1_ = x.type1_;
    this->weight_ = x.weight_;
    this->color_ = x.color_;
    this->material_ = x.material_;
    this->width_ = x.width_;
    this->laneChange_ = x.laneChange_;
    this->height_ = x.height_;
  }

  return *this;
}

roadMark1::
~roadMark1 ()
{
}

// header
//

header::
header ()
: ::xml_schema::type (),
  geoReference_ (this),
  userData_ (this),
  include_ (this),
  revMajor_ (this),
  revMinor_ (this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  vendor_ (this)
{
}

header::
header (const header& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geoReference_ (x.geoReference_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  revMajor_ (x.revMajor_, f, this),
  revMinor_ (x.revMinor_, f, this),
  name_ (x.name_, f, this),
  version_ (x.version_, f, this),
  date_ (x.date_, f, this),
  north_ (x.north_, f, this),
  south_ (x.south_, f, this),
  east_ (x.east_, f, this),
  west_ (x.west_, f, this),
  vendor_ (x.vendor_, f, this)
{
}

header::
header (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geoReference_ (this),
  userData_ (this),
  include_ (this),
  revMajor_ (this),
  revMinor_ (this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  vendor_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geoReference
    //
    if (n.name () == "geoReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoReference_type > r (
        geoReference_traits::create (i, f, this));

      if (!this->geoReference_)
      {
        this->geoReference_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "revMajor" && n.namespace_ ().empty ())
    {
      this->revMajor_.set (revMajor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "revMinor" && n.namespace_ ().empty ())
    {
      this->revMinor_.set (revMinor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "date" && n.namespace_ ().empty ())
    {
      this->date_.set (date_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "north" && n.namespace_ ().empty ())
    {
      this->north_.set (north_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "south" && n.namespace_ ().empty ())
    {
      this->south_.set (south_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "east" && n.namespace_ ().empty ())
    {
      this->east_.set (east_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "west" && n.namespace_ ().empty ())
    {
      this->west_.set (west_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vendor" && n.namespace_ ().empty ())
    {
      this->vendor_.set (vendor_traits::create (i, f, this));
      continue;
    }
  }
}

header* header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class header (*this, f, c);
}

header& header::
operator= (const header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geoReference_ = x.geoReference_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->revMajor_ = x.revMajor_;
    this->revMinor_ = x.revMinor_;
    this->name_ = x.name_;
    this->version_ = x.version_;
    this->date_ = x.date_;
    this->north_ = x.north_;
    this->south_ = x.south_;
    this->east_ = x.east_;
    this->west_ = x.west_;
    this->vendor_ = x.vendor_;
  }

  return *this;
}

header::
~header ()
{
}

// road
//

road::
road (const planView_type& planView,
      const lanes_type& lanes)
: ::xml_schema::type (),
  lane_link_ (this),
  type_ (this),
  planView_ (planView, this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (lanes, this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this)
{
}

road::
road (::std::auto_ptr< planView_type > planView,
      ::std::auto_ptr< lanes_type > lanes)
: ::xml_schema::type (),
  lane_link_ (this),
  type_ (this),
  planView_ (planView, this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (lanes, this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this)
{
}

road::
road (const road& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_link_ (x.lane_link_, f, this),
  type_ (x.type_, f, this),
  planView_ (x.planView_, f, this),
  elevationProfile_ (x.elevationProfile_, f, this),
  lateralProfile_ (x.lateralProfile_, f, this),
  lanes_ (x.lanes_, f, this),
  objects_ (x.objects_, f, this),
  signals_ (x.signals_, f, this),
  surface_ (x.surface_, f, this),
  railroad_ (x.railroad_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  name_ (x.name_, f, this),
  length_ (x.length_, f, this),
  id_ (x.id_, f, this),
  junction_ (x.junction_, f, this)
{
}

road::
road (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_link_ (this),
  type_ (this),
  planView_ (this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void road::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->lane_link_)
      {
        this->lane_link_.set (r);
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.push_back (r);
      continue;
    }

    // planView
    //
    if (n.name () == "planView" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< planView_type > r (
        planView_traits::create (i, f, this));

      if (!planView_.present ())
      {
        this->planView_.set (r);
        continue;
      }
    }

    // elevationProfile
    //
    if (n.name () == "elevationProfile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< elevationProfile_type > r (
        elevationProfile_traits::create (i, f, this));

      if (!this->elevationProfile_)
      {
        this->elevationProfile_.set (r);
        continue;
      }
    }

    // lateralProfile
    //
    if (n.name () == "lateralProfile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lateralProfile_type > r (
        lateralProfile_traits::create (i, f, this));

      if (!this->lateralProfile_)
      {
        this->lateralProfile_.set (r);
        continue;
      }
    }

    // lanes
    //
    if (n.name () == "lanes" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lanes_type > r (
        lanes_traits::create (i, f, this));

      if (!lanes_.present ())
      {
        this->lanes_.set (r);
        continue;
      }
    }

    // objects
    //
    if (n.name () == "objects" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< objects_type > r (
        objects_traits::create (i, f, this));

      if (!this->objects_)
      {
        this->objects_.set (r);
        continue;
      }
    }

    // signals
    //
    if (n.name () == "signals" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< signals_type > r (
        signals_traits::create (i, f, this));

      if (!this->signals_)
      {
        this->signals_.set (r);
        continue;
      }
    }

    // surface
    //
    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< surface_type > r (
        surface_traits::create (i, f, this));

      if (!this->surface_)
      {
        this->surface_.set (r);
        continue;
      }
    }

    // railroad
    //
    if (n.name () == "railroad" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< railroad_type > r (
        railroad_traits::create (i, f, this));

      if (!this->railroad_)
      {
        this->railroad_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  if (!planView_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "planView",
      "");
  }

  if (!lanes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lanes",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      this->junction_.set (junction_traits::create (i, f, this));
      continue;
    }
  }
}

road* road::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class road (*this, f, c);
}

road& road::
operator= (const road& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_link_ = x.lane_link_;
    this->type_ = x.type_;
    this->planView_ = x.planView_;
    this->elevationProfile_ = x.elevationProfile_;
    this->lateralProfile_ = x.lateralProfile_;
    this->lanes_ = x.lanes_;
    this->objects_ = x.objects_;
    this->signals_ = x.signals_;
    this->surface_ = x.surface_;
    this->railroad_ = x.railroad_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->name_ = x.name_;
    this->length_ = x.length_;
    this->id_ = x.id_;
    this->junction_ = x.junction_;
  }

  return *this;
}

road::
~road ()
{
}

// controller
//

controller::
controller ()
: ::xml_schema::type (),
  control_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  name_ (this),
  sequence_ (this)
{
}

controller::
controller (const controller& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  control_ (x.control_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this),
  sequence_ (x.sequence_, f, this)
{
}

controller::
controller (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  control_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  name_ (this),
  sequence_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void controller::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // control
    //
    if (n.name () == "control" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< control_type > r (
        control_traits::create (i, f, this));

      this->control_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sequence" && n.namespace_ ().empty ())
    {
      this->sequence_.set (sequence_traits::create (i, f, this));
      continue;
    }
  }
}

controller* controller::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class controller (*this, f, c);
}

controller& controller::
operator= (const controller& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->control_ = x.control_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->sequence_ = x.sequence_;
  }

  return *this;
}

controller::
~controller ()
{
}

// junction
//

junction::
junction ()
: ::xml_schema::type (),
  connection_ (this),
  priority_ (this),
  controller_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this)
{
}

junction::
junction (const junction& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  connection_ (x.connection_, f, this),
  priority_ (x.priority_, f, this),
  controller_ (x.controller_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this)
{
}

junction::
junction (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  connection_ (this),
  priority_ (this),
  controller_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void junction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // connection
    //
    if (n.name () == "connection" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< connection_type > r (
        connection_traits::create (i, f, this));

      this->connection_.push_back (r);
      continue;
    }

    // priority
    //
    if (n.name () == "priority" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< priority_type > r (
        priority_traits::create (i, f, this));

      this->priority_.push_back (r);
      continue;
    }

    // controller
    //
    if (n.name () == "controller" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< controller_type > r (
        controller_traits::create (i, f, this));

      this->controller_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

junction* junction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class junction (*this, f, c);
}

junction& junction::
operator= (const junction& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->connection_ = x.connection_;
    this->priority_ = x.priority_;
    this->controller_ = x.controller_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->name_ = x.name_;
    this->id_ = x.id_;
  }

  return *this;
}

junction::
~junction ()
{
}

// junctionGroup
//

junctionGroup::
junctionGroup ()
: ::xml_schema::type (),
  junctionReference_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
}

junctionGroup::
junctionGroup (const junctionGroup& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  junctionReference_ (x.junctionReference_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

junctionGroup::
junctionGroup (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  junctionReference_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void junctionGroup::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // junctionReference
    //
    if (n.name () == "junctionReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< junctionReference_type > r (
        junctionReference_traits::create (i, f, this));

      this->junctionReference_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

junctionGroup* junctionGroup::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class junctionGroup (*this, f, c);
}

junctionGroup& junctionGroup::
operator= (const junctionGroup& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->junctionReference_ = x.junctionReference_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

junctionGroup::
~junctionGroup ()
{
}

// station
//

station::
station ()
: ::xml_schema::type (),
  platform_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
}

station::
station (const station& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  platform_ (x.platform_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

station::
station (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  platform_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void station::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // platform
    //
    if (n.name () == "platform" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< platform_type > r (
        platform_traits::create (i, f, this));

      this->platform_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

station* station::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class station (*this, f, c);
}

station& station::
operator= (const station& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->platform_ = x.platform_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

station::
~station ()
{
}

// predecessor
//

predecessor::
predecessor ()
: ::xml_schema::type (),
  id_ (this)
{
}

predecessor::
predecessor (const predecessor& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this)
{
}

predecessor::
predecessor (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void predecessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

predecessor* predecessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class predecessor (*this, f, c);
}

predecessor& predecessor::
operator= (const predecessor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

predecessor::
~predecessor ()
{
}

// successor
//

successor::
successor ()
: ::xml_schema::type (),
  id_ (this)
{
}

successor::
successor (const successor& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this)
{
}

successor::
successor (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void successor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

successor* successor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class successor (*this, f, c);
}

successor& successor::
operator= (const successor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

successor::
~successor ()
{
}

// type
//

type::
type ()
: ::xml_schema::type (),
  line_ (this),
  name_ (this),
  width_ (this)
{
}

type::
type (const type& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  line_ (x.line_, f, this),
  name_ (x.name_, f, this),
  width_ (x.width_, f, this)
{
}

type::
type (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  name_ (this),
  width_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< line_type > r (
        line_traits::create (i, f, this));

      this->line_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }
  }
}

type* type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type (*this, f, c);
}

type& type::
operator= (const type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->line_ = x.line_;
    this->name_ = x.name_;
    this->width_ = x.width_;
  }

  return *this;
}

type::
~type ()
{
}

// type1
//

type1::
type1 ()
: ::xml_schema::type (),
  line_ (this),
  name_ (this),
  width_ (this)
{
}

type1::
type1 (const type1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  line_ (x.line_, f, this),
  name_ (x.name_, f, this),
  width_ (x.width_, f, this)
{
}

type1::
type1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  name_ (this),
  width_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void type1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< line_type > r (
        line_traits::create (i, f, this));

      this->line_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }
  }
}

type1* type1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type1 (*this, f, c);
}

type1& type1::
operator= (const type1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->line_ = x.line_;
    this->name_ = x.name_;
    this->width_ = x.width_;
  }

  return *this;
}

type1::
~type1 ()
{
}

// link2
//

link2::
link2 ()
: ::xml_schema::type (),
  predecessor_ (this),
  successor_ (this),
  neighbor_ (this),
  userData_ (this),
  include_ (this)
{
}

link2::
link2 (const link2& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  neighbor_ (x.neighbor_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

link2::
link2 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  neighbor_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void link2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      if (!this->predecessor_)
      {
        this->predecessor_.set (r);
        continue;
      }
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      if (!this->successor_)
      {
        this->successor_.set (r);
        continue;
      }
    }

    // neighbor
    //
    if (n.name () == "neighbor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< neighbor_type > r (
        neighbor_traits::create (i, f, this));

      this->neighbor_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

link2* link2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class link2 (*this, f, c);
}

link2& link2::
operator= (const link2& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->neighbor_ = x.neighbor_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

link2::
~link2 ()
{
}

// type2
//

type2::
type2 ()
: ::xml_schema::type (),
  speed_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  type_ (this)
{
}

type2::
type2 (const type2& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  speed_ (x.speed_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  type_ (x.type_, f, this)
{
}

type2::
type2 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  speed_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void type2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // speed
    //
    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      if (!this->speed_)
      {
        this->speed_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

type2* type2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type2 (*this, f, c);
}

type2& type2::
operator= (const type2& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->speed_ = x.speed_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->type_ = x.type_;
  }

  return *this;
}

type2::
~type2 ()
{
}

// planView
//

planView::
planView ()
: ::xml_schema::type (),
  geometry_ (this)
{
}

planView::
planView (const planView& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this)
{
}

planView::
planView (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void planView::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      this->geometry_.push_back (r);
      continue;
    }

    break;
  }
}

planView* planView::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class planView (*this, f, c);
}

planView& planView::
operator= (const planView& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
  }

  return *this;
}

planView::
~planView ()
{
}

// elevationProfile
//

elevationProfile::
elevationProfile ()
: ::xml_schema::type (),
  elevation_ (this),
  userData_ (this),
  include_ (this)
{
}

elevationProfile::
elevationProfile (const elevationProfile& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  elevation_ (x.elevation_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

elevationProfile::
elevationProfile (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  elevation_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void elevationProfile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // elevation
    //
    if (n.name () == "elevation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< elevation_type > r (
        elevation_traits::create (i, f, this));

      this->elevation_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

elevationProfile* elevationProfile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class elevationProfile (*this, f, c);
}

elevationProfile& elevationProfile::
operator= (const elevationProfile& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->elevation_ = x.elevation_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

elevationProfile::
~elevationProfile ()
{
}

// lateralProfile
//

lateralProfile::
lateralProfile ()
: ::xml_schema::type (),
  superelevation_ (this),
  crossfall_ (this),
  shape_ (this),
  userData_ (this),
  include_ (this)
{
}

lateralProfile::
lateralProfile (const lateralProfile& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  superelevation_ (x.superelevation_, f, this),
  crossfall_ (x.crossfall_, f, this),
  shape_ (x.shape_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

lateralProfile::
lateralProfile (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  superelevation_ (this),
  crossfall_ (this),
  shape_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lateralProfile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // superelevation
    //
    if (n.name () == "superelevation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< superelevation_type > r (
        superelevation_traits::create (i, f, this));

      this->superelevation_.push_back (r);
      continue;
    }

    // crossfall
    //
    if (n.name () == "crossfall" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< crossfall_type > r (
        crossfall_traits::create (i, f, this));

      this->crossfall_.push_back (r);
      continue;
    }

    // shape
    //
    if (n.name () == "shape" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shape_type > r (
        shape_traits::create (i, f, this));

      this->shape_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

lateralProfile* lateralProfile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lateralProfile (*this, f, c);
}

lateralProfile& lateralProfile::
operator= (const lateralProfile& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->superelevation_ = x.superelevation_;
    this->crossfall_ = x.crossfall_;
    this->shape_ = x.shape_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

lateralProfile::
~lateralProfile ()
{
}

// lanes
//

lanes::
lanes ()
: ::xml_schema::type (),
  laneOffset_ (this),
  laneSection_ (this)
{
}

lanes::
lanes (const lanes& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  laneOffset_ (x.laneOffset_, f, this),
  laneSection_ (x.laneSection_, f, this)
{
}

lanes::
lanes (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  laneOffset_ (this),
  laneSection_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lanes::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // laneOffset
    //
    if (n.name () == "laneOffset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< laneOffset_type > r (
        laneOffset_traits::create (i, f, this));

      this->laneOffset_.push_back (r);
      continue;
    }

    // laneSection
    //
    if (n.name () == "laneSection" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< laneSection_type > r (
        laneSection_traits::create (i, f, this));

      this->laneSection_.push_back (r);
      continue;
    }

    break;
  }
}

lanes* lanes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lanes (*this, f, c);
}

lanes& lanes::
operator= (const lanes& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->laneOffset_ = x.laneOffset_;
    this->laneSection_ = x.laneSection_;
  }

  return *this;
}

lanes::
~lanes ()
{
}

// objects
//

objects::
objects ()
: ::xml_schema::type (),
  object_ (this),
  objectReference_ (this),
  tunnel_ (this),
  bridge_ (this),
  userData_ (this),
  include_ (this)
{
}

objects::
objects (const objects& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  object_ (x.object_, f, this),
  objectReference_ (x.objectReference_, f, this),
  tunnel_ (x.tunnel_, f, this),
  bridge_ (x.bridge_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

objects::
objects (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  object_ (this),
  objectReference_ (this),
  tunnel_ (this),
  bridge_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void objects::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // object
    //
    if (n.name () == "object" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< object_type > r (
        object_traits::create (i, f, this));

      this->object_.push_back (r);
      continue;
    }

    // objectReference
    //
    if (n.name () == "objectReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< objectReference_type > r (
        objectReference_traits::create (i, f, this));

      this->objectReference_.push_back (r);
      continue;
    }

    // tunnel
    //
    if (n.name () == "tunnel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tunnel_type > r (
        tunnel_traits::create (i, f, this));

      this->tunnel_.push_back (r);
      continue;
    }

    // bridge
    //
    if (n.name () == "bridge" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bridge_type > r (
        bridge_traits::create (i, f, this));

      this->bridge_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

objects* objects::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class objects (*this, f, c);
}

objects& objects::
operator= (const objects& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->object_ = x.object_;
    this->objectReference_ = x.objectReference_;
    this->tunnel_ = x.tunnel_;
    this->bridge_ = x.bridge_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

objects::
~objects ()
{
}

// signals
//

signals::
signals ()
: ::xml_schema::type (),
  signal_ (this),
  signalReference_ (this),
  userData_ (this),
  include_ (this)
{
}

signals::
signals (const signals& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  signal_ (x.signal_, f, this),
  signalReference_ (x.signalReference_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

signals::
signals (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  signal_ (this),
  signalReference_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void signals::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // signal
    //
    if (n.name () == "signal" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< signal_type > r (
        signal_traits::create (i, f, this));

      this->signal_.push_back (r);
      continue;
    }

    // signalReference
    //
    if (n.name () == "signalReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< signalReference_type > r (
        signalReference_traits::create (i, f, this));

      this->signalReference_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

signals* signals::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class signals (*this, f, c);
}

signals& signals::
operator= (const signals& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->signal_ = x.signal_;
    this->signalReference_ = x.signalReference_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

signals::
~signals ()
{
}

// surface
//

surface::
surface ()
: ::xml_schema::type (),
  CRG_ (this),
  userData_ (this),
  include_ (this)
{
}

surface::
surface (const surface& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  CRG_ (x.CRG_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

surface::
surface (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  CRG_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void surface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CRG
    //
    if (n.name () == "CRG" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CRG_type > r (
        CRG_traits::create (i, f, this));

      this->CRG_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

surface* surface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class surface (*this, f, c);
}

surface& surface::
operator= (const surface& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->CRG_ = x.CRG_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

surface::
~surface ()
{
}

// railroad
//

railroad::
railroad ()
: ::xml_schema::type (),
  switch__ (this),
  userData_ (this),
  include_ (this)
{
}

railroad::
railroad (const railroad& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  switch__ (x.switch__, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

railroad::
railroad (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  switch__ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void railroad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // switch
    //
    if (n.name () == "switch" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< switch_type > r (
        switch_traits::create (i, f, this));

      this->switch__.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

railroad* railroad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class railroad (*this, f, c);
}

railroad& railroad::
operator= (const railroad& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->switch__ = x.switch__;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

railroad::
~railroad ()
{
}

// control
//

control::
control ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  signalId_ (this),
  type_ (this)
{
}

control::
control (const control& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  signalId_ (x.signalId_, f, this),
  type_ (x.type_, f, this)
{
}

control::
control (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  signalId_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void control::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "signalId" && n.namespace_ ().empty ())
    {
      this->signalId_.set (signalId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

control* control::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class control (*this, f, c);
}

control& control::
operator= (const control& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->signalId_ = x.signalId_;
    this->type_ = x.type_;
  }

  return *this;
}

control::
~control ()
{
}

// connection
//

connection::
connection ()
: ::xml_schema::type (),
  laneLink_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  incomingRoad_ (this),
  connectingRoad_ (this),
  contactPoint_ (this)
{
}

connection::
connection (const connection& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  laneLink_ (x.laneLink_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  id_ (x.id_, f, this),
  incomingRoad_ (x.incomingRoad_, f, this),
  connectingRoad_ (x.connectingRoad_, f, this),
  contactPoint_ (x.contactPoint_, f, this)
{
}

connection::
connection (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  laneLink_ (this),
  userData_ (this),
  include_ (this),
  id_ (this),
  incomingRoad_ (this),
  connectingRoad_ (this),
  contactPoint_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void connection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // laneLink
    //
    if (n.name () == "laneLink" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< laneLink_type > r (
        laneLink_traits::create (i, f, this));

      this->laneLink_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "incomingRoad" && n.namespace_ ().empty ())
    {
      this->incomingRoad_.set (incomingRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "connectingRoad" && n.namespace_ ().empty ())
    {
      this->connectingRoad_.set (connectingRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }
  }
}

connection* connection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class connection (*this, f, c);
}

connection& connection::
operator= (const connection& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->laneLink_ = x.laneLink_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->id_ = x.id_;
    this->incomingRoad_ = x.incomingRoad_;
    this->connectingRoad_ = x.connectingRoad_;
    this->contactPoint_ = x.contactPoint_;
  }

  return *this;
}

connection::
~connection ()
{
}

// priority
//

priority::
priority ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  high_ (this),
  low_ (this)
{
}

priority::
priority (const priority& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  high_ (x.high_, f, this),
  low_ (x.low_, f, this)
{
}

priority::
priority (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  high_ (this),
  low_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void priority::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "high" && n.namespace_ ().empty ())
    {
      this->high_.set (high_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "low" && n.namespace_ ().empty ())
    {
      this->low_.set (low_traits::create (i, f, this));
      continue;
    }
  }
}

priority* priority::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class priority (*this, f, c);
}

priority& priority::
operator= (const priority& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->high_ = x.high_;
    this->low_ = x.low_;
  }

  return *this;
}

priority::
~priority ()
{
}

// controller1
//

controller1::
controller1 ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this),
  sequence_ (this)
{
}

controller1::
controller1 (const controller1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  sequence_ (x.sequence_, f, this)
{
}

controller1::
controller1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this),
  sequence_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void controller1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sequence" && n.namespace_ ().empty ())
    {
      this->sequence_.set (sequence_traits::create (i, f, this));
      continue;
    }
  }
}

controller1* controller1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class controller1 (*this, f, c);
}

controller1& controller1::
operator= (const controller1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->sequence_ = x.sequence_;
  }

  return *this;
}

controller1::
~controller1 ()
{
}

// junctionReference
//

junctionReference::
junctionReference ()
: ::xml_schema::type (),
  junction_ (this)
{
}

junctionReference::
junctionReference (const junctionReference& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  junction_ (x.junction_, f, this)
{
}

junctionReference::
junctionReference (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  junction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void junctionReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      this->junction_.set (junction_traits::create (i, f, this));
      continue;
    }
  }
}

junctionReference* junctionReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class junctionReference (*this, f, c);
}

junctionReference& junctionReference::
operator= (const junctionReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->junction_ = x.junction_;
  }

  return *this;
}

junctionReference::
~junctionReference ()
{
}

// platform
//

platform::
platform ()
: ::xml_schema::type (),
  segment_ (this),
  name_ (this),
  id_ (this)
{
}

platform::
platform (const platform& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  segment_ (x.segment_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this)
{
}

platform::
platform (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  segment_ (this),
  name_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void platform::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // segment
    //
    if (n.name () == "segment" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< segment_type > r (
        segment_traits::create (i, f, this));

      this->segment_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

platform* platform::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class platform (*this, f, c);
}

platform& platform::
operator= (const platform& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->segment_ = x.segment_;
    this->name_ = x.name_;
    this->id_ = x.id_;
  }

  return *this;
}

platform::
~platform ()
{
}

// line
//

line::
line ()
: ::xml_schema::type (),
  length_ (this),
  space_ (this),
  tOffset_ (this),
  sOffset_ (this),
  rule_ (this),
  width_ (this)
{
}

line::
line (const line& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  length_ (x.length_, f, this),
  space_ (x.space_, f, this),
  tOffset_ (x.tOffset_, f, this),
  sOffset_ (x.sOffset_, f, this),
  rule_ (x.rule_, f, this),
  width_ (x.width_, f, this)
{
}

line::
line (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  length_ (this),
  space_ (this),
  tOffset_ (this),
  sOffset_ (this),
  rule_ (this),
  width_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void line::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "space" && n.namespace_ ().empty ())
    {
      this->space_.set (space_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }
  }
}

line* line::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class line (*this, f, c);
}

line& line::
operator= (const line& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->length_ = x.length_;
    this->space_ = x.space_;
    this->tOffset_ = x.tOffset_;
    this->sOffset_ = x.sOffset_;
    this->rule_ = x.rule_;
    this->width_ = x.width_;
  }

  return *this;
}

line::
~line ()
{
}

// predecessor1
//

predecessor1::
predecessor1 ()
: ::xml_schema::type (),
  elementType_ (this),
  elementId_ (this),
  contactPoint_ (this)
{
}

predecessor1::
predecessor1 (const predecessor1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  elementType_ (x.elementType_, f, this),
  elementId_ (x.elementId_, f, this),
  contactPoint_ (x.contactPoint_, f, this)
{
}

predecessor1::
predecessor1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  elementType_ (this),
  elementId_ (this),
  contactPoint_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void predecessor1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }
  }
}

predecessor1* predecessor1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class predecessor1 (*this, f, c);
}

predecessor1& predecessor1::
operator= (const predecessor1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->elementType_ = x.elementType_;
    this->elementId_ = x.elementId_;
    this->contactPoint_ = x.contactPoint_;
  }

  return *this;
}

predecessor1::
~predecessor1 ()
{
}

// successor1
//

successor1::
successor1 ()
: ::xml_schema::type (),
  elementType_ (this),
  elementId_ (this),
  contactPoint_ (this)
{
}

successor1::
successor1 (const successor1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  elementType_ (x.elementType_, f, this),
  elementId_ (x.elementId_, f, this),
  contactPoint_ (x.contactPoint_, f, this)
{
}

successor1::
successor1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  elementType_ (this),
  elementId_ (this),
  contactPoint_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void successor1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }
  }
}

successor1* successor1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class successor1 (*this, f, c);
}

successor1& successor1::
operator= (const successor1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->elementType_ = x.elementType_;
    this->elementId_ = x.elementId_;
    this->contactPoint_ = x.contactPoint_;
  }

  return *this;
}

successor1::
~successor1 ()
{
}

// neighbor
//

neighbor::
neighbor ()
: ::xml_schema::type (),
  side_ (this),
  elementId_ (this),
  direction_ (this)
{
}

neighbor::
neighbor (const neighbor& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  side_ (x.side_, f, this),
  elementId_ (x.elementId_, f, this),
  direction_ (x.direction_, f, this)
{
}

neighbor::
neighbor (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  side_ (this),
  elementId_ (this),
  direction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void neighbor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "direction" && n.namespace_ ().empty ())
    {
      this->direction_.set (direction_traits::create (i, f, this));
      continue;
    }
  }
}

neighbor* neighbor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class neighbor (*this, f, c);
}

neighbor& neighbor::
operator= (const neighbor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->side_ = x.side_;
    this->elementId_ = x.elementId_;
    this->direction_ = x.direction_;
  }

  return *this;
}

neighbor::
~neighbor ()
{
}

// speed1
//

speed1::
speed1 ()
: ::xml_schema::type (),
  t_max_ (this),
  unit_ (this)
{
}

speed1::
speed1 (const speed1& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  t_max_ (x.t_max_, f, this),
  unit_ (x.unit_, f, this)
{
}

speed1::
speed1 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  t_max_ (this),
  unit_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void speed1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->t_max_.set (max_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }
  }
}

speed1* speed1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class speed1 (*this, f, c);
}

speed1& speed1::
operator= (const speed1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->t_max_ = x.t_max_;
    this->unit_ = x.unit_;
  }

  return *this;
}

speed1::
~speed1 ()
{
}

// geometry
//

geometry::
geometry ()
: ::xml_schema::type (),
  line_ (this),
  spiral_ (this),
  arc_ (this),
  poly3_ (this),
  paramPoly3_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  x_ (this),
  y_ (this),
  hdg_ (this),
  length_ (this)
{
}

geometry::
geometry (const geometry& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  line_ (x.line_, f, this),
  spiral_ (x.spiral_, f, this),
  arc_ (x.arc_, f, this),
  poly3_ (x.poly3_, f, this),
  paramPoly3_ (x.paramPoly3_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  hdg_ (x.hdg_, f, this),
  length_ (x.length_, f, this)
{
}

geometry::
geometry (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  spiral_ (this),
  arc_ (this),
  poly3_ (this),
  paramPoly3_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  x_ (this),
  y_ (this),
  hdg_ (this),
  length_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void geometry::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< line_type > r (
        line_traits::create (i, f, this));

      if (!this->line_)
      {
        this->line_.set (r);
        continue;
      }
    }

    // spiral
    //
    if (n.name () == "spiral" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spiral_type > r (
        spiral_traits::create (i, f, this));

      if (!this->spiral_)
      {
        this->spiral_.set (r);
        continue;
      }
    }

    // arc
    //
    if (n.name () == "arc" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< arc_type > r (
        arc_traits::create (i, f, this));

      if (!this->arc_)
      {
        this->arc_.set (r);
        continue;
      }
    }

    // poly3
    //
    if (n.name () == "poly3" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< poly3_type > r (
        poly3_traits::create (i, f, this));

      if (!this->poly3_)
      {
        this->poly3_.set (r);
        continue;
      }
    }

    // paramPoly3
    //
    if (n.name () == "paramPoly3" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< paramPoly3_type > r (
        paramPoly3_traits::create (i, f, this));

      if (!this->paramPoly3_)
      {
        this->paramPoly3_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }
  }
}

geometry* geometry::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class geometry (*this, f, c);
}

geometry& geometry::
operator= (const geometry& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->line_ = x.line_;
    this->spiral_ = x.spiral_;
    this->arc_ = x.arc_;
    this->poly3_ = x.poly3_;
    this->paramPoly3_ = x.paramPoly3_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->hdg_ = x.hdg_;
    this->length_ = x.length_;
  }

  return *this;
}

geometry::
~geometry ()
{
}

// elevation
//

elevation::
elevation ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

elevation::
elevation (const elevation& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

elevation::
elevation (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void elevation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

elevation* elevation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class elevation (*this, f, c);
}

elevation& elevation::
operator= (const elevation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

elevation::
~elevation ()
{
}

// superelevation
//

superelevation::
superelevation ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

superelevation::
superelevation (const superelevation& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

superelevation::
superelevation (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void superelevation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

superelevation* superelevation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class superelevation (*this, f, c);
}

superelevation& superelevation::
operator= (const superelevation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

superelevation::
~superelevation ()
{
}

// crossfall
//

crossfall::
crossfall ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  side_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

crossfall::
crossfall (const crossfall& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  side_ (x.side_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

crossfall::
crossfall (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  side_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void crossfall::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

crossfall* crossfall::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class crossfall (*this, f, c);
}

crossfall& crossfall::
operator= (const crossfall& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->side_ = x.side_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

crossfall::
~crossfall ()
{
}

// shape
//

shape::
shape ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

shape::
shape (const shape& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

shape::
shape (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void shape::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

shape* shape::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class shape (*this, f, c);
}

shape& shape::
operator= (const shape& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

shape::
~shape ()
{
}

// laneOffset
//

laneOffset::
laneOffset ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

laneOffset::
laneOffset (const laneOffset& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

laneOffset::
laneOffset (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void laneOffset::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

laneOffset* laneOffset::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneOffset (*this, f, c);
}

laneOffset& laneOffset::
operator= (const laneOffset& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

laneOffset::
~laneOffset ()
{
}

// laneSection
//

laneSection::
laneSection (const center_type& center)
: ::xml_schema::type (),
  left_ (this),
  center_ (center, this),
  right_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  singleSide_ (this)
{
}

laneSection::
laneSection (::std::auto_ptr< center_type > center)
: ::xml_schema::type (),
  left_ (this),
  center_ (center, this),
  right_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  singleSide_ (this)
{
}

laneSection::
laneSection (const laneSection& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  left_ (x.left_, f, this),
  center_ (x.center_, f, this),
  right_ (x.right_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  singleSide_ (x.singleSide_, f, this)
{
}

laneSection::
laneSection (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  center_ (this),
  right_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  singleSide_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void laneSection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!this->left_)
      {
        this->left_.set (r);
        continue;
      }
    }

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      if (!center_.present ())
      {
        this->center_.set (r);
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!this->right_)
      {
        this->right_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  if (!center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "singleSide" && n.namespace_ ().empty ())
    {
      this->singleSide_.set (singleSide_traits::create (i, f, this));
      continue;
    }
  }
}

laneSection* laneSection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneSection (*this, f, c);
}

laneSection& laneSection::
operator= (const laneSection& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->left_ = x.left_;
    this->center_ = x.center_;
    this->right_ = x.right_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->singleSide_ = x.singleSide_;
  }

  return *this;
}

laneSection::
~laneSection ()
{
}

// object
//

object::
object ()
: ::xml_schema::type (),
  repeat_ (this),
  outline_ (this),
  material_ (this),
  validity_ (this),
  parkingSpace_ (this),
  userData_ (this),
  include_ (this),
  type_ (this),
  name_ (this),
  id_ (this),
  s_ (this),
  t_ (this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (this),
  length_ (this),
  width_ (this),
  radius_ (this),
  height_ (this),
  hdg_ (this),
  pitch_ (this),
  roll_ (this)
{
}

object::
object (const object& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  repeat_ (x.repeat_, f, this),
  outline_ (x.outline_, f, this),
  material_ (x.material_, f, this),
  validity_ (x.validity_, f, this),
  parkingSpace_ (x.parkingSpace_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  type_ (x.type_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  zOffset_ (x.zOffset_, f, this),
  validLength_ (x.validLength_, f, this),
  orientation_ (x.orientation_, f, this),
  length_ (x.length_, f, this),
  width_ (x.width_, f, this),
  radius_ (x.radius_, f, this),
  height_ (x.height_, f, this),
  hdg_ (x.hdg_, f, this),
  pitch_ (x.pitch_, f, this),
  roll_ (x.roll_, f, this)
{
}

object::
object (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  repeat_ (this),
  outline_ (this),
  material_ (this),
  validity_ (this),
  parkingSpace_ (this),
  userData_ (this),
  include_ (this),
  type_ (this),
  name_ (this),
  id_ (this),
  s_ (this),
  t_ (this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (this),
  length_ (this),
  width_ (this),
  radius_ (this),
  height_ (this),
  hdg_ (this),
  pitch_ (this),
  roll_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void object::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // repeat
    //
    if (n.name () == "repeat" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeat_type > r (
        repeat_traits::create (i, f, this));

      this->repeat_.push_back (r);
      continue;
    }

    // outline
    //
    if (n.name () == "outline" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outline_type > r (
        outline_traits::create (i, f, this));

      if (!this->outline_)
      {
        this->outline_.set (r);
        continue;
      }
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< material_type > r (
        material_traits::create (i, f, this));

      if (!this->material_)
      {
        this->material_.set (r);
        continue;
      }
    }

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // parkingSpace
    //
    if (n.name () == "parkingSpace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parkingSpace_type > r (
        parkingSpace_traits::create (i, f, this));

      if (!this->parkingSpace_)
      {
        this->parkingSpace_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "validLength" && n.namespace_ ().empty ())
    {
      this->validLength_.set (validLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      this->pitch_.set (pitch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roll" && n.namespace_ ().empty ())
    {
      this->roll_.set (roll_traits::create (i, f, this));
      continue;
    }
  }
}

object* object::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class object (*this, f, c);
}

object& object::
operator= (const object& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->repeat_ = x.repeat_;
    this->outline_ = x.outline_;
    this->material_ = x.material_;
    this->validity_ = x.validity_;
    this->parkingSpace_ = x.parkingSpace_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->type_ = x.type_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->zOffset_ = x.zOffset_;
    this->validLength_ = x.validLength_;
    this->orientation_ = x.orientation_;
    this->length_ = x.length_;
    this->width_ = x.width_;
    this->radius_ = x.radius_;
    this->height_ = x.height_;
    this->hdg_ = x.hdg_;
    this->pitch_ = x.pitch_;
    this->roll_ = x.roll_;
  }

  return *this;
}

object::
~object ()
{
}

// objectReference
//

objectReference::
objectReference ()
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (this)
{
}

objectReference::
objectReference (const objectReference& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  id_ (x.id_, f, this),
  zOffset_ (x.zOffset_, f, this),
  validLength_ (x.validLength_, f, this),
  orientation_ (x.orientation_, f, this)
{
}

objectReference::
objectReference (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void objectReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "validLength" && n.namespace_ ().empty ())
    {
      this->validLength_.set (validLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }
  }
}

objectReference* objectReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class objectReference (*this, f, c);
}

objectReference& objectReference::
operator= (const objectReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->id_ = x.id_;
    this->zOffset_ = x.zOffset_;
    this->validLength_ = x.validLength_;
    this->orientation_ = x.orientation_;
  }

  return *this;
}

objectReference::
~objectReference ()
{
}

// tunnel
//

tunnel::
tunnel ()
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this),
  lighting_ (this),
  daylight_ (this)
{
}

tunnel::
tunnel (const tunnel& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  lighting_ (x.lighting_, f, this),
  daylight_ (x.daylight_, f, this)
{
}

tunnel::
tunnel (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this),
  lighting_ (this),
  daylight_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void tunnel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lighting" && n.namespace_ ().empty ())
    {
      this->lighting_.set (lighting_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "daylight" && n.namespace_ ().empty ())
    {
      this->daylight_.set (daylight_traits::create (i, f, this));
      continue;
    }
  }
}

tunnel* tunnel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tunnel (*this, f, c);
}

tunnel& tunnel::
operator= (const tunnel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->lighting_ = x.lighting_;
    this->daylight_ = x.daylight_;
  }

  return *this;
}

tunnel::
~tunnel ()
{
}

// bridge
//

bridge::
bridge ()
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
}

bridge::
bridge (const bridge& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

bridge::
bridge (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void bridge::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

bridge* bridge::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class bridge (*this, f, c);
}

bridge& bridge::
operator= (const bridge& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

bridge::
~bridge ()
{
}

// signal
//

signal::
signal ()
: ::xml_schema::type (),
  validity_ (this),
  dependency_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  name_ (this),
  dynamic_ (this),
  orientation_ (this),
  zOffset_ (this),
  country_ (this),
  type_ (this),
  subtype_ (this),
  value_ (this),
  unit_ (this),
  height_ (this),
  width_ (this),
  text_ (this),
  hOffset_ (this),
  pitch_ (this),
  roll_ (this)
{
}

signal::
signal (const signal& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  dependency_ (x.dependency_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this),
  dynamic_ (x.dynamic_, f, this),
  orientation_ (x.orientation_, f, this),
  zOffset_ (x.zOffset_, f, this),
  country_ (x.country_, f, this),
  type_ (x.type_, f, this),
  subtype_ (x.subtype_, f, this),
  value_ (x.value_, f, this),
  unit_ (x.unit_, f, this),
  height_ (x.height_, f, this),
  width_ (x.width_, f, this),
  text_ (x.text_, f, this),
  hOffset_ (x.hOffset_, f, this),
  pitch_ (x.pitch_, f, this),
  roll_ (x.roll_, f, this)
{
}

signal::
signal (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  dependency_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  name_ (this),
  dynamic_ (this),
  orientation_ (this),
  zOffset_ (this),
  country_ (this),
  type_ (this),
  subtype_ (this),
  value_ (this),
  unit_ (this),
  height_ (this),
  width_ (this),
  text_ (this),
  hOffset_ (this),
  pitch_ (this),
  roll_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void signal::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // dependency
    //
    if (n.name () == "dependency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dependency_type > r (
        dependency_traits::create (i, f, this));

      this->dependency_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dynamic" && n.namespace_ ().empty ())
    {
      this->dynamic_.set (dynamic_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "country" && n.namespace_ ().empty ())
    {
      this->country_.set (country_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "subtype" && n.namespace_ ().empty ())
    {
      this->subtype_.set (subtype_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "text" && n.namespace_ ().empty ())
    {
      this->text_.set (text_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hOffset" && n.namespace_ ().empty ())
    {
      this->hOffset_.set (hOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      this->pitch_.set (pitch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roll" && n.namespace_ ().empty ())
    {
      this->roll_.set (roll_traits::create (i, f, this));
      continue;
    }
  }
}

signal* signal::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class signal (*this, f, c);
}

signal& signal::
operator= (const signal& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->dependency_ = x.dependency_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->dynamic_ = x.dynamic_;
    this->orientation_ = x.orientation_;
    this->zOffset_ = x.zOffset_;
    this->country_ = x.country_;
    this->type_ = x.type_;
    this->subtype_ = x.subtype_;
    this->value_ = x.value_;
    this->unit_ = x.unit_;
    this->height_ = x.height_;
    this->width_ = x.width_;
    this->text_ = x.text_;
    this->hOffset_ = x.hOffset_;
    this->pitch_ = x.pitch_;
    this->roll_ = x.roll_;
  }

  return *this;
}

signal::
~signal ()
{
}

// signalReference
//

signalReference::
signalReference ()
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  orientation_ (this)
{
}

signalReference::
signalReference (const signalReference& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  id_ (x.id_, f, this),
  orientation_ (x.orientation_, f, this)
{
}

signalReference::
signalReference (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  orientation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void signalReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }
  }
}

signalReference* signalReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class signalReference (*this, f, c);
}

signalReference& signalReference::
operator= (const signalReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->id_ = x.id_;
    this->orientation_ = x.orientation_;
  }

  return *this;
}

signalReference::
~signalReference ()
{
}

// CRG
//

CRG::
CRG ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  file_ (this),
  sStart_ (this),
  sEnd_ (this),
  orientation_ (this),
  mode_ (this),
  purpose_ (this),
  sOffset_ (this),
  tOffset_ (this),
  zOffset_ (this),
  zScale_ (this),
  hOffset_ (this)
{
}

CRG::
CRG (const CRG& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  file_ (x.file_, f, this),
  sStart_ (x.sStart_, f, this),
  sEnd_ (x.sEnd_, f, this),
  orientation_ (x.orientation_, f, this),
  mode_ (x.mode_, f, this),
  purpose_ (x.purpose_, f, this),
  sOffset_ (x.sOffset_, f, this),
  tOffset_ (x.tOffset_, f, this),
  zOffset_ (x.zOffset_, f, this),
  zScale_ (x.zScale_, f, this),
  hOffset_ (x.hOffset_, f, this)
{
}

CRG::
CRG (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  file_ (this),
  sStart_ (this),
  sEnd_ (this),
  orientation_ (this),
  mode_ (this),
  purpose_ (this),
  sOffset_ (this),
  tOffset_ (this),
  zOffset_ (this),
  zScale_ (this),
  hOffset_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void CRG::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      this->file_.set (file_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sStart" && n.namespace_ ().empty ())
    {
      this->sStart_.set (sStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sEnd" && n.namespace_ ().empty ())
    {
      this->sEnd_.set (sEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mode" && n.namespace_ ().empty ())
    {
      this->mode_.set (mode_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "purpose" && n.namespace_ ().empty ())
    {
      this->purpose_.set (purpose_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zScale" && n.namespace_ ().empty ())
    {
      this->zScale_.set (zScale_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hOffset" && n.namespace_ ().empty ())
    {
      this->hOffset_.set (hOffset_traits::create (i, f, this));
      continue;
    }
  }
}

CRG* CRG::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CRG (*this, f, c);
}

CRG& CRG::
operator= (const CRG& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->file_ = x.file_;
    this->sStart_ = x.sStart_;
    this->sEnd_ = x.sEnd_;
    this->orientation_ = x.orientation_;
    this->mode_ = x.mode_;
    this->purpose_ = x.purpose_;
    this->sOffset_ = x.sOffset_;
    this->tOffset_ = x.tOffset_;
    this->zOffset_ = x.zOffset_;
    this->zScale_ = x.zScale_;
    this->hOffset_ = x.hOffset_;
  }

  return *this;
}

CRG::
~CRG ()
{
}

// switch_
//

switch_::
switch_ (const mainTrack_type& mainTrack,
         const sideTrack_type& sideTrack)
: ::xml_schema::type (),
  mainTrack_ (mainTrack, this),
  sideTrack_ (sideTrack, this),
  partner_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this),
  position_ (this)
{
}

switch_::
switch_ (::std::auto_ptr< mainTrack_type > mainTrack,
         ::std::auto_ptr< sideTrack_type > sideTrack)
: ::xml_schema::type (),
  mainTrack_ (mainTrack, this),
  sideTrack_ (sideTrack, this),
  partner_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this),
  position_ (this)
{
}

switch_::
switch_ (const switch_& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  mainTrack_ (x.mainTrack_, f, this),
  sideTrack_ (x.sideTrack_, f, this),
  partner_ (x.partner_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  position_ (x.position_, f, this)
{
}

switch_::
switch_ (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  mainTrack_ (this),
  sideTrack_ (this),
  partner_ (this),
  userData_ (this),
  include_ (this),
  name_ (this),
  id_ (this),
  position_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void switch_::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // mainTrack
    //
    if (n.name () == "mainTrack" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mainTrack_type > r (
        mainTrack_traits::create (i, f, this));

      if (!mainTrack_.present ())
      {
        this->mainTrack_.set (r);
        continue;
      }
    }

    // sideTrack
    //
    if (n.name () == "sideTrack" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sideTrack_type > r (
        sideTrack_traits::create (i, f, this));

      if (!sideTrack_.present ())
      {
        this->sideTrack_.set (r);
        continue;
      }
    }

    // partner
    //
    if (n.name () == "partner" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< partner_type > r (
        partner_traits::create (i, f, this));

      if (!this->partner_)
      {
        this->partner_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  if (!mainTrack_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mainTrack",
      "");
  }

  if (!sideTrack_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sideTrack",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      this->position_.set (position_traits::create (i, f, this));
      continue;
    }
  }
}

switch_* switch_::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class switch_ (*this, f, c);
}

switch_& switch_::
operator= (const switch_& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->mainTrack_ = x.mainTrack_;
    this->sideTrack_ = x.sideTrack_;
    this->partner_ = x.partner_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->position_ = x.position_;
  }

  return *this;
}

switch_::
~switch_ ()
{
}

// laneLink
//

laneLink::
laneLink ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  from_ (this),
  to_ (this)
{
}

laneLink::
laneLink (const laneLink& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  from_ (x.from_, f, this),
  to_ (x.to_, f, this)
{
}

laneLink::
laneLink (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  from_ (this),
  to_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void laneLink::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "from" && n.namespace_ ().empty ())
    {
      this->from_.set (from_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "to" && n.namespace_ ().empty ())
    {
      this->to_.set (to_traits::create (i, f, this));
      continue;
    }
  }
}

laneLink* laneLink::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneLink (*this, f, c);
}

laneLink& laneLink::
operator= (const laneLink& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->from_ = x.from_;
    this->to_ = x.to_;
  }

  return *this;
}

laneLink::
~laneLink ()
{
}

// segment
//

segment::
segment ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  roadId_ (this),
  sStart_ (this),
  sEnd_ (this),
  side_ (this)
{
}

segment::
segment (const segment& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  roadId_ (x.roadId_, f, this),
  sStart_ (x.sStart_, f, this),
  sEnd_ (x.sEnd_, f, this),
  side_ (x.side_, f, this)
{
}

segment::
segment (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  roadId_ (this),
  sStart_ (this),
  sEnd_ (this),
  side_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void segment::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "roadId" && n.namespace_ ().empty ())
    {
      this->roadId_.set (roadId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sStart" && n.namespace_ ().empty ())
    {
      this->sStart_.set (sStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sEnd" && n.namespace_ ().empty ())
    {
      this->sEnd_.set (sEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }
  }
}

segment* segment::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class segment (*this, f, c);
}

segment& segment::
operator= (const segment& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->roadId_ = x.roadId_;
    this->sStart_ = x.sStart_;
    this->sEnd_ = x.sEnd_;
    this->side_ = x.side_;
  }

  return *this;
}

segment::
~segment ()
{
}

// line1
//

line1::
line1 ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this)
{
}

line1::
line1 (const line1& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

line1::
line1 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void line1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

line1* line1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class line1 (*this, f, c);
}

line1& line1::
operator= (const line1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

line1::
~line1 ()
{
}

// spiral
//

spiral::
spiral ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  curvStart_ (this),
  curvEnd_ (this)
{
}

spiral::
spiral (const spiral& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  curvStart_ (x.curvStart_, f, this),
  curvEnd_ (x.curvEnd_, f, this)
{
}

spiral::
spiral (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  curvStart_ (this),
  curvEnd_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void spiral::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "curvStart" && n.namespace_ ().empty ())
    {
      this->curvStart_.set (curvStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "curvEnd" && n.namespace_ ().empty ())
    {
      this->curvEnd_.set (curvEnd_traits::create (i, f, this));
      continue;
    }
  }
}

spiral* spiral::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spiral (*this, f, c);
}

spiral& spiral::
operator= (const spiral& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->curvStart_ = x.curvStart_;
    this->curvEnd_ = x.curvEnd_;
  }

  return *this;
}

spiral::
~spiral ()
{
}

// arc
//

arc::
arc ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  curvature_ (this)
{
}

arc::
arc (const arc& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  curvature_ (x.curvature_, f, this)
{
}

arc::
arc (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  curvature_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void arc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "curvature" && n.namespace_ ().empty ())
    {
      this->curvature_.set (curvature_traits::create (i, f, this));
      continue;
    }
  }
}

arc* arc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class arc (*this, f, c);
}

arc& arc::
operator= (const arc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->curvature_ = x.curvature_;
  }

  return *this;
}

arc::
~arc ()
{
}

// poly3
//

poly3::
poly3 ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
}

poly3::
poly3 (const poly3& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

poly3::
poly3 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void poly3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }
}

poly3* poly3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class poly3 (*this, f, c);
}

poly3& poly3::
operator= (const poly3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

poly3::
~poly3 ()
{
}

// paramPoly3
//

paramPoly3::
paramPoly3 ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  aU_ (this),
  bU_ (this),
  cU_ (this),
  dU_ (this),
  aV_ (this),
  bV_ (this),
  cV_ (this),
  dV_ (this),
  pRange_ (this)
{
}

paramPoly3::
paramPoly3 (const paramPoly3& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  aU_ (x.aU_, f, this),
  bU_ (x.bU_, f, this),
  cU_ (x.cU_, f, this),
  dU_ (x.dU_, f, this),
  aV_ (x.aV_, f, this),
  bV_ (x.bV_, f, this),
  cV_ (x.cV_, f, this),
  dV_ (x.dV_, f, this),
  pRange_ (x.pRange_, f, this)
{
}

paramPoly3::
paramPoly3 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  aU_ (this),
  bU_ (this),
  cU_ (this),
  dU_ (this),
  aV_ (this),
  bV_ (this),
  cV_ (this),
  dV_ (this),
  pRange_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void paramPoly3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "aU" && n.namespace_ ().empty ())
    {
      this->aU_.set (aU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bU" && n.namespace_ ().empty ())
    {
      this->bU_.set (bU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cU" && n.namespace_ ().empty ())
    {
      this->cU_.set (cU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dU" && n.namespace_ ().empty ())
    {
      this->dU_.set (dU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "aV" && n.namespace_ ().empty ())
    {
      this->aV_.set (aV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bV" && n.namespace_ ().empty ())
    {
      this->bV_.set (bV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cV" && n.namespace_ ().empty ())
    {
      this->cV_.set (cV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dV" && n.namespace_ ().empty ())
    {
      this->dV_.set (dV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pRange" && n.namespace_ ().empty ())
    {
      this->pRange_.set (pRange_traits::create (i, f, this));
      continue;
    }
  }
}

paramPoly3* paramPoly3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramPoly3 (*this, f, c);
}

paramPoly3& paramPoly3::
operator= (const paramPoly3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->aU_ = x.aU_;
    this->bU_ = x.bU_;
    this->cU_ = x.cU_;
    this->dU_ = x.dU_;
    this->aV_ = x.aV_;
    this->bV_ = x.bV_;
    this->cV_ = x.cV_;
    this->dV_ = x.dV_;
    this->pRange_ = x.pRange_;
  }

  return *this;
}

paramPoly3::
~paramPoly3 ()
{
}

// left
//

left::
left ()
: ::xml_schema::type (),
  lane_ (this),
  userData_ (this),
  include_ (this)
{
}

left::
left (const left& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

left::
left (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void left::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

left* left::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class left (*this, f, c);
}

left& left::
operator= (const left& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

left::
~left ()
{
}

// center
//

center::
center ()
: ::xml_schema::type (),
  lane_ (this),
  userData_ (this),
  include_ (this)
{
}

center::
center (const center& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

center::
center (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void center::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      if (!this->lane_)
      {
        this->lane_.set (r);
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

center* center::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class center (*this, f, c);
}

center& center::
operator= (const center& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

center::
~center ()
{
}

// right
//

right::
right ()
: ::xml_schema::type (),
  lane_ (this),
  userData_ (this),
  include_ (this)
{
}

right::
right (const right& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

right::
right (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void right::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

right* right::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class right (*this, f, c);
}

right& right::
operator= (const right& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

right::
~right ()
{
}

// repeat
//

repeat::
repeat ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  s_ (this),
  length_ (this),
  distance_ (this),
  tStart_ (this),
  tEnd_ (this),
  widthStart_ (this),
  widthEnd_ (this),
  heightStart_ (this),
  heightEnd_ (this),
  zOffsetStart_ (this),
  zOffsetEnd_ (this)
{
}

repeat::
repeat (const repeat& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  distance_ (x.distance_, f, this),
  tStart_ (x.tStart_, f, this),
  tEnd_ (x.tEnd_, f, this),
  widthStart_ (x.widthStart_, f, this),
  widthEnd_ (x.widthEnd_, f, this),
  heightStart_ (x.heightStart_, f, this),
  heightEnd_ (x.heightEnd_, f, this),
  zOffsetStart_ (x.zOffsetStart_, f, this),
  zOffsetEnd_ (x.zOffsetEnd_, f, this)
{
}

repeat::
repeat (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  s_ (this),
  length_ (this),
  distance_ (this),
  tStart_ (this),
  tEnd_ (this),
  widthStart_ (this),
  widthEnd_ (this),
  heightStart_ (this),
  heightEnd_ (this),
  zOffsetStart_ (this),
  zOffsetEnd_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void repeat::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      this->distance_.set (distance_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tStart" && n.namespace_ ().empty ())
    {
      this->tStart_.set (tStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      this->tEnd_.set (tEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "widthStart" && n.namespace_ ().empty ())
    {
      this->widthStart_.set (widthStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "widthEnd" && n.namespace_ ().empty ())
    {
      this->widthEnd_.set (widthEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "heightStart" && n.namespace_ ().empty ())
    {
      this->heightStart_.set (heightStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "heightEnd" && n.namespace_ ().empty ())
    {
      this->heightEnd_.set (heightEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffsetStart" && n.namespace_ ().empty ())
    {
      this->zOffsetStart_.set (zOffsetStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffsetEnd" && n.namespace_ ().empty ())
    {
      this->zOffsetEnd_.set (zOffsetEnd_traits::create (i, f, this));
      continue;
    }
  }
}

repeat* repeat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class repeat (*this, f, c);
}

repeat& repeat::
operator= (const repeat& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->distance_ = x.distance_;
    this->tStart_ = x.tStart_;
    this->tEnd_ = x.tEnd_;
    this->widthStart_ = x.widthStart_;
    this->widthEnd_ = x.widthEnd_;
    this->heightStart_ = x.heightStart_;
    this->heightEnd_ = x.heightEnd_;
    this->zOffsetStart_ = x.zOffsetStart_;
    this->zOffsetEnd_ = x.zOffsetEnd_;
  }

  return *this;
}

repeat::
~repeat ()
{
}

// outline
//

outline::
outline ()
: ::xml_schema::type (),
  cornerRoad_ (this),
  cornerLocal_ (this),
  userData_ (this),
  include_ (this)
{
}

outline::
outline (const outline& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cornerRoad_ (x.cornerRoad_, f, this),
  cornerLocal_ (x.cornerLocal_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this)
{
}

outline::
outline (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cornerRoad_ (this),
  cornerLocal_ (this),
  userData_ (this),
  include_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void outline::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cornerRoad
    //
    if (n.name () == "cornerRoad" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cornerRoad_type > r (
        cornerRoad_traits::create (i, f, this));

      this->cornerRoad_.push_back (r);
      continue;
    }

    // cornerLocal
    //
    if (n.name () == "cornerLocal" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cornerLocal_type > r (
        cornerLocal_traits::create (i, f, this));

      this->cornerLocal_.push_back (r);
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }
}

outline* outline::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class outline (*this, f, c);
}

outline& outline::
operator= (const outline& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cornerRoad_ = x.cornerRoad_;
    this->cornerLocal_ = x.cornerLocal_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
  }

  return *this;
}

outline::
~outline ()
{
}

// material1
//

material1::
material1 ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
}

material1::
material1 (const material1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  surface_ (x.surface_, f, this),
  friction_ (x.friction_, f, this),
  roughness_ (x.roughness_, f, this)
{
}

material1::
material1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void material1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      this->surface_.set (surface_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "friction" && n.namespace_ ().empty ())
    {
      this->friction_.set (friction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roughness" && n.namespace_ ().empty ())
    {
      this->roughness_.set (roughness_traits::create (i, f, this));
      continue;
    }
  }
}

material1* material1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class material1 (*this, f, c);
}

material1& material1::
operator= (const material1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->surface_ = x.surface_;
    this->friction_ = x.friction_;
    this->roughness_ = x.roughness_;
  }

  return *this;
}

material1::
~material1 ()
{
}

// dependency
//

dependency::
dependency ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this)
{
}

dependency::
dependency (const dependency& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

dependency::
dependency (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void dependency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

dependency* dependency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dependency (*this, f, c);
}

dependency& dependency::
operator= (const dependency& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

dependency::
~dependency ()
{
}

// mainTrack
//

mainTrack::
mainTrack ()
: ::xml_schema::type (),
  id_ (this),
  s_ (this),
  dir_ (this)
{
}

mainTrack::
mainTrack (const mainTrack& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  s_ (x.s_, f, this),
  dir_ (x.dir_, f, this)
{
}

mainTrack::
mainTrack (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  s_ (this),
  dir_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void mainTrack::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dir" && n.namespace_ ().empty ())
    {
      this->dir_.set (dir_traits::create (i, f, this));
      continue;
    }
  }
}

mainTrack* mainTrack::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mainTrack (*this, f, c);
}

mainTrack& mainTrack::
operator= (const mainTrack& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->s_ = x.s_;
    this->dir_ = x.dir_;
  }

  return *this;
}

mainTrack::
~mainTrack ()
{
}

// sideTrack
//

sideTrack::
sideTrack ()
: ::xml_schema::type (),
  id_ (this),
  s_ (this),
  dir_ (this)
{
}

sideTrack::
sideTrack (const sideTrack& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  s_ (x.s_, f, this),
  dir_ (x.dir_, f, this)
{
}

sideTrack::
sideTrack (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  s_ (this),
  dir_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void sideTrack::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dir" && n.namespace_ ().empty ())
    {
      this->dir_.set (dir_traits::create (i, f, this));
      continue;
    }
  }
}

sideTrack* sideTrack::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sideTrack (*this, f, c);
}

sideTrack& sideTrack::
operator= (const sideTrack& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->s_ = x.s_;
    this->dir_ = x.dir_;
  }

  return *this;
}

sideTrack::
~sideTrack ()
{
}

// partner
//

partner::
partner ()
: ::xml_schema::type (),
  name_ (this),
  id_ (this)
{
}

partner::
partner (const partner& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this)
{
}

partner::
partner (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void partner::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

partner* partner::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class partner (*this, f, c);
}

partner& partner::
operator= (const partner& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->id_ = x.id_;
  }

  return *this;
}

partner::
~partner ()
{
}

// cornerRoad
//

cornerRoad::
cornerRoad ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  dz_ (this),
  height_ (this)
{
}

cornerRoad::
cornerRoad (const cornerRoad& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  dz_ (x.dz_, f, this),
  height_ (x.height_, f, this)
{
}

cornerRoad::
cornerRoad (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  s_ (this),
  t_ (this),
  dz_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void cornerRoad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dz" && n.namespace_ ().empty ())
    {
      this->dz_.set (dz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }
  }
}

cornerRoad* cornerRoad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cornerRoad (*this, f, c);
}

cornerRoad& cornerRoad::
operator= (const cornerRoad& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->dz_ = x.dz_;
    this->height_ = x.height_;
  }

  return *this;
}

cornerRoad::
~cornerRoad ()
{
}

// cornerLocal
//

cornerLocal::
cornerLocal ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  u_ (this),
  v_ (this),
  z_ (this),
  height_ (this)
{
}

cornerLocal::
cornerLocal (const cornerLocal& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  u_ (x.u_, f, this),
  v_ (x.v_, f, this),
  z_ (x.z_, f, this),
  height_ (x.height_, f, this)
{
}

cornerLocal::
cornerLocal (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  u_ (this),
  v_ (this),
  z_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void cornerLocal::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (r);
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "u" && n.namespace_ ().empty ())
    {
      this->u_.set (u_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v" && n.namespace_ ().empty ())
    {
      this->v_.set (v_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }
  }
}

cornerLocal* cornerLocal::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cornerLocal (*this, f, c);
}

cornerLocal& cornerLocal::
operator= (const cornerLocal& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->u_ = x.u_;
    this->v_ = x.v_;
    this->z_ = x.z_;
    this->height_ = x.height_;
  }

  return *this;
}

cornerLocal::
~cornerLocal ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::OpenDRIVE > (
      ::OpenDRIVE_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

::std::auto_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

