// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "OpenDRIVE_1.5M.h"

// t_grEqZero
// 


// t_grZero
// 


// t_zeroOne
// 


// t_bool
// 

t_bool::
t_bool (value v)
: ::xml_schema::string (_xsd_t_bool_literals_[v])
{
}

t_bool::
t_bool (const char* v)
: ::xml_schema::string (v)
{
}

t_bool::
t_bool (const ::std::string& v)
: ::xml_schema::string (v)
{
}

t_bool::
t_bool (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

t_bool::
t_bool (const t_bool& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

t_bool& t_bool::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_t_bool_literals_[v]);

  return *this;
}


// t_yesNo
// 

t_yesNo::
t_yesNo (value v)
: ::xml_schema::string (_xsd_t_yesNo_literals_[v])
{
}

t_yesNo::
t_yesNo (const char* v)
: ::xml_schema::string (v)
{
}

t_yesNo::
t_yesNo (const ::std::string& v)
: ::xml_schema::string (v)
{
}

t_yesNo::
t_yesNo (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

t_yesNo::
t_yesNo (const t_yesNo& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

t_yesNo& t_yesNo::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_t_yesNo_literals_[v]);

  return *this;
}


// t_header_Version
// 


// t_maxSpeed
//

t_maxSpeed::
t_maxSpeed (const char* s)
: ::xml_schema::string (s)
{
}

t_maxSpeed::
t_maxSpeed (const ::std::string& s)
: ::xml_schema::string (s)
{
}

t_maxSpeed::
t_maxSpeed (const t_maxSpeed& o,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (o, f, c)
{
}

// e_maxSpeedString
// 

e_maxSpeedString::
e_maxSpeedString (value v)
: ::xml_schema::string (_xsd_e_maxSpeedString_literals_[v])
{
}

e_maxSpeedString::
e_maxSpeedString (const char* v)
: ::xml_schema::string (v)
{
}

e_maxSpeedString::
e_maxSpeedString (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_maxSpeedString::
e_maxSpeedString (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_maxSpeedString::
e_maxSpeedString (const e_maxSpeedString& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_maxSpeedString& e_maxSpeedString::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_maxSpeedString_literals_[v]);

  return *this;
}


// t_junction_id
// 


// t_header
// 

const t_header::geoReference_optional& t_header::
geoReference () const
{
  return this->geoReference_;
}

t_header::geoReference_optional& t_header::
geoReference ()
{
  return this->geoReference_;
}

void t_header::
geoReference (const geoReference_type& x)
{
  this->geoReference_.set (x);
}

void t_header::
geoReference (const geoReference_optional& x)
{
  this->geoReference_ = x;
}

void t_header::
geoReference (::std::unique_ptr< geoReference_type > x)
{
  this->geoReference_.set (std::move (x));
}

const t_header::offset_optional& t_header::
offset () const
{
  return this->offset_;
}

t_header::offset_optional& t_header::
offset ()
{
  return this->offset_;
}

void t_header::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

void t_header::
offset (const offset_optional& x)
{
  this->offset_ = x;
}

void t_header::
offset (::std::unique_ptr< offset_type > x)
{
  this->offset_.set (std::move (x));
}

const t_header::userData_sequence& t_header::
userData () const
{
  return this->userData_;
}

t_header::userData_sequence& t_header::
userData ()
{
  return this->userData_;
}

void t_header::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_header::include_sequence& t_header::
include () const
{
  return this->include_;
}

t_header::include_sequence& t_header::
include ()
{
  return this->include_;
}

void t_header::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_header::dataQuality_optional& t_header::
dataQuality () const
{
  return this->dataQuality_;
}

t_header::dataQuality_optional& t_header::
dataQuality ()
{
  return this->dataQuality_;
}

void t_header::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_header::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_header::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_header::revMajor_type& t_header::
revMajor () const
{
  return this->revMajor_.get ();
}

t_header::revMajor_type t_header::
revMajor_default_value ()
{
  return revMajor_type (1LL);
}

const t_header::revMinor_type& t_header::
revMinor () const
{
  return this->revMinor_.get ();
}

t_header::revMinor_type t_header::
revMinor_default_value ()
{
  return revMinor_type (5LL);
}

const t_header::name_optional& t_header::
name () const
{
  return this->name_;
}

t_header::name_optional& t_header::
name ()
{
  return this->name_;
}

void t_header::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_header::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_header::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_header::version_optional& t_header::
version () const
{
  return this->version_;
}

t_header::version_optional& t_header::
version ()
{
  return this->version_;
}

void t_header::
version (const version_type& x)
{
  this->version_.set (x);
}

void t_header::
version (const version_optional& x)
{
  this->version_ = x;
}

void t_header::
version (::std::unique_ptr< version_type > x)
{
  this->version_.set (std::move (x));
}

const t_header::date_optional& t_header::
date () const
{
  return this->date_;
}

t_header::date_optional& t_header::
date ()
{
  return this->date_;
}

void t_header::
date (const date_type& x)
{
  this->date_.set (x);
}

void t_header::
date (const date_optional& x)
{
  this->date_ = x;
}

void t_header::
date (::std::unique_ptr< date_type > x)
{
  this->date_.set (std::move (x));
}

const t_header::north_optional& t_header::
north () const
{
  return this->north_;
}

t_header::north_optional& t_header::
north ()
{
  return this->north_;
}

void t_header::
north (const north_type& x)
{
  this->north_.set (x);
}

void t_header::
north (const north_optional& x)
{
  this->north_ = x;
}

const t_header::south_optional& t_header::
south () const
{
  return this->south_;
}

t_header::south_optional& t_header::
south ()
{
  return this->south_;
}

void t_header::
south (const south_type& x)
{
  this->south_.set (x);
}

void t_header::
south (const south_optional& x)
{
  this->south_ = x;
}

const t_header::east_optional& t_header::
east () const
{
  return this->east_;
}

t_header::east_optional& t_header::
east ()
{
  return this->east_;
}

void t_header::
east (const east_type& x)
{
  this->east_.set (x);
}

void t_header::
east (const east_optional& x)
{
  this->east_ = x;
}

const t_header::west_optional& t_header::
west () const
{
  return this->west_;
}

t_header::west_optional& t_header::
west ()
{
  return this->west_;
}

void t_header::
west (const west_type& x)
{
  this->west_.set (x);
}

void t_header::
west (const west_optional& x)
{
  this->west_ = x;
}

const t_header::vendor_optional& t_header::
vendor () const
{
  return this->vendor_;
}

t_header::vendor_optional& t_header::
vendor ()
{
  return this->vendor_;
}

void t_header::
vendor (const vendor_type& x)
{
  this->vendor_.set (x);
}

void t_header::
vendor (const vendor_optional& x)
{
  this->vendor_ = x;
}

void t_header::
vendor (::std::unique_ptr< vendor_type > x)
{
  this->vendor_.set (std::move (x));
}


// t_header_GeoReference
// 

const t_header_GeoReference::userData_sequence& t_header_GeoReference::
userData () const
{
  return this->userData_;
}

t_header_GeoReference::userData_sequence& t_header_GeoReference::
userData ()
{
  return this->userData_;
}

void t_header_GeoReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_header_GeoReference::include_sequence& t_header_GeoReference::
include () const
{
  return this->include_;
}

t_header_GeoReference::include_sequence& t_header_GeoReference::
include ()
{
  return this->include_;
}

void t_header_GeoReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_header_GeoReference::dataQuality_optional& t_header_GeoReference::
dataQuality () const
{
  return this->dataQuality_;
}

t_header_GeoReference::dataQuality_optional& t_header_GeoReference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_header_GeoReference::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_header_GeoReference::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_header_GeoReference::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_header_Offset
// 

const t_header_Offset::userData_sequence& t_header_Offset::
userData () const
{
  return this->userData_;
}

t_header_Offset::userData_sequence& t_header_Offset::
userData ()
{
  return this->userData_;
}

void t_header_Offset::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_header_Offset::include_sequence& t_header_Offset::
include () const
{
  return this->include_;
}

t_header_Offset::include_sequence& t_header_Offset::
include ()
{
  return this->include_;
}

void t_header_Offset::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_header_Offset::dataQuality_optional& t_header_Offset::
dataQuality () const
{
  return this->dataQuality_;
}

t_header_Offset::dataQuality_optional& t_header_Offset::
dataQuality ()
{
  return this->dataQuality_;
}

void t_header_Offset::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_header_Offset::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_header_Offset::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_header_Offset::x_type& t_header_Offset::
x () const
{
  return this->x_.get ();
}

t_header_Offset::x_type& t_header_Offset::
x ()
{
  return this->x_.get ();
}

void t_header_Offset::
x (const x_type& x)
{
  this->x_.set (x);
}

const t_header_Offset::y_type& t_header_Offset::
y () const
{
  return this->y_.get ();
}

t_header_Offset::y_type& t_header_Offset::
y ()
{
  return this->y_.get ();
}

void t_header_Offset::
y (const y_type& x)
{
  this->y_.set (x);
}

const t_header_Offset::z_type& t_header_Offset::
z () const
{
  return this->z_.get ();
}

t_header_Offset::z_type& t_header_Offset::
z ()
{
  return this->z_.get ();
}

void t_header_Offset::
z (const z_type& x)
{
  this->z_.set (x);
}

const t_header_Offset::hdg_type& t_header_Offset::
hdg () const
{
  return this->hdg_.get ();
}

t_header_Offset::hdg_type& t_header_Offset::
hdg ()
{
  return this->hdg_.get ();
}

void t_header_Offset::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}


// t_road
// 

const t_road::link_optional& t_road::
link () const
{
  return this->link_;
}

t_road::link_optional& t_road::
link ()
{
  return this->link_;
}

void t_road::
link (const link_type& x)
{
  this->link_.set (x);
}

void t_road::
link (const link_optional& x)
{
  this->link_ = x;
}

void t_road::
link (::std::unique_ptr< link_type > x)
{
  this->link_.set (std::move (x));
}

const t_road::type_sequence& t_road::
type () const
{
  return this->type_;
}

t_road::type_sequence& t_road::
type ()
{
  return this->type_;
}

void t_road::
type (const type_sequence& s)
{
  this->type_ = s;
}

const t_road::planView_type& t_road::
planView () const
{
  return this->planView_.get ();
}

t_road::planView_type& t_road::
planView ()
{
  return this->planView_.get ();
}

void t_road::
planView (const planView_type& x)
{
  this->planView_.set (x);
}

void t_road::
planView (::std::unique_ptr< planView_type > x)
{
  this->planView_.set (std::move (x));
}

const t_road::elevationProfile_optional& t_road::
elevationProfile () const
{
  return this->elevationProfile_;
}

t_road::elevationProfile_optional& t_road::
elevationProfile ()
{
  return this->elevationProfile_;
}

void t_road::
elevationProfile (const elevationProfile_type& x)
{
  this->elevationProfile_.set (x);
}

void t_road::
elevationProfile (const elevationProfile_optional& x)
{
  this->elevationProfile_ = x;
}

void t_road::
elevationProfile (::std::unique_ptr< elevationProfile_type > x)
{
  this->elevationProfile_.set (std::move (x));
}

const t_road::lateralProfile_optional& t_road::
lateralProfile () const
{
  return this->lateralProfile_;
}

t_road::lateralProfile_optional& t_road::
lateralProfile ()
{
  return this->lateralProfile_;
}

void t_road::
lateralProfile (const lateralProfile_type& x)
{
  this->lateralProfile_.set (x);
}

void t_road::
lateralProfile (const lateralProfile_optional& x)
{
  this->lateralProfile_ = x;
}

void t_road::
lateralProfile (::std::unique_ptr< lateralProfile_type > x)
{
  this->lateralProfile_.set (std::move (x));
}

const t_road::lanes_type& t_road::
lanes () const
{
  return this->lanes_.get ();
}

t_road::lanes_type& t_road::
lanes ()
{
  return this->lanes_.get ();
}

void t_road::
lanes (const lanes_type& x)
{
  this->lanes_.set (x);
}

void t_road::
lanes (::std::unique_ptr< lanes_type > x)
{
  this->lanes_.set (std::move (x));
}

const t_road::objects_optional& t_road::
objects () const
{
  return this->objects_;
}

t_road::objects_optional& t_road::
objects ()
{
  return this->objects_;
}

void t_road::
objects (const objects_type& x)
{
  this->objects_.set (x);
}

void t_road::
objects (const objects_optional& x)
{
  this->objects_ = x;
}

void t_road::
objects (::std::unique_ptr< objects_type > x)
{
  this->objects_.set (std::move (x));
}

const t_road::signals_optional& t_road::
signals () const
{
  return this->signals_;
}

t_road::signals_optional& t_road::
signals ()
{
  return this->signals_;
}

void t_road::
signals (const signals_type& x)
{
  this->signals_.set (x);
}

void t_road::
signals (const signals_optional& x)
{
  this->signals_ = x;
}

void t_road::
signals (::std::unique_ptr< signals_type > x)
{
  this->signals_.set (std::move (x));
}

const t_road::surface_optional& t_road::
surface () const
{
  return this->surface_;
}

t_road::surface_optional& t_road::
surface ()
{
  return this->surface_;
}

void t_road::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void t_road::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void t_road::
surface (::std::unique_ptr< surface_type > x)
{
  this->surface_.set (std::move (x));
}

const t_road::railroad_optional& t_road::
railroad () const
{
  return this->railroad_;
}

t_road::railroad_optional& t_road::
railroad ()
{
  return this->railroad_;
}

void t_road::
railroad (const railroad_type& x)
{
  this->railroad_.set (x);
}

void t_road::
railroad (const railroad_optional& x)
{
  this->railroad_ = x;
}

void t_road::
railroad (::std::unique_ptr< railroad_type > x)
{
  this->railroad_.set (std::move (x));
}

const t_road::userData_sequence& t_road::
userData () const
{
  return this->userData_;
}

t_road::userData_sequence& t_road::
userData ()
{
  return this->userData_;
}

void t_road::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road::include_sequence& t_road::
include () const
{
  return this->include_;
}

t_road::include_sequence& t_road::
include ()
{
  return this->include_;
}

void t_road::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road::dataQuality_optional& t_road::
dataQuality () const
{
  return this->dataQuality_;
}

t_road::dataQuality_optional& t_road::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road::name_optional& t_road::
name () const
{
  return this->name_;
}

t_road::name_optional& t_road::
name ()
{
  return this->name_;
}

void t_road::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road::length_type& t_road::
length () const
{
  return this->length_.get ();
}

t_road::length_type& t_road::
length ()
{
  return this->length_.get ();
}

void t_road::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road::
length (::std::unique_ptr< length_type > x)
{
  this->length_.set (std::move (x));
}

const t_road::id_type& t_road::
id () const
{
  return this->id_.get ();
}

t_road::id_type& t_road::
id ()
{
  return this->id_.get ();
}

void t_road::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road::junction_type& t_road::
junction () const
{
  return this->junction_.get ();
}

t_road::junction_type& t_road::
junction ()
{
  return this->junction_.get ();
}

void t_road::
junction (const junction_type& x)
{
  this->junction_.set (x);
}

void t_road::
junction (::std::unique_ptr< junction_type > x)
{
  this->junction_.set (std::move (x));
}

const t_road::rule_optional& t_road::
rule () const
{
  return this->rule_;
}

t_road::rule_optional& t_road::
rule ()
{
  return this->rule_;
}

void t_road::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void t_road::
rule (::std::unique_ptr< rule_type > x)
{
  this->rule_.set (std::move (x));
}


// e_trafficRule
// 

e_trafficRule::
e_trafficRule (value v)
: ::xml_schema::string (_xsd_e_trafficRule_literals_[v])
{
}

e_trafficRule::
e_trafficRule (const char* v)
: ::xml_schema::string (v)
{
}

e_trafficRule::
e_trafficRule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_trafficRule::
e_trafficRule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_trafficRule::
e_trafficRule (const e_trafficRule& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_trafficRule& e_trafficRule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_trafficRule_literals_[v]);

  return *this;
}


// t_road_link
// 

const t_road_link::predecessor_optional& t_road_link::
predecessor () const
{
  return this->predecessor_;
}

t_road_link::predecessor_optional& t_road_link::
predecessor ()
{
  return this->predecessor_;
}

void t_road_link::
predecessor (const predecessor_type& x)
{
  this->predecessor_.set (x);
}

void t_road_link::
predecessor (const predecessor_optional& x)
{
  this->predecessor_ = x;
}

void t_road_link::
predecessor (::std::unique_ptr< predecessor_type > x)
{
  this->predecessor_.set (std::move (x));
}

const t_road_link::successor_optional& t_road_link::
successor () const
{
  return this->successor_;
}

t_road_link::successor_optional& t_road_link::
successor ()
{
  return this->successor_;
}

void t_road_link::
successor (const successor_type& x)
{
  this->successor_.set (x);
}

void t_road_link::
successor (const successor_optional& x)
{
  this->successor_ = x;
}

void t_road_link::
successor (::std::unique_ptr< successor_type > x)
{
  this->successor_.set (std::move (x));
}

const t_road_link::neighbor_sequence& t_road_link::
neighbor () const
{
  return this->neighbor_;
}

t_road_link::neighbor_sequence& t_road_link::
neighbor ()
{
  return this->neighbor_;
}

void t_road_link::
neighbor (const neighbor_sequence& s)
{
  this->neighbor_ = s;
}

const t_road_link::userData_sequence& t_road_link::
userData () const
{
  return this->userData_;
}

t_road_link::userData_sequence& t_road_link::
userData ()
{
  return this->userData_;
}

void t_road_link::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_link::include_sequence& t_road_link::
include () const
{
  return this->include_;
}

t_road_link::include_sequence& t_road_link::
include ()
{
  return this->include_;
}

void t_road_link::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_link::dataQuality_optional& t_road_link::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_link::dataQuality_optional& t_road_link::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_link::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_link::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_link::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_link_predecessorSuccessor
// 

const t_road_link_predecessorSuccessor::userData_sequence& t_road_link_predecessorSuccessor::
userData () const
{
  return this->userData_;
}

t_road_link_predecessorSuccessor::userData_sequence& t_road_link_predecessorSuccessor::
userData ()
{
  return this->userData_;
}

void t_road_link_predecessorSuccessor::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_link_predecessorSuccessor::include_sequence& t_road_link_predecessorSuccessor::
include () const
{
  return this->include_;
}

t_road_link_predecessorSuccessor::include_sequence& t_road_link_predecessorSuccessor::
include ()
{
  return this->include_;
}

void t_road_link_predecessorSuccessor::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_link_predecessorSuccessor::dataQuality_optional& t_road_link_predecessorSuccessor::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_link_predecessorSuccessor::dataQuality_optional& t_road_link_predecessorSuccessor::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_link_predecessorSuccessor::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_link_predecessorSuccessor::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_link_predecessorSuccessor::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_link_predecessorSuccessor::elementType_type& t_road_link_predecessorSuccessor::
elementType () const
{
  return this->elementType_.get ();
}

t_road_link_predecessorSuccessor::elementType_type& t_road_link_predecessorSuccessor::
elementType ()
{
  return this->elementType_.get ();
}

void t_road_link_predecessorSuccessor::
elementType (const elementType_type& x)
{
  this->elementType_.set (x);
}

void t_road_link_predecessorSuccessor::
elementType (::std::unique_ptr< elementType_type > x)
{
  this->elementType_.set (std::move (x));
}

const t_road_link_predecessorSuccessor::elementId_type& t_road_link_predecessorSuccessor::
elementId () const
{
  return this->elementId_.get ();
}

t_road_link_predecessorSuccessor::elementId_type& t_road_link_predecessorSuccessor::
elementId ()
{
  return this->elementId_.get ();
}

void t_road_link_predecessorSuccessor::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void t_road_link_predecessorSuccessor::
elementId (::std::unique_ptr< elementId_type > x)
{
  this->elementId_.set (std::move (x));
}

const t_road_link_predecessorSuccessor::contactPoint_optional& t_road_link_predecessorSuccessor::
contactPoint () const
{
  return this->contactPoint_;
}

t_road_link_predecessorSuccessor::contactPoint_optional& t_road_link_predecessorSuccessor::
contactPoint ()
{
  return this->contactPoint_;
}

void t_road_link_predecessorSuccessor::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void t_road_link_predecessorSuccessor::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void t_road_link_predecessorSuccessor::
contactPoint (::std::unique_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (std::move (x));
}

const t_road_link_predecessorSuccessor::elementS_optional& t_road_link_predecessorSuccessor::
elementS () const
{
  return this->elementS_;
}

t_road_link_predecessorSuccessor::elementS_optional& t_road_link_predecessorSuccessor::
elementS ()
{
  return this->elementS_;
}

void t_road_link_predecessorSuccessor::
elementS (const elementS_type& x)
{
  this->elementS_.set (x);
}

void t_road_link_predecessorSuccessor::
elementS (const elementS_optional& x)
{
  this->elementS_ = x;
}

void t_road_link_predecessorSuccessor::
elementS (::std::unique_ptr< elementS_type > x)
{
  this->elementS_.set (std::move (x));
}

const t_road_link_predecessorSuccessor::elementDir_optional& t_road_link_predecessorSuccessor::
elementDir () const
{
  return this->elementDir_;
}

t_road_link_predecessorSuccessor::elementDir_optional& t_road_link_predecessorSuccessor::
elementDir ()
{
  return this->elementDir_;
}

void t_road_link_predecessorSuccessor::
elementDir (const elementDir_type& x)
{
  this->elementDir_.set (x);
}

void t_road_link_predecessorSuccessor::
elementDir (const elementDir_optional& x)
{
  this->elementDir_ = x;
}

void t_road_link_predecessorSuccessor::
elementDir (::std::unique_ptr< elementDir_type > x)
{
  this->elementDir_.set (std::move (x));
}


// e_road_link_elementType
// 

e_road_link_elementType::
e_road_link_elementType (value v)
: ::xml_schema::string (_xsd_e_road_link_elementType_literals_[v])
{
}

e_road_link_elementType::
e_road_link_elementType (const char* v)
: ::xml_schema::string (v)
{
}

e_road_link_elementType::
e_road_link_elementType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_link_elementType::
e_road_link_elementType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_link_elementType::
e_road_link_elementType (const e_road_link_elementType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_link_elementType& e_road_link_elementType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_link_elementType_literals_[v]);

  return *this;
}


// t_road_link_neighbor
// 

const t_road_link_neighbor::userData_sequence& t_road_link_neighbor::
userData () const
{
  return this->userData_;
}

t_road_link_neighbor::userData_sequence& t_road_link_neighbor::
userData ()
{
  return this->userData_;
}

void t_road_link_neighbor::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_link_neighbor::include_sequence& t_road_link_neighbor::
include () const
{
  return this->include_;
}

t_road_link_neighbor::include_sequence& t_road_link_neighbor::
include ()
{
  return this->include_;
}

void t_road_link_neighbor::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_link_neighbor::dataQuality_optional& t_road_link_neighbor::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_link_neighbor::dataQuality_optional& t_road_link_neighbor::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_link_neighbor::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_link_neighbor::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_link_neighbor::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_link_neighbor::side_type& t_road_link_neighbor::
side () const
{
  return this->side_.get ();
}

t_road_link_neighbor::side_type& t_road_link_neighbor::
side ()
{
  return this->side_.get ();
}

void t_road_link_neighbor::
side (const side_type& x)
{
  this->side_.set (x);
}

void t_road_link_neighbor::
side (::std::unique_ptr< side_type > x)
{
  this->side_.set (std::move (x));
}

const t_road_link_neighbor::elementId_type& t_road_link_neighbor::
elementId () const
{
  return this->elementId_.get ();
}

t_road_link_neighbor::elementId_type& t_road_link_neighbor::
elementId ()
{
  return this->elementId_.get ();
}

void t_road_link_neighbor::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void t_road_link_neighbor::
elementId (::std::unique_ptr< elementId_type > x)
{
  this->elementId_.set (std::move (x));
}

const t_road_link_neighbor::direction_type& t_road_link_neighbor::
direction () const
{
  return this->direction_.get ();
}

t_road_link_neighbor::direction_type& t_road_link_neighbor::
direction ()
{
  return this->direction_.get ();
}

void t_road_link_neighbor::
direction (const direction_type& x)
{
  this->direction_.set (x);
}

void t_road_link_neighbor::
direction (::std::unique_ptr< direction_type > x)
{
  this->direction_.set (std::move (x));
}


// e_road_link_neighbor_side
// 

e_road_link_neighbor_side::
e_road_link_neighbor_side (value v)
: ::xml_schema::string (_xsd_e_road_link_neighbor_side_literals_[v])
{
}

e_road_link_neighbor_side::
e_road_link_neighbor_side (const char* v)
: ::xml_schema::string (v)
{
}

e_road_link_neighbor_side::
e_road_link_neighbor_side (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_link_neighbor_side::
e_road_link_neighbor_side (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_link_neighbor_side::
e_road_link_neighbor_side (const e_road_link_neighbor_side& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_link_neighbor_side& e_road_link_neighbor_side::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_link_neighbor_side_literals_[v]);

  return *this;
}


// t_road_type
// 

const t_road_type::speed_optional& t_road_type::
speed () const
{
  return this->speed_;
}

t_road_type::speed_optional& t_road_type::
speed ()
{
  return this->speed_;
}

void t_road_type::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

void t_road_type::
speed (const speed_optional& x)
{
  this->speed_ = x;
}

void t_road_type::
speed (::std::unique_ptr< speed_type > x)
{
  this->speed_.set (std::move (x));
}

const t_road_type::userData_sequence& t_road_type::
userData () const
{
  return this->userData_;
}

t_road_type::userData_sequence& t_road_type::
userData ()
{
  return this->userData_;
}

void t_road_type::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_type::include_sequence& t_road_type::
include () const
{
  return this->include_;
}

t_road_type::include_sequence& t_road_type::
include ()
{
  return this->include_;
}

void t_road_type::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_type::dataQuality_optional& t_road_type::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_type::dataQuality_optional& t_road_type::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_type::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_type::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_type::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_type::s_type& t_road_type::
s () const
{
  return this->s_.get ();
}

t_road_type::s_type& t_road_type::
s ()
{
  return this->s_.get ();
}

void t_road_type::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_type::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_type::type_type& t_road_type::
type () const
{
  return this->type_.get ();
}

t_road_type::type_type& t_road_type::
type ()
{
  return this->type_.get ();
}

void t_road_type::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_type::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_type::country_optional& t_road_type::
country () const
{
  return this->country_;
}

t_road_type::country_optional& t_road_type::
country ()
{
  return this->country_;
}

void t_road_type::
country (const country_type& x)
{
  this->country_.set (x);
}

void t_road_type::
country (const country_optional& x)
{
  this->country_ = x;
}

void t_road_type::
country (::std::unique_ptr< country_type > x)
{
  this->country_.set (std::move (x));
}


// t_road_type_speed
// 

const t_road_type_speed::userData_sequence& t_road_type_speed::
userData () const
{
  return this->userData_;
}

t_road_type_speed::userData_sequence& t_road_type_speed::
userData ()
{
  return this->userData_;
}

void t_road_type_speed::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_type_speed::include_sequence& t_road_type_speed::
include () const
{
  return this->include_;
}

t_road_type_speed::include_sequence& t_road_type_speed::
include ()
{
  return this->include_;
}

void t_road_type_speed::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_type_speed::dataQuality_optional& t_road_type_speed::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_type_speed::dataQuality_optional& t_road_type_speed::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_type_speed::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_type_speed::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_type_speed::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_type_speed::max_type& t_road_type_speed::
fmax () const
{
  return this->fmax_.get ();
}

t_road_type_speed::max_type& t_road_type_speed::
fmax ()
{
  return this->fmax_.get ();
}

void t_road_type_speed::
fmax (const max_type& x)
{
  this->fmax_.set (x);
}

void t_road_type_speed::
fmax (::std::unique_ptr< max_type > x)
{
  this->fmax_.set (std::move (x));
}

const t_road_type_speed::unit_optional& t_road_type_speed::
unit () const
{
  return this->unit_;
}

t_road_type_speed::unit_optional& t_road_type_speed::
unit ()
{
  return this->unit_;
}

void t_road_type_speed::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void t_road_type_speed::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void t_road_type_speed::
unit (::std::unique_ptr< unit_type > x)
{
  this->unit_.set (std::move (x));
}


// t_road_planView
// 

const t_road_planView::geometry_sequence& t_road_planView::
geometry () const
{
  return this->geometry_;
}

t_road_planView::geometry_sequence& t_road_planView::
geometry ()
{
  return this->geometry_;
}

void t_road_planView::
geometry (const geometry_sequence& s)
{
  this->geometry_ = s;
}

const t_road_planView::userData_sequence& t_road_planView::
userData () const
{
  return this->userData_;
}

t_road_planView::userData_sequence& t_road_planView::
userData ()
{
  return this->userData_;
}

void t_road_planView::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView::include_sequence& t_road_planView::
include () const
{
  return this->include_;
}

t_road_planView::include_sequence& t_road_planView::
include ()
{
  return this->include_;
}

void t_road_planView::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView::dataQuality_optional& t_road_planView::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView::dataQuality_optional& t_road_planView::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_planView::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_planView::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_planView_geometry
// 

const t_road_planView_geometry::line_optional& t_road_planView_geometry::
line () const
{
  return this->line_;
}

t_road_planView_geometry::line_optional& t_road_planView_geometry::
line ()
{
  return this->line_;
}

void t_road_planView_geometry::
line (const line_type& x)
{
  this->line_.set (x);
}

void t_road_planView_geometry::
line (const line_optional& x)
{
  this->line_ = x;
}

void t_road_planView_geometry::
line (::std::unique_ptr< line_type > x)
{
  this->line_.set (std::move (x));
}

const t_road_planView_geometry::spiral_optional& t_road_planView_geometry::
spiral () const
{
  return this->spiral_;
}

t_road_planView_geometry::spiral_optional& t_road_planView_geometry::
spiral ()
{
  return this->spiral_;
}

void t_road_planView_geometry::
spiral (const spiral_type& x)
{
  this->spiral_.set (x);
}

void t_road_planView_geometry::
spiral (const spiral_optional& x)
{
  this->spiral_ = x;
}

void t_road_planView_geometry::
spiral (::std::unique_ptr< spiral_type > x)
{
  this->spiral_.set (std::move (x));
}

const t_road_planView_geometry::arc_optional& t_road_planView_geometry::
arc () const
{
  return this->arc_;
}

t_road_planView_geometry::arc_optional& t_road_planView_geometry::
arc ()
{
  return this->arc_;
}

void t_road_planView_geometry::
arc (const arc_type& x)
{
  this->arc_.set (x);
}

void t_road_planView_geometry::
arc (const arc_optional& x)
{
  this->arc_ = x;
}

void t_road_planView_geometry::
arc (::std::unique_ptr< arc_type > x)
{
  this->arc_.set (std::move (x));
}

const t_road_planView_geometry::poly3_optional& t_road_planView_geometry::
poly3 () const
{
  return this->poly3_;
}

t_road_planView_geometry::poly3_optional& t_road_planView_geometry::
poly3 ()
{
  return this->poly3_;
}

void t_road_planView_geometry::
poly3 (const poly3_type& x)
{
  this->poly3_.set (x);
}

void t_road_planView_geometry::
poly3 (const poly3_optional& x)
{
  this->poly3_ = x;
}

void t_road_planView_geometry::
poly3 (::std::unique_ptr< poly3_type > x)
{
  this->poly3_.set (std::move (x));
}

const t_road_planView_geometry::paramPoly3_optional& t_road_planView_geometry::
paramPoly3 () const
{
  return this->paramPoly3_;
}

t_road_planView_geometry::paramPoly3_optional& t_road_planView_geometry::
paramPoly3 ()
{
  return this->paramPoly3_;
}

void t_road_planView_geometry::
paramPoly3 (const paramPoly3_type& x)
{
  this->paramPoly3_.set (x);
}

void t_road_planView_geometry::
paramPoly3 (const paramPoly3_optional& x)
{
  this->paramPoly3_ = x;
}

void t_road_planView_geometry::
paramPoly3 (::std::unique_ptr< paramPoly3_type > x)
{
  this->paramPoly3_.set (std::move (x));
}

const t_road_planView_geometry::userData_sequence& t_road_planView_geometry::
userData () const
{
  return this->userData_;
}

t_road_planView_geometry::userData_sequence& t_road_planView_geometry::
userData ()
{
  return this->userData_;
}

void t_road_planView_geometry::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView_geometry::include_sequence& t_road_planView_geometry::
include () const
{
  return this->include_;
}

t_road_planView_geometry::include_sequence& t_road_planView_geometry::
include ()
{
  return this->include_;
}

void t_road_planView_geometry::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView_geometry::dataQuality_optional& t_road_planView_geometry::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView_geometry::dataQuality_optional& t_road_planView_geometry::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView_geometry::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_planView_geometry::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_planView_geometry::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_planView_geometry::s_type& t_road_planView_geometry::
s () const
{
  return this->s_.get ();
}

t_road_planView_geometry::s_type& t_road_planView_geometry::
s ()
{
  return this->s_.get ();
}

void t_road_planView_geometry::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_planView_geometry::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_planView_geometry::x_type& t_road_planView_geometry::
x () const
{
  return this->x_.get ();
}

t_road_planView_geometry::x_type& t_road_planView_geometry::
x ()
{
  return this->x_.get ();
}

void t_road_planView_geometry::
x (const x_type& x)
{
  this->x_.set (x);
}

const t_road_planView_geometry::y_type& t_road_planView_geometry::
y () const
{
  return this->y_.get ();
}

t_road_planView_geometry::y_type& t_road_planView_geometry::
y ()
{
  return this->y_.get ();
}

void t_road_planView_geometry::
y (const y_type& x)
{
  this->y_.set (x);
}

const t_road_planView_geometry::hdg_type& t_road_planView_geometry::
hdg () const
{
  return this->hdg_.get ();
}

t_road_planView_geometry::hdg_type& t_road_planView_geometry::
hdg ()
{
  return this->hdg_.get ();
}

void t_road_planView_geometry::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}

const t_road_planView_geometry::length_type& t_road_planView_geometry::
length () const
{
  return this->length_.get ();
}

t_road_planView_geometry::length_type& t_road_planView_geometry::
length ()
{
  return this->length_.get ();
}

void t_road_planView_geometry::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_planView_geometry::
length (::std::unique_ptr< length_type > x)
{
  this->length_.set (std::move (x));
}


// t_road_planView_geometry_line
// 

const t_road_planView_geometry_line::userData_sequence& t_road_planView_geometry_line::
userData () const
{
  return this->userData_;
}

t_road_planView_geometry_line::userData_sequence& t_road_planView_geometry_line::
userData ()
{
  return this->userData_;
}

void t_road_planView_geometry_line::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView_geometry_line::include_sequence& t_road_planView_geometry_line::
include () const
{
  return this->include_;
}

t_road_planView_geometry_line::include_sequence& t_road_planView_geometry_line::
include ()
{
  return this->include_;
}

void t_road_planView_geometry_line::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView_geometry_line::dataQuality_optional& t_road_planView_geometry_line::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView_geometry_line::dataQuality_optional& t_road_planView_geometry_line::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView_geometry_line::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_planView_geometry_line::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_planView_geometry_line::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_planView_geometry_spiral
// 

const t_road_planView_geometry_spiral::userData_sequence& t_road_planView_geometry_spiral::
userData () const
{
  return this->userData_;
}

t_road_planView_geometry_spiral::userData_sequence& t_road_planView_geometry_spiral::
userData ()
{
  return this->userData_;
}

void t_road_planView_geometry_spiral::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView_geometry_spiral::include_sequence& t_road_planView_geometry_spiral::
include () const
{
  return this->include_;
}

t_road_planView_geometry_spiral::include_sequence& t_road_planView_geometry_spiral::
include ()
{
  return this->include_;
}

void t_road_planView_geometry_spiral::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView_geometry_spiral::dataQuality_optional& t_road_planView_geometry_spiral::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView_geometry_spiral::dataQuality_optional& t_road_planView_geometry_spiral::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView_geometry_spiral::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_planView_geometry_spiral::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_planView_geometry_spiral::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_planView_geometry_spiral::curvStart_type& t_road_planView_geometry_spiral::
curvStart () const
{
  return this->curvStart_.get ();
}

t_road_planView_geometry_spiral::curvStart_type& t_road_planView_geometry_spiral::
curvStart ()
{
  return this->curvStart_.get ();
}

void t_road_planView_geometry_spiral::
curvStart (const curvStart_type& x)
{
  this->curvStart_.set (x);
}

const t_road_planView_geometry_spiral::curvEnd_type& t_road_planView_geometry_spiral::
curvEnd () const
{
  return this->curvEnd_.get ();
}

t_road_planView_geometry_spiral::curvEnd_type& t_road_planView_geometry_spiral::
curvEnd ()
{
  return this->curvEnd_.get ();
}

void t_road_planView_geometry_spiral::
curvEnd (const curvEnd_type& x)
{
  this->curvEnd_.set (x);
}


// t_road_planView_geometry_arc
// 

const t_road_planView_geometry_arc::userData_sequence& t_road_planView_geometry_arc::
userData () const
{
  return this->userData_;
}

t_road_planView_geometry_arc::userData_sequence& t_road_planView_geometry_arc::
userData ()
{
  return this->userData_;
}

void t_road_planView_geometry_arc::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView_geometry_arc::include_sequence& t_road_planView_geometry_arc::
include () const
{
  return this->include_;
}

t_road_planView_geometry_arc::include_sequence& t_road_planView_geometry_arc::
include ()
{
  return this->include_;
}

void t_road_planView_geometry_arc::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView_geometry_arc::dataQuality_optional& t_road_planView_geometry_arc::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView_geometry_arc::dataQuality_optional& t_road_planView_geometry_arc::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView_geometry_arc::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_planView_geometry_arc::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_planView_geometry_arc::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_planView_geometry_arc::curvature_type& t_road_planView_geometry_arc::
curvature () const
{
  return this->curvature_.get ();
}

t_road_planView_geometry_arc::curvature_type& t_road_planView_geometry_arc::
curvature ()
{
  return this->curvature_.get ();
}

void t_road_planView_geometry_arc::
curvature (const curvature_type& x)
{
  this->curvature_.set (x);
}


// t_road_planView_geometry_poly3
// 

const t_road_planView_geometry_poly3::userData_sequence& t_road_planView_geometry_poly3::
userData () const
{
  return this->userData_;
}

t_road_planView_geometry_poly3::userData_sequence& t_road_planView_geometry_poly3::
userData ()
{
  return this->userData_;
}

void t_road_planView_geometry_poly3::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView_geometry_poly3::include_sequence& t_road_planView_geometry_poly3::
include () const
{
  return this->include_;
}

t_road_planView_geometry_poly3::include_sequence& t_road_planView_geometry_poly3::
include ()
{
  return this->include_;
}

void t_road_planView_geometry_poly3::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView_geometry_poly3::dataQuality_optional& t_road_planView_geometry_poly3::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView_geometry_poly3::dataQuality_optional& t_road_planView_geometry_poly3::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView_geometry_poly3::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_planView_geometry_poly3::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_planView_geometry_poly3::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_planView_geometry_poly3::a_type& t_road_planView_geometry_poly3::
a () const
{
  return this->a_.get ();
}

t_road_planView_geometry_poly3::a_type& t_road_planView_geometry_poly3::
a ()
{
  return this->a_.get ();
}

void t_road_planView_geometry_poly3::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_planView_geometry_poly3::b_type& t_road_planView_geometry_poly3::
b () const
{
  return this->b_.get ();
}

t_road_planView_geometry_poly3::b_type& t_road_planView_geometry_poly3::
b ()
{
  return this->b_.get ();
}

void t_road_planView_geometry_poly3::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_planView_geometry_poly3::c_type& t_road_planView_geometry_poly3::
c () const
{
  return this->c_.get ();
}

t_road_planView_geometry_poly3::c_type& t_road_planView_geometry_poly3::
c ()
{
  return this->c_.get ();
}

void t_road_planView_geometry_poly3::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_planView_geometry_poly3::d_type& t_road_planView_geometry_poly3::
d () const
{
  return this->d_.get ();
}

t_road_planView_geometry_poly3::d_type& t_road_planView_geometry_poly3::
d ()
{
  return this->d_.get ();
}

void t_road_planView_geometry_poly3::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_planView_geometry_paramPoly3
// 

const t_road_planView_geometry_paramPoly3::userData_sequence& t_road_planView_geometry_paramPoly3::
userData () const
{
  return this->userData_;
}

t_road_planView_geometry_paramPoly3::userData_sequence& t_road_planView_geometry_paramPoly3::
userData ()
{
  return this->userData_;
}

void t_road_planView_geometry_paramPoly3::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_planView_geometry_paramPoly3::include_sequence& t_road_planView_geometry_paramPoly3::
include () const
{
  return this->include_;
}

t_road_planView_geometry_paramPoly3::include_sequence& t_road_planView_geometry_paramPoly3::
include ()
{
  return this->include_;
}

void t_road_planView_geometry_paramPoly3::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_planView_geometry_paramPoly3::dataQuality_optional& t_road_planView_geometry_paramPoly3::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_planView_geometry_paramPoly3::dataQuality_optional& t_road_planView_geometry_paramPoly3::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_planView_geometry_paramPoly3::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_planView_geometry_paramPoly3::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_planView_geometry_paramPoly3::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_planView_geometry_paramPoly3::aU_type& t_road_planView_geometry_paramPoly3::
aU () const
{
  return this->aU_.get ();
}

t_road_planView_geometry_paramPoly3::aU_type& t_road_planView_geometry_paramPoly3::
aU ()
{
  return this->aU_.get ();
}

void t_road_planView_geometry_paramPoly3::
aU (const aU_type& x)
{
  this->aU_.set (x);
}

const t_road_planView_geometry_paramPoly3::bU_type& t_road_planView_geometry_paramPoly3::
bU () const
{
  return this->bU_.get ();
}

t_road_planView_geometry_paramPoly3::bU_type& t_road_planView_geometry_paramPoly3::
bU ()
{
  return this->bU_.get ();
}

void t_road_planView_geometry_paramPoly3::
bU (const bU_type& x)
{
  this->bU_.set (x);
}

const t_road_planView_geometry_paramPoly3::cU_type& t_road_planView_geometry_paramPoly3::
cU () const
{
  return this->cU_.get ();
}

t_road_planView_geometry_paramPoly3::cU_type& t_road_planView_geometry_paramPoly3::
cU ()
{
  return this->cU_.get ();
}

void t_road_planView_geometry_paramPoly3::
cU (const cU_type& x)
{
  this->cU_.set (x);
}

const t_road_planView_geometry_paramPoly3::dU_type& t_road_planView_geometry_paramPoly3::
dU () const
{
  return this->dU_.get ();
}

t_road_planView_geometry_paramPoly3::dU_type& t_road_planView_geometry_paramPoly3::
dU ()
{
  return this->dU_.get ();
}

void t_road_planView_geometry_paramPoly3::
dU (const dU_type& x)
{
  this->dU_.set (x);
}

const t_road_planView_geometry_paramPoly3::aV_type& t_road_planView_geometry_paramPoly3::
aV () const
{
  return this->aV_.get ();
}

t_road_planView_geometry_paramPoly3::aV_type& t_road_planView_geometry_paramPoly3::
aV ()
{
  return this->aV_.get ();
}

void t_road_planView_geometry_paramPoly3::
aV (const aV_type& x)
{
  this->aV_.set (x);
}

const t_road_planView_geometry_paramPoly3::bV_type& t_road_planView_geometry_paramPoly3::
bV () const
{
  return this->bV_.get ();
}

t_road_planView_geometry_paramPoly3::bV_type& t_road_planView_geometry_paramPoly3::
bV ()
{
  return this->bV_.get ();
}

void t_road_planView_geometry_paramPoly3::
bV (const bV_type& x)
{
  this->bV_.set (x);
}

const t_road_planView_geometry_paramPoly3::cV_type& t_road_planView_geometry_paramPoly3::
cV () const
{
  return this->cV_.get ();
}

t_road_planView_geometry_paramPoly3::cV_type& t_road_planView_geometry_paramPoly3::
cV ()
{
  return this->cV_.get ();
}

void t_road_planView_geometry_paramPoly3::
cV (const cV_type& x)
{
  this->cV_.set (x);
}

const t_road_planView_geometry_paramPoly3::dV_type& t_road_planView_geometry_paramPoly3::
dV () const
{
  return this->dV_.get ();
}

t_road_planView_geometry_paramPoly3::dV_type& t_road_planView_geometry_paramPoly3::
dV ()
{
  return this->dV_.get ();
}

void t_road_planView_geometry_paramPoly3::
dV (const dV_type& x)
{
  this->dV_.set (x);
}

const t_road_planView_geometry_paramPoly3::pRange_type& t_road_planView_geometry_paramPoly3::
pRange () const
{
  return this->pRange_.get ();
}

t_road_planView_geometry_paramPoly3::pRange_type& t_road_planView_geometry_paramPoly3::
pRange ()
{
  return this->pRange_.get ();
}

void t_road_planView_geometry_paramPoly3::
pRange (const pRange_type& x)
{
  this->pRange_.set (x);
}

void t_road_planView_geometry_paramPoly3::
pRange (::std::unique_ptr< pRange_type > x)
{
  this->pRange_.set (std::move (x));
}


// e_paramPoly3_pRange
// 

e_paramPoly3_pRange::
e_paramPoly3_pRange (value v)
: ::xml_schema::string (_xsd_e_paramPoly3_pRange_literals_[v])
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const char* v)
: ::xml_schema::string (v)
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const e_paramPoly3_pRange& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_paramPoly3_pRange& e_paramPoly3_pRange::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_paramPoly3_pRange_literals_[v]);

  return *this;
}


// t_road_elevationProfile
// 

const t_road_elevationProfile::elevation_sequence& t_road_elevationProfile::
elevation () const
{
  return this->elevation_;
}

t_road_elevationProfile::elevation_sequence& t_road_elevationProfile::
elevation ()
{
  return this->elevation_;
}

void t_road_elevationProfile::
elevation (const elevation_sequence& s)
{
  this->elevation_ = s;
}

const t_road_elevationProfile::userData_sequence& t_road_elevationProfile::
userData () const
{
  return this->userData_;
}

t_road_elevationProfile::userData_sequence& t_road_elevationProfile::
userData ()
{
  return this->userData_;
}

void t_road_elevationProfile::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_elevationProfile::include_sequence& t_road_elevationProfile::
include () const
{
  return this->include_;
}

t_road_elevationProfile::include_sequence& t_road_elevationProfile::
include ()
{
  return this->include_;
}

void t_road_elevationProfile::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_elevationProfile::dataQuality_optional& t_road_elevationProfile::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_elevationProfile::dataQuality_optional& t_road_elevationProfile::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_elevationProfile::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_elevationProfile::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_elevationProfile::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_elevationProfile_elevation
// 

const t_road_elevationProfile_elevation::userData_sequence& t_road_elevationProfile_elevation::
userData () const
{
  return this->userData_;
}

t_road_elevationProfile_elevation::userData_sequence& t_road_elevationProfile_elevation::
userData ()
{
  return this->userData_;
}

void t_road_elevationProfile_elevation::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_elevationProfile_elevation::include_sequence& t_road_elevationProfile_elevation::
include () const
{
  return this->include_;
}

t_road_elevationProfile_elevation::include_sequence& t_road_elevationProfile_elevation::
include ()
{
  return this->include_;
}

void t_road_elevationProfile_elevation::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_elevationProfile_elevation::dataQuality_optional& t_road_elevationProfile_elevation::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_elevationProfile_elevation::dataQuality_optional& t_road_elevationProfile_elevation::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_elevationProfile_elevation::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_elevationProfile_elevation::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_elevationProfile_elevation::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_elevationProfile_elevation::s_type& t_road_elevationProfile_elevation::
s () const
{
  return this->s_.get ();
}

t_road_elevationProfile_elevation::s_type& t_road_elevationProfile_elevation::
s ()
{
  return this->s_.get ();
}

void t_road_elevationProfile_elevation::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_elevationProfile_elevation::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_elevationProfile_elevation::a_type& t_road_elevationProfile_elevation::
a () const
{
  return this->a_.get ();
}

t_road_elevationProfile_elevation::a_type& t_road_elevationProfile_elevation::
a ()
{
  return this->a_.get ();
}

void t_road_elevationProfile_elevation::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_elevationProfile_elevation::b_type& t_road_elevationProfile_elevation::
b () const
{
  return this->b_.get ();
}

t_road_elevationProfile_elevation::b_type& t_road_elevationProfile_elevation::
b ()
{
  return this->b_.get ();
}

void t_road_elevationProfile_elevation::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_elevationProfile_elevation::c_type& t_road_elevationProfile_elevation::
c () const
{
  return this->c_.get ();
}

t_road_elevationProfile_elevation::c_type& t_road_elevationProfile_elevation::
c ()
{
  return this->c_.get ();
}

void t_road_elevationProfile_elevation::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_elevationProfile_elevation::d_type& t_road_elevationProfile_elevation::
d () const
{
  return this->d_.get ();
}

t_road_elevationProfile_elevation::d_type& t_road_elevationProfile_elevation::
d ()
{
  return this->d_.get ();
}

void t_road_elevationProfile_elevation::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lateralProfile
// 

const t_road_lateralProfile::superelevation_sequence& t_road_lateralProfile::
superelevation () const
{
  return this->superelevation_;
}

t_road_lateralProfile::superelevation_sequence& t_road_lateralProfile::
superelevation ()
{
  return this->superelevation_;
}

void t_road_lateralProfile::
superelevation (const superelevation_sequence& s)
{
  this->superelevation_ = s;
}

const t_road_lateralProfile::crossfall_sequence& t_road_lateralProfile::
crossfall () const
{
  return this->crossfall_;
}

t_road_lateralProfile::crossfall_sequence& t_road_lateralProfile::
crossfall ()
{
  return this->crossfall_;
}

void t_road_lateralProfile::
crossfall (const crossfall_sequence& s)
{
  this->crossfall_ = s;
}

const t_road_lateralProfile::shape_sequence& t_road_lateralProfile::
shape () const
{
  return this->shape_;
}

t_road_lateralProfile::shape_sequence& t_road_lateralProfile::
shape ()
{
  return this->shape_;
}

void t_road_lateralProfile::
shape (const shape_sequence& s)
{
  this->shape_ = s;
}

const t_road_lateralProfile::userData_sequence& t_road_lateralProfile::
userData () const
{
  return this->userData_;
}

t_road_lateralProfile::userData_sequence& t_road_lateralProfile::
userData ()
{
  return this->userData_;
}

void t_road_lateralProfile::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lateralProfile::include_sequence& t_road_lateralProfile::
include () const
{
  return this->include_;
}

t_road_lateralProfile::include_sequence& t_road_lateralProfile::
include ()
{
  return this->include_;
}

void t_road_lateralProfile::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lateralProfile::dataQuality_optional& t_road_lateralProfile::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lateralProfile::dataQuality_optional& t_road_lateralProfile::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lateralProfile::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lateralProfile::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lateralProfile::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_lateralProfile_superelevation
// 

const t_road_lateralProfile_superelevation::userData_sequence& t_road_lateralProfile_superelevation::
userData () const
{
  return this->userData_;
}

t_road_lateralProfile_superelevation::userData_sequence& t_road_lateralProfile_superelevation::
userData ()
{
  return this->userData_;
}

void t_road_lateralProfile_superelevation::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lateralProfile_superelevation::include_sequence& t_road_lateralProfile_superelevation::
include () const
{
  return this->include_;
}

t_road_lateralProfile_superelevation::include_sequence& t_road_lateralProfile_superelevation::
include ()
{
  return this->include_;
}

void t_road_lateralProfile_superelevation::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lateralProfile_superelevation::dataQuality_optional& t_road_lateralProfile_superelevation::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lateralProfile_superelevation::dataQuality_optional& t_road_lateralProfile_superelevation::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lateralProfile_superelevation::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lateralProfile_superelevation::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lateralProfile_superelevation::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lateralProfile_superelevation::s_type& t_road_lateralProfile_superelevation::
s () const
{
  return this->s_.get ();
}

t_road_lateralProfile_superelevation::s_type& t_road_lateralProfile_superelevation::
s ()
{
  return this->s_.get ();
}

void t_road_lateralProfile_superelevation::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lateralProfile_superelevation::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_lateralProfile_superelevation::a_type& t_road_lateralProfile_superelevation::
a () const
{
  return this->a_.get ();
}

t_road_lateralProfile_superelevation::a_type& t_road_lateralProfile_superelevation::
a ()
{
  return this->a_.get ();
}

void t_road_lateralProfile_superelevation::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lateralProfile_superelevation::b_type& t_road_lateralProfile_superelevation::
b () const
{
  return this->b_.get ();
}

t_road_lateralProfile_superelevation::b_type& t_road_lateralProfile_superelevation::
b ()
{
  return this->b_.get ();
}

void t_road_lateralProfile_superelevation::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lateralProfile_superelevation::c_type& t_road_lateralProfile_superelevation::
c () const
{
  return this->c_.get ();
}

t_road_lateralProfile_superelevation::c_type& t_road_lateralProfile_superelevation::
c ()
{
  return this->c_.get ();
}

void t_road_lateralProfile_superelevation::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lateralProfile_superelevation::d_type& t_road_lateralProfile_superelevation::
d () const
{
  return this->d_.get ();
}

t_road_lateralProfile_superelevation::d_type& t_road_lateralProfile_superelevation::
d ()
{
  return this->d_.get ();
}

void t_road_lateralProfile_superelevation::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lateralProfile_crossfall
// 

const t_road_lateralProfile_crossfall::userData_sequence& t_road_lateralProfile_crossfall::
userData () const
{
  return this->userData_;
}

t_road_lateralProfile_crossfall::userData_sequence& t_road_lateralProfile_crossfall::
userData ()
{
  return this->userData_;
}

void t_road_lateralProfile_crossfall::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lateralProfile_crossfall::include_sequence& t_road_lateralProfile_crossfall::
include () const
{
  return this->include_;
}

t_road_lateralProfile_crossfall::include_sequence& t_road_lateralProfile_crossfall::
include ()
{
  return this->include_;
}

void t_road_lateralProfile_crossfall::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lateralProfile_crossfall::dataQuality_optional& t_road_lateralProfile_crossfall::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lateralProfile_crossfall::dataQuality_optional& t_road_lateralProfile_crossfall::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lateralProfile_crossfall::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lateralProfile_crossfall::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lateralProfile_crossfall::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lateralProfile_crossfall::side_type& t_road_lateralProfile_crossfall::
side () const
{
  return this->side_.get ();
}

t_road_lateralProfile_crossfall::side_type& t_road_lateralProfile_crossfall::
side ()
{
  return this->side_.get ();
}

void t_road_lateralProfile_crossfall::
side (const side_type& x)
{
  this->side_.set (x);
}

void t_road_lateralProfile_crossfall::
side (::std::unique_ptr< side_type > x)
{
  this->side_.set (std::move (x));
}

const t_road_lateralProfile_crossfall::s_type& t_road_lateralProfile_crossfall::
s () const
{
  return this->s_.get ();
}

t_road_lateralProfile_crossfall::s_type& t_road_lateralProfile_crossfall::
s ()
{
  return this->s_.get ();
}

void t_road_lateralProfile_crossfall::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lateralProfile_crossfall::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_lateralProfile_crossfall::a_type& t_road_lateralProfile_crossfall::
a () const
{
  return this->a_.get ();
}

t_road_lateralProfile_crossfall::a_type& t_road_lateralProfile_crossfall::
a ()
{
  return this->a_.get ();
}

void t_road_lateralProfile_crossfall::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lateralProfile_crossfall::b_type& t_road_lateralProfile_crossfall::
b () const
{
  return this->b_.get ();
}

t_road_lateralProfile_crossfall::b_type& t_road_lateralProfile_crossfall::
b ()
{
  return this->b_.get ();
}

void t_road_lateralProfile_crossfall::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lateralProfile_crossfall::c_type& t_road_lateralProfile_crossfall::
c () const
{
  return this->c_.get ();
}

t_road_lateralProfile_crossfall::c_type& t_road_lateralProfile_crossfall::
c ()
{
  return this->c_.get ();
}

void t_road_lateralProfile_crossfall::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lateralProfile_crossfall::d_type& t_road_lateralProfile_crossfall::
d () const
{
  return this->d_.get ();
}

t_road_lateralProfile_crossfall::d_type& t_road_lateralProfile_crossfall::
d ()
{
  return this->d_.get ();
}

void t_road_lateralProfile_crossfall::
d (const d_type& x)
{
  this->d_.set (x);
}


// e_road_lateralProfile_crossfall_side
// 

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (value v)
: ::xml_schema::string (_xsd_e_road_lateralProfile_crossfall_side_literals_[v])
{
}

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (const char* v)
: ::xml_schema::string (v)
{
}

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (const e_road_lateralProfile_crossfall_side& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_lateralProfile_crossfall_side& e_road_lateralProfile_crossfall_side::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_lateralProfile_crossfall_side_literals_[v]);

  return *this;
}


// t_road_lateralProfile_shape
// 

const t_road_lateralProfile_shape::userData_sequence& t_road_lateralProfile_shape::
userData () const
{
  return this->userData_;
}

t_road_lateralProfile_shape::userData_sequence& t_road_lateralProfile_shape::
userData ()
{
  return this->userData_;
}

void t_road_lateralProfile_shape::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lateralProfile_shape::include_sequence& t_road_lateralProfile_shape::
include () const
{
  return this->include_;
}

t_road_lateralProfile_shape::include_sequence& t_road_lateralProfile_shape::
include ()
{
  return this->include_;
}

void t_road_lateralProfile_shape::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lateralProfile_shape::dataQuality_optional& t_road_lateralProfile_shape::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lateralProfile_shape::dataQuality_optional& t_road_lateralProfile_shape::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lateralProfile_shape::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lateralProfile_shape::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lateralProfile_shape::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lateralProfile_shape::s_type& t_road_lateralProfile_shape::
s () const
{
  return this->s_.get ();
}

t_road_lateralProfile_shape::s_type& t_road_lateralProfile_shape::
s ()
{
  return this->s_.get ();
}

void t_road_lateralProfile_shape::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lateralProfile_shape::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_lateralProfile_shape::t_type& t_road_lateralProfile_shape::
t () const
{
  return this->t_.get ();
}

t_road_lateralProfile_shape::t_type& t_road_lateralProfile_shape::
t ()
{
  return this->t_.get ();
}

void t_road_lateralProfile_shape::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_lateralProfile_shape::a_type& t_road_lateralProfile_shape::
a () const
{
  return this->a_.get ();
}

t_road_lateralProfile_shape::a_type& t_road_lateralProfile_shape::
a ()
{
  return this->a_.get ();
}

void t_road_lateralProfile_shape::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lateralProfile_shape::b_type& t_road_lateralProfile_shape::
b () const
{
  return this->b_.get ();
}

t_road_lateralProfile_shape::b_type& t_road_lateralProfile_shape::
b ()
{
  return this->b_.get ();
}

void t_road_lateralProfile_shape::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lateralProfile_shape::c_type& t_road_lateralProfile_shape::
c () const
{
  return this->c_.get ();
}

t_road_lateralProfile_shape::c_type& t_road_lateralProfile_shape::
c ()
{
  return this->c_.get ();
}

void t_road_lateralProfile_shape::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lateralProfile_shape::d_type& t_road_lateralProfile_shape::
d () const
{
  return this->d_.get ();
}

t_road_lateralProfile_shape::d_type& t_road_lateralProfile_shape::
d ()
{
  return this->d_.get ();
}

void t_road_lateralProfile_shape::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes
// 

const t_road_lanes::laneOffset_sequence& t_road_lanes::
laneOffset () const
{
  return this->laneOffset_;
}

t_road_lanes::laneOffset_sequence& t_road_lanes::
laneOffset ()
{
  return this->laneOffset_;
}

void t_road_lanes::
laneOffset (const laneOffset_sequence& s)
{
  this->laneOffset_ = s;
}

const t_road_lanes::laneSection_sequence& t_road_lanes::
laneSection () const
{
  return this->laneSection_;
}

t_road_lanes::laneSection_sequence& t_road_lanes::
laneSection ()
{
  return this->laneSection_;
}

void t_road_lanes::
laneSection (const laneSection_sequence& s)
{
  this->laneSection_ = s;
}

const t_road_lanes::userData_sequence& t_road_lanes::
userData () const
{
  return this->userData_;
}

t_road_lanes::userData_sequence& t_road_lanes::
userData ()
{
  return this->userData_;
}

void t_road_lanes::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes::include_sequence& t_road_lanes::
include () const
{
  return this->include_;
}

t_road_lanes::include_sequence& t_road_lanes::
include ()
{
  return this->include_;
}

void t_road_lanes::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes::dataQuality_optional& t_road_lanes::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes::dataQuality_optional& t_road_lanes::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_lanes_laneOffset
// 

const t_road_lanes_laneOffset::userData_sequence& t_road_lanes_laneOffset::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneOffset::userData_sequence& t_road_lanes_laneOffset::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneOffset::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneOffset::include_sequence& t_road_lanes_laneOffset::
include () const
{
  return this->include_;
}

t_road_lanes_laneOffset::include_sequence& t_road_lanes_laneOffset::
include ()
{
  return this->include_;
}

void t_road_lanes_laneOffset::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneOffset::dataQuality_optional& t_road_lanes_laneOffset::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneOffset::dataQuality_optional& t_road_lanes_laneOffset::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneOffset::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneOffset::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneOffset::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneOffset::s_type& t_road_lanes_laneOffset::
s () const
{
  return this->s_.get ();
}

t_road_lanes_laneOffset::s_type& t_road_lanes_laneOffset::
s ()
{
  return this->s_.get ();
}

void t_road_lanes_laneOffset::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lanes_laneOffset::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_lanes_laneOffset::a_type& t_road_lanes_laneOffset::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneOffset::a_type& t_road_lanes_laneOffset::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneOffset::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneOffset::b_type& t_road_lanes_laneOffset::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneOffset::b_type& t_road_lanes_laneOffset::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneOffset::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneOffset::c_type& t_road_lanes_laneOffset::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneOffset::c_type& t_road_lanes_laneOffset::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneOffset::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneOffset::d_type& t_road_lanes_laneOffset::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneOffset::d_type& t_road_lanes_laneOffset::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneOffset::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection
// 

const t_road_lanes_laneSection::left_optional& t_road_lanes_laneSection::
left () const
{
  return this->left_;
}

t_road_lanes_laneSection::left_optional& t_road_lanes_laneSection::
left ()
{
  return this->left_;
}

void t_road_lanes_laneSection::
left (const left_type& x)
{
  this->left_.set (x);
}

void t_road_lanes_laneSection::
left (const left_optional& x)
{
  this->left_ = x;
}

void t_road_lanes_laneSection::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const t_road_lanes_laneSection::center_optional& t_road_lanes_laneSection::
center () const
{
  return this->center_;
}

t_road_lanes_laneSection::center_optional& t_road_lanes_laneSection::
center ()
{
  return this->center_;
}

void t_road_lanes_laneSection::
center (const center_type& x)
{
  this->center_.set (x);
}

void t_road_lanes_laneSection::
center (const center_optional& x)
{
  this->center_ = x;
}

void t_road_lanes_laneSection::
center (::std::unique_ptr< center_type > x)
{
  this->center_.set (std::move (x));
}

const t_road_lanes_laneSection::right_optional& t_road_lanes_laneSection::
right () const
{
  return this->right_;
}

t_road_lanes_laneSection::right_optional& t_road_lanes_laneSection::
right ()
{
  return this->right_;
}

void t_road_lanes_laneSection::
right (const right_type& x)
{
  this->right_.set (x);
}

void t_road_lanes_laneSection::
right (const right_optional& x)
{
  this->right_ = x;
}

void t_road_lanes_laneSection::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}

const t_road_lanes_laneSection::userData_sequence& t_road_lanes_laneSection::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection::userData_sequence& t_road_lanes_laneSection::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection::include_sequence& t_road_lanes_laneSection::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection::include_sequence& t_road_lanes_laneSection::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection::dataQuality_optional& t_road_lanes_laneSection::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection::dataQuality_optional& t_road_lanes_laneSection::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection::s_type& t_road_lanes_laneSection::
s () const
{
  return this->s_.get ();
}

t_road_lanes_laneSection::s_type& t_road_lanes_laneSection::
s ()
{
  return this->s_.get ();
}

void t_road_lanes_laneSection::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_lanes_laneSection::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_lanes_laneSection::singleSide_optional& t_road_lanes_laneSection::
singleSide () const
{
  return this->singleSide_;
}

t_road_lanes_laneSection::singleSide_optional& t_road_lanes_laneSection::
singleSide ()
{
  return this->singleSide_;
}

void t_road_lanes_laneSection::
singleSide (const singleSide_type& x)
{
  this->singleSide_.set (x);
}

void t_road_lanes_laneSection::
singleSide (const singleSide_optional& x)
{
  this->singleSide_ = x;
}

void t_road_lanes_laneSection::
singleSide (::std::unique_ptr< singleSide_type > x)
{
  this->singleSide_.set (std::move (x));
}


// t_road_lanes_laneSection_left
// 

const t_road_lanes_laneSection_left::lane_sequence& t_road_lanes_laneSection_left::
lane () const
{
  return this->lane_;
}

t_road_lanes_laneSection_left::lane_sequence& t_road_lanes_laneSection_left::
lane ()
{
  return this->lane_;
}

void t_road_lanes_laneSection_left::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const t_road_lanes_laneSection_left::userData_sequence& t_road_lanes_laneSection_left::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_left::userData_sequence& t_road_lanes_laneSection_left::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_left::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_left::include_sequence& t_road_lanes_laneSection_left::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_left::include_sequence& t_road_lanes_laneSection_left::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_left::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_left::dataQuality_optional& t_road_lanes_laneSection_left::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_left::dataQuality_optional& t_road_lanes_laneSection_left::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_left::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_left::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_left::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_lanes_laneSection_center
// 

const t_road_lanes_laneSection_center::lane_sequence& t_road_lanes_laneSection_center::
lane () const
{
  return this->lane_;
}

t_road_lanes_laneSection_center::lane_sequence& t_road_lanes_laneSection_center::
lane ()
{
  return this->lane_;
}

void t_road_lanes_laneSection_center::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const t_road_lanes_laneSection_center::userData_sequence& t_road_lanes_laneSection_center::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_center::userData_sequence& t_road_lanes_laneSection_center::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_center::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_center::include_sequence& t_road_lanes_laneSection_center::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_center::include_sequence& t_road_lanes_laneSection_center::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_center::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_center::dataQuality_optional& t_road_lanes_laneSection_center::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_center::dataQuality_optional& t_road_lanes_laneSection_center::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_center::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_center::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_center::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_lanes_laneSection_right
// 

const t_road_lanes_laneSection_right::lane_sequence& t_road_lanes_laneSection_right::
lane () const
{
  return this->lane_;
}

t_road_lanes_laneSection_right::lane_sequence& t_road_lanes_laneSection_right::
lane ()
{
  return this->lane_;
}

void t_road_lanes_laneSection_right::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}

const t_road_lanes_laneSection_right::userData_sequence& t_road_lanes_laneSection_right::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_right::userData_sequence& t_road_lanes_laneSection_right::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_right::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_right::include_sequence& t_road_lanes_laneSection_right::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_right::include_sequence& t_road_lanes_laneSection_right::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_right::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_right::dataQuality_optional& t_road_lanes_laneSection_right::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_right::dataQuality_optional& t_road_lanes_laneSection_right::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_right::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_right::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_right::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_lanes_laneSection_center_lane
// 

const t_road_lanes_laneSection_center_lane::link_optional& t_road_lanes_laneSection_center_lane::
link () const
{
  return this->link_;
}

t_road_lanes_laneSection_center_lane::link_optional& t_road_lanes_laneSection_center_lane::
link ()
{
  return this->link_;
}

void t_road_lanes_laneSection_center_lane::
link (const link_type& x)
{
  this->link_.set (x);
}

void t_road_lanes_laneSection_center_lane::
link (const link_optional& x)
{
  this->link_ = x;
}

void t_road_lanes_laneSection_center_lane::
link (::std::unique_ptr< link_type > x)
{
  this->link_.set (std::move (x));
}

const t_road_lanes_laneSection_center_lane::roadMark_sequence& t_road_lanes_laneSection_center_lane::
roadMark () const
{
  return this->roadMark_;
}

t_road_lanes_laneSection_center_lane::roadMark_sequence& t_road_lanes_laneSection_center_lane::
roadMark ()
{
  return this->roadMark_;
}

void t_road_lanes_laneSection_center_lane::
roadMark (const roadMark_sequence& s)
{
  this->roadMark_ = s;
}

const t_road_lanes_laneSection_center_lane::userData_sequence& t_road_lanes_laneSection_center_lane::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_center_lane::userData_sequence& t_road_lanes_laneSection_center_lane::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_center_lane::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_center_lane::include_sequence& t_road_lanes_laneSection_center_lane::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_center_lane::include_sequence& t_road_lanes_laneSection_center_lane::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_center_lane::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_center_lane::dataQuality_optional& t_road_lanes_laneSection_center_lane::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_center_lane::dataQuality_optional& t_road_lanes_laneSection_center_lane::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_center_lane::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_center_lane::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_center_lane::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_center_lane::id_type& t_road_lanes_laneSection_center_lane::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_center_lane::id_type t_road_lanes_laneSection_center_lane::
id_default_value ()
{
  return id_type (0LL);
}

const t_road_lanes_laneSection_center_lane::type_type& t_road_lanes_laneSection_center_lane::
type () const
{
  return this->type_.get ();
}

t_road_lanes_laneSection_center_lane::type_type& t_road_lanes_laneSection_center_lane::
type ()
{
  return this->type_.get ();
}

void t_road_lanes_laneSection_center_lane::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_lanes_laneSection_center_lane::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_lanes_laneSection_center_lane::level_optional& t_road_lanes_laneSection_center_lane::
level () const
{
  return this->level_;
}

t_road_lanes_laneSection_center_lane::level_optional& t_road_lanes_laneSection_center_lane::
level ()
{
  return this->level_;
}

void t_road_lanes_laneSection_center_lane::
level (const level_type& x)
{
  this->level_.set (x);
}

void t_road_lanes_laneSection_center_lane::
level (const level_optional& x)
{
  this->level_ = x;
}

void t_road_lanes_laneSection_center_lane::
level (::std::unique_ptr< level_type > x)
{
  this->level_.set (std::move (x));
}


// t_road_lanes_laneSection_lr_lane
// 

const t_road_lanes_laneSection_lr_lane::link_optional& t_road_lanes_laneSection_lr_lane::
link () const
{
  return this->link_;
}

t_road_lanes_laneSection_lr_lane::link_optional& t_road_lanes_laneSection_lr_lane::
link ()
{
  return this->link_;
}

void t_road_lanes_laneSection_lr_lane::
link (const link_type& x)
{
  this->link_.set (x);
}

void t_road_lanes_laneSection_lr_lane::
link (const link_optional& x)
{
  this->link_ = x;
}

void t_road_lanes_laneSection_lr_lane::
link (::std::unique_ptr< link_type > x)
{
  this->link_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane::width_sequence& t_road_lanes_laneSection_lr_lane::
width () const
{
  return this->width_;
}

t_road_lanes_laneSection_lr_lane::width_sequence& t_road_lanes_laneSection_lr_lane::
width ()
{
  return this->width_;
}

void t_road_lanes_laneSection_lr_lane::
width (const width_sequence& s)
{
  this->width_ = s;
}

const t_road_lanes_laneSection_lr_lane::border_sequence& t_road_lanes_laneSection_lr_lane::
border () const
{
  return this->border_;
}

t_road_lanes_laneSection_lr_lane::border_sequence& t_road_lanes_laneSection_lr_lane::
border ()
{
  return this->border_;
}

void t_road_lanes_laneSection_lr_lane::
border (const border_sequence& s)
{
  this->border_ = s;
}

const t_road_lanes_laneSection_lr_lane::roadMark_sequence& t_road_lanes_laneSection_lr_lane::
roadMark () const
{
  return this->roadMark_;
}

t_road_lanes_laneSection_lr_lane::roadMark_sequence& t_road_lanes_laneSection_lr_lane::
roadMark ()
{
  return this->roadMark_;
}

void t_road_lanes_laneSection_lr_lane::
roadMark (const roadMark_sequence& s)
{
  this->roadMark_ = s;
}

const t_road_lanes_laneSection_lr_lane::material_sequence& t_road_lanes_laneSection_lr_lane::
material () const
{
  return this->material_;
}

t_road_lanes_laneSection_lr_lane::material_sequence& t_road_lanes_laneSection_lr_lane::
material ()
{
  return this->material_;
}

void t_road_lanes_laneSection_lr_lane::
material (const material_sequence& s)
{
  this->material_ = s;
}

const t_road_lanes_laneSection_lr_lane::visibility_sequence& t_road_lanes_laneSection_lr_lane::
visibility () const
{
  return this->visibility_;
}

t_road_lanes_laneSection_lr_lane::visibility_sequence& t_road_lanes_laneSection_lr_lane::
visibility ()
{
  return this->visibility_;
}

void t_road_lanes_laneSection_lr_lane::
visibility (const visibility_sequence& s)
{
  this->visibility_ = s;
}

const t_road_lanes_laneSection_lr_lane::speed_sequence& t_road_lanes_laneSection_lr_lane::
speed () const
{
  return this->speed_;
}

t_road_lanes_laneSection_lr_lane::speed_sequence& t_road_lanes_laneSection_lr_lane::
speed ()
{
  return this->speed_;
}

void t_road_lanes_laneSection_lr_lane::
speed (const speed_sequence& s)
{
  this->speed_ = s;
}

const t_road_lanes_laneSection_lr_lane::access_sequence& t_road_lanes_laneSection_lr_lane::
access () const
{
  return this->access_;
}

t_road_lanes_laneSection_lr_lane::access_sequence& t_road_lanes_laneSection_lr_lane::
access ()
{
  return this->access_;
}

void t_road_lanes_laneSection_lr_lane::
access (const access_sequence& s)
{
  this->access_ = s;
}

const t_road_lanes_laneSection_lr_lane::height_sequence& t_road_lanes_laneSection_lr_lane::
height () const
{
  return this->height_;
}

t_road_lanes_laneSection_lr_lane::height_sequence& t_road_lanes_laneSection_lr_lane::
height ()
{
  return this->height_;
}

void t_road_lanes_laneSection_lr_lane::
height (const height_sequence& s)
{
  this->height_ = s;
}

const t_road_lanes_laneSection_lr_lane::rule_sequence& t_road_lanes_laneSection_lr_lane::
rule () const
{
  return this->rule_;
}

t_road_lanes_laneSection_lr_lane::rule_sequence& t_road_lanes_laneSection_lr_lane::
rule ()
{
  return this->rule_;
}

void t_road_lanes_laneSection_lr_lane::
rule (const rule_sequence& s)
{
  this->rule_ = s;
}

const t_road_lanes_laneSection_lr_lane::userData_sequence& t_road_lanes_laneSection_lr_lane::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane::userData_sequence& t_road_lanes_laneSection_lr_lane::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane::include_sequence& t_road_lanes_laneSection_lr_lane::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane::include_sequence& t_road_lanes_laneSection_lr_lane::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane::dataQuality_optional& t_road_lanes_laneSection_lr_lane::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane::dataQuality_optional& t_road_lanes_laneSection_lr_lane::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane::type_type& t_road_lanes_laneSection_lr_lane::
type () const
{
  return this->type_.get ();
}

t_road_lanes_laneSection_lr_lane::type_type& t_road_lanes_laneSection_lr_lane::
type ()
{
  return this->type_.get ();
}

void t_road_lanes_laneSection_lr_lane::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_lanes_laneSection_lr_lane::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane::level_optional& t_road_lanes_laneSection_lr_lane::
level () const
{
  return this->level_;
}

t_road_lanes_laneSection_lr_lane::level_optional& t_road_lanes_laneSection_lr_lane::
level ()
{
  return this->level_;
}

void t_road_lanes_laneSection_lr_lane::
level (const level_type& x)
{
  this->level_.set (x);
}

void t_road_lanes_laneSection_lr_lane::
level (const level_optional& x)
{
  this->level_ = x;
}

void t_road_lanes_laneSection_lr_lane::
level (::std::unique_ptr< level_type > x)
{
  this->level_.set (std::move (x));
}


// t_road_lanes_laneSection_left_lane
// 

const t_road_lanes_laneSection_left_lane::id_type& t_road_lanes_laneSection_left_lane::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_left_lane::id_type& t_road_lanes_laneSection_left_lane::
id ()
{
  return this->id_.get ();
}

void t_road_lanes_laneSection_left_lane::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_lanes_laneSection_right_lane
// 

const t_road_lanes_laneSection_right_lane::id_type& t_road_lanes_laneSection_right_lane::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_right_lane::id_type& t_road_lanes_laneSection_right_lane::
id ()
{
  return this->id_.get ();
}

void t_road_lanes_laneSection_right_lane::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_lanes_laneSection_lcr_lane_link
// 

const t_road_lanes_laneSection_lcr_lane_link::predecessor_sequence& t_road_lanes_laneSection_lcr_lane_link::
predecessor () const
{
  return this->predecessor_;
}

t_road_lanes_laneSection_lcr_lane_link::predecessor_sequence& t_road_lanes_laneSection_lcr_lane_link::
predecessor ()
{
  return this->predecessor_;
}

void t_road_lanes_laneSection_lcr_lane_link::
predecessor (const predecessor_sequence& s)
{
  this->predecessor_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::successor_sequence& t_road_lanes_laneSection_lcr_lane_link::
successor () const
{
  return this->successor_;
}

t_road_lanes_laneSection_lcr_lane_link::successor_sequence& t_road_lanes_laneSection_lcr_lane_link::
successor ()
{
  return this->successor_;
}

void t_road_lanes_laneSection_lcr_lane_link::
successor (const successor_sequence& s)
{
  this->successor_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::userData_sequence& t_road_lanes_laneSection_lcr_lane_link::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_link::userData_sequence& t_road_lanes_laneSection_lcr_lane_link::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_link::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::include_sequence& t_road_lanes_laneSection_lcr_lane_link::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_link::include_sequence& t_road_lanes_laneSection_lcr_lane_link::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_link::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_link::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_link::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_link::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_link::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_link::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_link::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor
// 

const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::userData_sequence& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::userData_sequence& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::include_sequence& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::include_sequence& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::id_type& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
id () const
{
  return this->id_.get ();
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::id_type& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
id ()
{
  return this->id_.get ();
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_lanes_laneSection_lr_lane_width
// 

const t_road_lanes_laneSection_lr_lane_width::userData_sequence& t_road_lanes_laneSection_lr_lane_width::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_width::userData_sequence& t_road_lanes_laneSection_lr_lane_width::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_width::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_width::include_sequence& t_road_lanes_laneSection_lr_lane_width::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_width::include_sequence& t_road_lanes_laneSection_lr_lane_width::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_width::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_width::dataQuality_optional& t_road_lanes_laneSection_lr_lane_width::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_width::dataQuality_optional& t_road_lanes_laneSection_lr_lane_width::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_width::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_width::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_width::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_width::sOffset_type& t_road_lanes_laneSection_lr_lane_width::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_width::sOffset_type& t_road_lanes_laneSection_lr_lane_width::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_width::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_width::a_type& t_road_lanes_laneSection_lr_lane_width::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneSection_lr_lane_width::a_type& t_road_lanes_laneSection_lr_lane_width::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneSection_lr_lane_width::b_type& t_road_lanes_laneSection_lr_lane_width::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneSection_lr_lane_width::b_type& t_road_lanes_laneSection_lr_lane_width::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneSection_lr_lane_width::c_type& t_road_lanes_laneSection_lr_lane_width::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneSection_lr_lane_width::c_type& t_road_lanes_laneSection_lr_lane_width::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneSection_lr_lane_width::d_type& t_road_lanes_laneSection_lr_lane_width::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneSection_lr_lane_width::d_type& t_road_lanes_laneSection_lr_lane_width::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneSection_lr_lane_width::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection_lr_lane_border
// 

const t_road_lanes_laneSection_lr_lane_border::userData_sequence& t_road_lanes_laneSection_lr_lane_border::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_border::userData_sequence& t_road_lanes_laneSection_lr_lane_border::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_border::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_border::include_sequence& t_road_lanes_laneSection_lr_lane_border::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_border::include_sequence& t_road_lanes_laneSection_lr_lane_border::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_border::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_border::dataQuality_optional& t_road_lanes_laneSection_lr_lane_border::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_border::dataQuality_optional& t_road_lanes_laneSection_lr_lane_border::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_border::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_border::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_border::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_border::sOffset_type& t_road_lanes_laneSection_lr_lane_border::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_border::sOffset_type& t_road_lanes_laneSection_lr_lane_border::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_border::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_border::a_type& t_road_lanes_laneSection_lr_lane_border::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneSection_lr_lane_border::a_type& t_road_lanes_laneSection_lr_lane_border::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneSection_lr_lane_border::b_type& t_road_lanes_laneSection_lr_lane_border::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneSection_lr_lane_border::b_type& t_road_lanes_laneSection_lr_lane_border::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneSection_lr_lane_border::c_type& t_road_lanes_laneSection_lr_lane_border::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneSection_lr_lane_border::c_type& t_road_lanes_laneSection_lr_lane_border::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneSection_lr_lane_border::d_type& t_road_lanes_laneSection_lr_lane_border::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneSection_lr_lane_border::d_type& t_road_lanes_laneSection_lr_lane_border::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneSection_lr_lane_border::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection_lcr_lane_roadMark
// 

const t_road_lanes_laneSection_lcr_lane_roadMark::sway_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
sway () const
{
  return this->sway_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::sway_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
sway ()
{
  return this->sway_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
sway (const sway_sequence& s)
{
  this->sway_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark::type_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
type () const
{
  return this->type_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::type_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
type ()
{
  return this->type_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::explicit_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ () const
{
  return this->explicit__;
}

t_road_lanes_laneSection_lcr_lane_roadMark::explicit_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ ()
{
  return this->explicit__;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ (const explicit_type& x)
{
  this->explicit__.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ (const explicit_optional& x)
{
  this->explicit__ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
explicit_ (::std::unique_ptr< explicit_type > x)
{
  this->explicit__.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::type1_type& t_road_lanes_laneSection_lcr_lane_roadMark::
type1 () const
{
  return this->type1_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark::type1_type& t_road_lanes_laneSection_lcr_lane_roadMark::
type1 ()
{
  return this->type1_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type1 (const type1_type& x)
{
  this->type1_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
type1 (::std::unique_ptr< type1_type > x)
{
  this->type1_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::weight_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
weight () const
{
  return this->weight_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::weight_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
weight ()
{
  return this->weight_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
weight (::std::unique_ptr< weight_type > x)
{
  this->weight_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::color_type& t_road_lanes_laneSection_lcr_lane_roadMark::
color () const
{
  return this->color_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark::color_type& t_road_lanes_laneSection_lcr_lane_roadMark::
color ()
{
  return this->color_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
color (const color_type& x)
{
  this->color_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
color (::std::unique_ptr< color_type > x)
{
  this->color_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::material_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
material () const
{
  return this->material_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::material_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
material ()
{
  return this->material_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
material (const material_type& x)
{
  this->material_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
material (const material_optional& x)
{
  this->material_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
material (::std::unique_ptr< material_type > x)
{
  this->material_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
width () const
{
  return this->width_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::width_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
width ()
{
  return this->width_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
width (const width_optional& x)
{
  this->width_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
width (::std::unique_ptr< width_type > x)
{
  this->width_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::laneChange_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange () const
{
  return this->laneChange_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::laneChange_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange ()
{
  return this->laneChange_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange (const laneChange_type& x)
{
  this->laneChange_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange (const laneChange_optional& x)
{
  this->laneChange_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
laneChange (::std::unique_ptr< laneChange_type > x)
{
  this->laneChange_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark::height_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
height () const
{
  return this->height_;
}

t_road_lanes_laneSection_lcr_lane_roadMark::height_optional& t_road_lanes_laneSection_lcr_lane_roadMark::
height ()
{
  return this->height_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
height (const height_type& x)
{
  this->height_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
height (const height_optional& x)
{
  this->height_ = x;
}


// e_road_lanes_laneSection_lcr_lane_roadMark_laneChange
// 

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (value v)
: ::xml_schema::string (_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[v])
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const char* v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& v,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[v]);

  return *this;
}


// t_road_lanes_laneSection_lcr_lane_roadMark_sway
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::ds_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds () const
{
  return this->ds_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::ds_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds ()
{
  return this->ds_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds (const ds_type& x)
{
  this->ds_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
ds (::std::unique_ptr< ds_type > x)
{
  this->ds_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::a_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
a () const
{
  return this->a_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::a_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
a ()
{
  return this->a_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
a (const a_type& x)
{
  this->a_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::b_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
b () const
{
  return this->b_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::b_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
b ()
{
  return this->b_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
b (const b_type& x)
{
  this->b_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::c_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
c () const
{
  return this->c_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::c_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
c ()
{
  return this->c_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
c (const c_type& x)
{
  this->c_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_sway::d_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
d () const
{
  return this->d_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::d_type& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
d ()
{
  return this->d_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
d (const d_type& x)
{
  this->d_.set (x);
}


// t_road_lanes_laneSection_lcr_lane_roadMark_type
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_type::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
line () const
{
  return this->line_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
line ()
{
  return this->line_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
line (const line_sequence& s)
{
  this->line_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::name_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
name () const
{
  return this->name_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::name_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
name ()
{
  return this->name_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
width () const
{
  return this->width_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
width ()
{
  return this->width_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
width (::std::unique_ptr< width_type > x)
{
  this->width_.set (std::move (x));
}


// t_road_lanes_laneSection_lcr_lane_roadMark_type_line
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length () const
{
  return this->length_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length ()
{
  return this->length_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
length (::std::unique_ptr< length_type > x)
{
  this->length_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::space_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space () const
{
  return this->space_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::space_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space ()
{
  return this->space_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space (const space_type& x)
{
  this->space_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
space (::std::unique_ptr< space_type > x)
{
  this->space_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
tOffset () const
{
  return this->tOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
tOffset ()
{
  return this->tOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule () const
{
  return this->rule_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule ()
{
  return this->rule_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
rule (::std::unique_ptr< rule_type > x)
{
  this->rule_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width () const
{
  return this->width_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width ()
{
  return this->width_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
width (::std::unique_ptr< width_type > x)
{
  this->width_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_type_line::color_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color () const
{
  return this->color_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::color_optional& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color ()
{
  return this->color_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color (const color_type& x)
{
  this->color_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color (const color_optional& x)
{
  this->color_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
color (::std::unique_ptr< color_type > x)
{
  this->color_.set (std::move (x));
}


// t_road_lanes_laneSection_lcr_lane_roadMark_explicit
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
line () const
{
  return this->line_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::line_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
line ()
{
  return this->line_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
line (const line_sequence& s)
{
  this->line_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line
// 

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::userData_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::include_sequence& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::dataQuality_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length () const
{
  return this->length_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::length_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length ()
{
  return this->length_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
length (::std::unique_ptr< length_type > x)
{
  this->length_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
tOffset () const
{
  return this->tOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::tOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
tOffset ()
{
  return this->tOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::sOffset_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule () const
{
  return this->rule_;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::rule_optional& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule ()
{
  return this->rule_;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule (const rule_optional& x)
{
  this->rule_ = x;
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
rule (::std::unique_ptr< rule_type > x)
{
  this->rule_.set (std::move (x));
}

const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width () const
{
  return this->width_.get ();
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::width_type& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width ()
{
  return this->width_.get ();
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
width (::std::unique_ptr< width_type > x)
{
  this->width_.set (std::move (x));
}


// t_road_lanes_laneSection_lr_lane_material
// 

const t_road_lanes_laneSection_lr_lane_material::userData_sequence& t_road_lanes_laneSection_lr_lane_material::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_material::userData_sequence& t_road_lanes_laneSection_lr_lane_material::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_material::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_material::include_sequence& t_road_lanes_laneSection_lr_lane_material::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_material::include_sequence& t_road_lanes_laneSection_lr_lane_material::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_material::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_material::dataQuality_optional& t_road_lanes_laneSection_lr_lane_material::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_material::dataQuality_optional& t_road_lanes_laneSection_lr_lane_material::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_material::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_material::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_material::sOffset_type& t_road_lanes_laneSection_lr_lane_material::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_material::sOffset_type& t_road_lanes_laneSection_lr_lane_material::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_material::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_material::surface_optional& t_road_lanes_laneSection_lr_lane_material::
surface () const
{
  return this->surface_;
}

t_road_lanes_laneSection_lr_lane_material::surface_optional& t_road_lanes_laneSection_lr_lane_material::
surface ()
{
  return this->surface_;
}

void t_road_lanes_laneSection_lr_lane_material::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void t_road_lanes_laneSection_lr_lane_material::
surface (::std::unique_ptr< surface_type > x)
{
  this->surface_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_material::friction_type& t_road_lanes_laneSection_lr_lane_material::
friction () const
{
  return this->friction_.get ();
}

t_road_lanes_laneSection_lr_lane_material::friction_type& t_road_lanes_laneSection_lr_lane_material::
friction ()
{
  return this->friction_.get ();
}

void t_road_lanes_laneSection_lr_lane_material::
friction (const friction_type& x)
{
  this->friction_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
friction (::std::unique_ptr< friction_type > x)
{
  this->friction_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_material::roughness_optional& t_road_lanes_laneSection_lr_lane_material::
roughness () const
{
  return this->roughness_;
}

t_road_lanes_laneSection_lr_lane_material::roughness_optional& t_road_lanes_laneSection_lr_lane_material::
roughness ()
{
  return this->roughness_;
}

void t_road_lanes_laneSection_lr_lane_material::
roughness (const roughness_type& x)
{
  this->roughness_.set (x);
}

void t_road_lanes_laneSection_lr_lane_material::
roughness (const roughness_optional& x)
{
  this->roughness_ = x;
}

void t_road_lanes_laneSection_lr_lane_material::
roughness (::std::unique_ptr< roughness_type > x)
{
  this->roughness_.set (std::move (x));
}


// t_road_lanes_laneSection_lr_lane_visibility
// 

const t_road_lanes_laneSection_lr_lane_visibility::userData_sequence& t_road_lanes_laneSection_lr_lane_visibility::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_visibility::userData_sequence& t_road_lanes_laneSection_lr_lane_visibility::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_visibility::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_visibility::include_sequence& t_road_lanes_laneSection_lr_lane_visibility::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_visibility::include_sequence& t_road_lanes_laneSection_lr_lane_visibility::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_visibility::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_visibility::dataQuality_optional& t_road_lanes_laneSection_lr_lane_visibility::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_visibility::dataQuality_optional& t_road_lanes_laneSection_lr_lane_visibility::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_visibility::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_visibility::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_visibility::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_visibility::sOffset_type& t_road_lanes_laneSection_lr_lane_visibility::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_visibility::sOffset_type& t_road_lanes_laneSection_lr_lane_visibility::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_visibility::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_visibility::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_visibility::forward_type& t_road_lanes_laneSection_lr_lane_visibility::
forward () const
{
  return this->forward_.get ();
}

t_road_lanes_laneSection_lr_lane_visibility::forward_type& t_road_lanes_laneSection_lr_lane_visibility::
forward ()
{
  return this->forward_.get ();
}

void t_road_lanes_laneSection_lr_lane_visibility::
forward (const forward_type& x)
{
  this->forward_.set (x);
}

void t_road_lanes_laneSection_lr_lane_visibility::
forward (::std::unique_ptr< forward_type > x)
{
  this->forward_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_visibility::back_type& t_road_lanes_laneSection_lr_lane_visibility::
back () const
{
  return this->back_.get ();
}

t_road_lanes_laneSection_lr_lane_visibility::back_type& t_road_lanes_laneSection_lr_lane_visibility::
back ()
{
  return this->back_.get ();
}

void t_road_lanes_laneSection_lr_lane_visibility::
back (const back_type& x)
{
  this->back_.set (x);
}

void t_road_lanes_laneSection_lr_lane_visibility::
back (::std::unique_ptr< back_type > x)
{
  this->back_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_visibility::left_type& t_road_lanes_laneSection_lr_lane_visibility::
left () const
{
  return this->left_.get ();
}

t_road_lanes_laneSection_lr_lane_visibility::left_type& t_road_lanes_laneSection_lr_lane_visibility::
left ()
{
  return this->left_.get ();
}

void t_road_lanes_laneSection_lr_lane_visibility::
left (const left_type& x)
{
  this->left_.set (x);
}

void t_road_lanes_laneSection_lr_lane_visibility::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_visibility::right_type& t_road_lanes_laneSection_lr_lane_visibility::
right () const
{
  return this->right_.get ();
}

t_road_lanes_laneSection_lr_lane_visibility::right_type& t_road_lanes_laneSection_lr_lane_visibility::
right ()
{
  return this->right_.get ();
}

void t_road_lanes_laneSection_lr_lane_visibility::
right (const right_type& x)
{
  this->right_.set (x);
}

void t_road_lanes_laneSection_lr_lane_visibility::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}


// t_road_lanes_laneSection_lr_lane_speed
// 

const t_road_lanes_laneSection_lr_lane_speed::userData_sequence& t_road_lanes_laneSection_lr_lane_speed::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_speed::userData_sequence& t_road_lanes_laneSection_lr_lane_speed::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_speed::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_speed::include_sequence& t_road_lanes_laneSection_lr_lane_speed::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_speed::include_sequence& t_road_lanes_laneSection_lr_lane_speed::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_speed::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_speed::dataQuality_optional& t_road_lanes_laneSection_lr_lane_speed::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_speed::dataQuality_optional& t_road_lanes_laneSection_lr_lane_speed::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_speed::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_speed::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_speed::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_speed::sOffset_type& t_road_lanes_laneSection_lr_lane_speed::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_speed::sOffset_type& t_road_lanes_laneSection_lr_lane_speed::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_speed::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_speed::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_speed::max_type& t_road_lanes_laneSection_lr_lane_speed::
fmax () const
{
  return this->fmax_.get ();
}

t_road_lanes_laneSection_lr_lane_speed::max_type& t_road_lanes_laneSection_lr_lane_speed::
fmax ()
{
  return this->fmax_.get ();
}

void t_road_lanes_laneSection_lr_lane_speed::
fmax (const max_type& x)
{
  this->fmax_.set (x);
}

void t_road_lanes_laneSection_lr_lane_speed::
fmax (::std::unique_ptr< max_type > x)
{
  this->fmax_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_speed::unit_optional& t_road_lanes_laneSection_lr_lane_speed::
unit () const
{
  return this->unit_;
}

t_road_lanes_laneSection_lr_lane_speed::unit_optional& t_road_lanes_laneSection_lr_lane_speed::
unit ()
{
  return this->unit_;
}

void t_road_lanes_laneSection_lr_lane_speed::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void t_road_lanes_laneSection_lr_lane_speed::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void t_road_lanes_laneSection_lr_lane_speed::
unit (::std::unique_ptr< unit_type > x)
{
  this->unit_.set (std::move (x));
}


// t_road_lanes_laneSection_lr_lane_access
// 

const t_road_lanes_laneSection_lr_lane_access::userData_sequence& t_road_lanes_laneSection_lr_lane_access::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_access::userData_sequence& t_road_lanes_laneSection_lr_lane_access::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_access::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_access::include_sequence& t_road_lanes_laneSection_lr_lane_access::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_access::include_sequence& t_road_lanes_laneSection_lr_lane_access::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_access::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_access::dataQuality_optional& t_road_lanes_laneSection_lr_lane_access::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_access::dataQuality_optional& t_road_lanes_laneSection_lr_lane_access::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_access::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_access::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_access::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_access::sOffset_type& t_road_lanes_laneSection_lr_lane_access::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_access::sOffset_type& t_road_lanes_laneSection_lr_lane_access::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_access::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_access::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_access::rule_type& t_road_lanes_laneSection_lr_lane_access::
rule () const
{
  return this->rule_.get ();
}

t_road_lanes_laneSection_lr_lane_access::rule_type& t_road_lanes_laneSection_lr_lane_access::
rule ()
{
  return this->rule_.get ();
}

void t_road_lanes_laneSection_lr_lane_access::
rule (const rule_type& x)
{
  this->rule_.set (x);
}

void t_road_lanes_laneSection_lr_lane_access::
rule (::std::unique_ptr< rule_type > x)
{
  this->rule_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_access::restriction_type& t_road_lanes_laneSection_lr_lane_access::
restriction () const
{
  return this->restriction_.get ();
}

t_road_lanes_laneSection_lr_lane_access::restriction_type& t_road_lanes_laneSection_lr_lane_access::
restriction ()
{
  return this->restriction_.get ();
}

void t_road_lanes_laneSection_lr_lane_access::
restriction (const restriction_type& x)
{
  this->restriction_.set (x);
}

void t_road_lanes_laneSection_lr_lane_access::
restriction (::std::unique_ptr< restriction_type > x)
{
  this->restriction_.set (std::move (x));
}


// e_road_lanes_laneSection_lr_lane_access_rule
// 

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (value v)
: ::xml_schema::string (_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[v])
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const char* v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const e_road_lanes_laneSection_lr_lane_access_rule& v,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_lanes_laneSection_lr_lane_access_rule& e_road_lanes_laneSection_lr_lane_access_rule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[v]);

  return *this;
}


// t_road_lanes_laneSection_lr_lane_height
// 

const t_road_lanes_laneSection_lr_lane_height::userData_sequence& t_road_lanes_laneSection_lr_lane_height::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_height::userData_sequence& t_road_lanes_laneSection_lr_lane_height::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_height::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_height::include_sequence& t_road_lanes_laneSection_lr_lane_height::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_height::include_sequence& t_road_lanes_laneSection_lr_lane_height::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_height::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_height::dataQuality_optional& t_road_lanes_laneSection_lr_lane_height::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_height::dataQuality_optional& t_road_lanes_laneSection_lr_lane_height::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_height::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_height::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_height::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_height::sOffset_type& t_road_lanes_laneSection_lr_lane_height::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_height::sOffset_type& t_road_lanes_laneSection_lr_lane_height::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_height::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_height::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_height::inner_type& t_road_lanes_laneSection_lr_lane_height::
inner () const
{
  return this->inner_.get ();
}

t_road_lanes_laneSection_lr_lane_height::inner_type& t_road_lanes_laneSection_lr_lane_height::
inner ()
{
  return this->inner_.get ();
}

void t_road_lanes_laneSection_lr_lane_height::
inner (const inner_type& x)
{
  this->inner_.set (x);
}

const t_road_lanes_laneSection_lr_lane_height::outer_type& t_road_lanes_laneSection_lr_lane_height::
outer () const
{
  return this->outer_.get ();
}

t_road_lanes_laneSection_lr_lane_height::outer_type& t_road_lanes_laneSection_lr_lane_height::
outer ()
{
  return this->outer_.get ();
}

void t_road_lanes_laneSection_lr_lane_height::
outer (const outer_type& x)
{
  this->outer_.set (x);
}


// t_road_lanes_laneSection_lr_lane_rule
// 

const t_road_lanes_laneSection_lr_lane_rule::userData_sequence& t_road_lanes_laneSection_lr_lane_rule::
userData () const
{
  return this->userData_;
}

t_road_lanes_laneSection_lr_lane_rule::userData_sequence& t_road_lanes_laneSection_lr_lane_rule::
userData ()
{
  return this->userData_;
}

void t_road_lanes_laneSection_lr_lane_rule::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_lanes_laneSection_lr_lane_rule::include_sequence& t_road_lanes_laneSection_lr_lane_rule::
include () const
{
  return this->include_;
}

t_road_lanes_laneSection_lr_lane_rule::include_sequence& t_road_lanes_laneSection_lr_lane_rule::
include ()
{
  return this->include_;
}

void t_road_lanes_laneSection_lr_lane_rule::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_lanes_laneSection_lr_lane_rule::dataQuality_optional& t_road_lanes_laneSection_lr_lane_rule::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_lanes_laneSection_lr_lane_rule::dataQuality_optional& t_road_lanes_laneSection_lr_lane_rule::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_lanes_laneSection_lr_lane_rule::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_lanes_laneSection_lr_lane_rule::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_lanes_laneSection_lr_lane_rule::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_rule::sOffset_type& t_road_lanes_laneSection_lr_lane_rule::
sOffset () const
{
  return this->sOffset_.get ();
}

t_road_lanes_laneSection_lr_lane_rule::sOffset_type& t_road_lanes_laneSection_lr_lane_rule::
sOffset ()
{
  return this->sOffset_.get ();
}

void t_road_lanes_laneSection_lr_lane_rule::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_lanes_laneSection_lr_lane_rule::
sOffset (::std::unique_ptr< sOffset_type > x)
{
  this->sOffset_.set (std::move (x));
}

const t_road_lanes_laneSection_lr_lane_rule::value_type& t_road_lanes_laneSection_lr_lane_rule::
value () const
{
  return this->value_.get ();
}

t_road_lanes_laneSection_lr_lane_rule::value_type& t_road_lanes_laneSection_lr_lane_rule::
value ()
{
  return this->value_.get ();
}

void t_road_lanes_laneSection_lr_lane_rule::
value (const value_type& x)
{
  this->value_.set (x);
}

void t_road_lanes_laneSection_lr_lane_rule::
value (::std::unique_ptr< value_type > x)
{
  this->value_.set (std::move (x));
}


// t_road_objects
// 

const t_road_objects::object_sequence& t_road_objects::
object () const
{
  return this->object_;
}

t_road_objects::object_sequence& t_road_objects::
object ()
{
  return this->object_;
}

void t_road_objects::
object (const object_sequence& s)
{
  this->object_ = s;
}

const t_road_objects::objectReference_sequence& t_road_objects::
objectReference () const
{
  return this->objectReference_;
}

t_road_objects::objectReference_sequence& t_road_objects::
objectReference ()
{
  return this->objectReference_;
}

void t_road_objects::
objectReference (const objectReference_sequence& s)
{
  this->objectReference_ = s;
}

const t_road_objects::tunnel_sequence& t_road_objects::
tunnel () const
{
  return this->tunnel_;
}

t_road_objects::tunnel_sequence& t_road_objects::
tunnel ()
{
  return this->tunnel_;
}

void t_road_objects::
tunnel (const tunnel_sequence& s)
{
  this->tunnel_ = s;
}

const t_road_objects::bridge_sequence& t_road_objects::
bridge () const
{
  return this->bridge_;
}

t_road_objects::bridge_sequence& t_road_objects::
bridge ()
{
  return this->bridge_;
}

void t_road_objects::
bridge (const bridge_sequence& s)
{
  this->bridge_ = s;
}

const t_road_objects::userData_sequence& t_road_objects::
userData () const
{
  return this->userData_;
}

t_road_objects::userData_sequence& t_road_objects::
userData ()
{
  return this->userData_;
}

void t_road_objects::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects::include_sequence& t_road_objects::
include () const
{
  return this->include_;
}

t_road_objects::include_sequence& t_road_objects::
include ()
{
  return this->include_;
}

void t_road_objects::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects::dataQuality_optional& t_road_objects::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects::dataQuality_optional& t_road_objects::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_objects_object
// 

const t_road_objects_object::repeat_optional& t_road_objects_object::
repeat () const
{
  return this->repeat_;
}

t_road_objects_object::repeat_optional& t_road_objects_object::
repeat ()
{
  return this->repeat_;
}

void t_road_objects_object::
repeat (const repeat_type& x)
{
  this->repeat_.set (x);
}

void t_road_objects_object::
repeat (const repeat_optional& x)
{
  this->repeat_ = x;
}

void t_road_objects_object::
repeat (::std::unique_ptr< repeat_type > x)
{
  this->repeat_.set (std::move (x));
}

const t_road_objects_object::outline_optional& t_road_objects_object::
outline () const
{
  return this->outline_;
}

t_road_objects_object::outline_optional& t_road_objects_object::
outline ()
{
  return this->outline_;
}

void t_road_objects_object::
outline (const outline_type& x)
{
  this->outline_.set (x);
}

void t_road_objects_object::
outline (const outline_optional& x)
{
  this->outline_ = x;
}

void t_road_objects_object::
outline (::std::unique_ptr< outline_type > x)
{
  this->outline_.set (std::move (x));
}

const t_road_objects_object::outlines_optional& t_road_objects_object::
outlines () const
{
  return this->outlines_;
}

t_road_objects_object::outlines_optional& t_road_objects_object::
outlines ()
{
  return this->outlines_;
}

void t_road_objects_object::
outlines (const outlines_type& x)
{
  this->outlines_.set (x);
}

void t_road_objects_object::
outlines (const outlines_optional& x)
{
  this->outlines_ = x;
}

void t_road_objects_object::
outlines (::std::unique_ptr< outlines_type > x)
{
  this->outlines_.set (std::move (x));
}

const t_road_objects_object::material_sequence& t_road_objects_object::
material () const
{
  return this->material_;
}

t_road_objects_object::material_sequence& t_road_objects_object::
material ()
{
  return this->material_;
}

void t_road_objects_object::
material (const material_sequence& s)
{
  this->material_ = s;
}

const t_road_objects_object::validity_sequence& t_road_objects_object::
validity () const
{
  return this->validity_;
}

t_road_objects_object::validity_sequence& t_road_objects_object::
validity ()
{
  return this->validity_;
}

void t_road_objects_object::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_object::parkingSpace_optional& t_road_objects_object::
parkingSpace () const
{
  return this->parkingSpace_;
}

t_road_objects_object::parkingSpace_optional& t_road_objects_object::
parkingSpace ()
{
  return this->parkingSpace_;
}

void t_road_objects_object::
parkingSpace (const parkingSpace_type& x)
{
  this->parkingSpace_.set (x);
}

void t_road_objects_object::
parkingSpace (const parkingSpace_optional& x)
{
  this->parkingSpace_ = x;
}

void t_road_objects_object::
parkingSpace (::std::unique_ptr< parkingSpace_type > x)
{
  this->parkingSpace_.set (std::move (x));
}

const t_road_objects_object::markings_optional& t_road_objects_object::
markings () const
{
  return this->markings_;
}

t_road_objects_object::markings_optional& t_road_objects_object::
markings ()
{
  return this->markings_;
}

void t_road_objects_object::
markings (const markings_type& x)
{
  this->markings_.set (x);
}

void t_road_objects_object::
markings (const markings_optional& x)
{
  this->markings_ = x;
}

void t_road_objects_object::
markings (::std::unique_ptr< markings_type > x)
{
  this->markings_.set (std::move (x));
}

const t_road_objects_object::borders_optional& t_road_objects_object::
borders () const
{
  return this->borders_;
}

t_road_objects_object::borders_optional& t_road_objects_object::
borders ()
{
  return this->borders_;
}

void t_road_objects_object::
borders (const borders_type& x)
{
  this->borders_.set (x);
}

void t_road_objects_object::
borders (const borders_optional& x)
{
  this->borders_ = x;
}

void t_road_objects_object::
borders (::std::unique_ptr< borders_type > x)
{
  this->borders_.set (std::move (x));
}

const t_road_objects_object::userData_sequence& t_road_objects_object::
userData () const
{
  return this->userData_;
}

t_road_objects_object::userData_sequence& t_road_objects_object::
userData ()
{
  return this->userData_;
}

void t_road_objects_object::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object::include_sequence& t_road_objects_object::
include () const
{
  return this->include_;
}

t_road_objects_object::include_sequence& t_road_objects_object::
include ()
{
  return this->include_;
}

void t_road_objects_object::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object::dataQuality_optional& t_road_objects_object::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object::dataQuality_optional& t_road_objects_object::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object::type_optional& t_road_objects_object::
type () const
{
  return this->type_;
}

t_road_objects_object::type_optional& t_road_objects_object::
type ()
{
  return this->type_;
}

void t_road_objects_object::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_object::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_road_objects_object::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_objects_object::subtype_optional& t_road_objects_object::
subtype () const
{
  return this->subtype_;
}

t_road_objects_object::subtype_optional& t_road_objects_object::
subtype ()
{
  return this->subtype_;
}

void t_road_objects_object::
subtype (const subtype_type& x)
{
  this->subtype_.set (x);
}

void t_road_objects_object::
subtype (const subtype_optional& x)
{
  this->subtype_ = x;
}

void t_road_objects_object::
subtype (::std::unique_ptr< subtype_type > x)
{
  this->subtype_.set (std::move (x));
}

const t_road_objects_object::dynamic_type& t_road_objects_object::
dynamic () const
{
  return this->dynamic_.get ();
}

t_road_objects_object::dynamic_type& t_road_objects_object::
dynamic ()
{
  return this->dynamic_.get ();
}

void t_road_objects_object::
dynamic (const dynamic_type& x)
{
  this->dynamic_.set (x);
}

void t_road_objects_object::
dynamic (::std::unique_ptr< dynamic_type > x)
{
  this->dynamic_.set (std::move (x));
}

const t_road_objects_object::name_optional& t_road_objects_object::
name () const
{
  return this->name_;
}

t_road_objects_object::name_optional& t_road_objects_object::
name ()
{
  return this->name_;
}

void t_road_objects_object::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_objects_object::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_objects_object::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road_objects_object::id_type& t_road_objects_object::
id () const
{
  return this->id_.get ();
}

t_road_objects_object::id_type& t_road_objects_object::
id ()
{
  return this->id_.get ();
}

void t_road_objects_object::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_object::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_objects_object::s_type& t_road_objects_object::
s () const
{
  return this->s_.get ();
}

t_road_objects_object::s_type& t_road_objects_object::
s ()
{
  return this->s_.get ();
}

void t_road_objects_object::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_object::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_objects_object::t_type& t_road_objects_object::
t () const
{
  return this->t_.get ();
}

t_road_objects_object::t_type& t_road_objects_object::
t ()
{
  return this->t_.get ();
}

void t_road_objects_object::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_objects_object::zOffset_type& t_road_objects_object::
zOffset () const
{
  return this->zOffset_.get ();
}

t_road_objects_object::zOffset_type& t_road_objects_object::
zOffset ()
{
  return this->zOffset_.get ();
}

void t_road_objects_object::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

const t_road_objects_object::validLength_type& t_road_objects_object::
validLength () const
{
  return this->validLength_.get ();
}

t_road_objects_object::validLength_type& t_road_objects_object::
validLength ()
{
  return this->validLength_.get ();
}

void t_road_objects_object::
validLength (const validLength_type& x)
{
  this->validLength_.set (x);
}

void t_road_objects_object::
validLength (::std::unique_ptr< validLength_type > x)
{
  this->validLength_.set (std::move (x));
}

const t_road_objects_object::orientation_type& t_road_objects_object::
orientation () const
{
  return this->orientation_.get ();
}

t_road_objects_object::orientation_type& t_road_objects_object::
orientation ()
{
  return this->orientation_.get ();
}

void t_road_objects_object::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_objects_object::
orientation (::std::unique_ptr< orientation_type > x)
{
  this->orientation_.set (std::move (x));
}

const t_road_objects_object::hdg_type& t_road_objects_object::
hdg () const
{
  return this->hdg_.get ();
}

t_road_objects_object::hdg_type& t_road_objects_object::
hdg ()
{
  return this->hdg_.get ();
}

void t_road_objects_object::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}

const t_road_objects_object::pitch_type& t_road_objects_object::
pitch () const
{
  return this->pitch_.get ();
}

t_road_objects_object::pitch_type& t_road_objects_object::
pitch ()
{
  return this->pitch_.get ();
}

void t_road_objects_object::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

const t_road_objects_object::roll_type& t_road_objects_object::
roll () const
{
  return this->roll_.get ();
}

t_road_objects_object::roll_type& t_road_objects_object::
roll ()
{
  return this->roll_.get ();
}

void t_road_objects_object::
roll (const roll_type& x)
{
  this->roll_.set (x);
}

const t_road_objects_object::height_type& t_road_objects_object::
height () const
{
  return this->height_.get ();
}

t_road_objects_object::height_type& t_road_objects_object::
height ()
{
  return this->height_.get ();
}

void t_road_objects_object::
height (const height_type& x)
{
  this->height_.set (x);
}

const t_road_objects_object::length_optional& t_road_objects_object::
length () const
{
  return this->length_;
}

t_road_objects_object::length_optional& t_road_objects_object::
length ()
{
  return this->length_;
}

void t_road_objects_object::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_object::
length (const length_optional& x)
{
  this->length_ = x;
}

const t_road_objects_object::width_optional& t_road_objects_object::
width () const
{
  return this->width_;
}

t_road_objects_object::width_optional& t_road_objects_object::
width ()
{
  return this->width_;
}

void t_road_objects_object::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_objects_object::
width (const width_optional& x)
{
  this->width_ = x;
}

const t_road_objects_object::radius_optional& t_road_objects_object::
radius () const
{
  return this->radius_;
}

t_road_objects_object::radius_optional& t_road_objects_object::
radius ()
{
  return this->radius_;
}

void t_road_objects_object::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void t_road_objects_object::
radius (const radius_optional& x)
{
  this->radius_ = x;
}


// t_road_objects_object_repeat
// 

const t_road_objects_object_repeat::userData_sequence& t_road_objects_object_repeat::
userData () const
{
  return this->userData_;
}

t_road_objects_object_repeat::userData_sequence& t_road_objects_object_repeat::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_repeat::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_repeat::include_sequence& t_road_objects_object_repeat::
include () const
{
  return this->include_;
}

t_road_objects_object_repeat::include_sequence& t_road_objects_object_repeat::
include ()
{
  return this->include_;
}

void t_road_objects_object_repeat::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_repeat::dataQuality_optional& t_road_objects_object_repeat::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_repeat::dataQuality_optional& t_road_objects_object_repeat::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_repeat::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_repeat::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_repeat::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_repeat::s_type& t_road_objects_object_repeat::
s () const
{
  return this->s_.get ();
}

t_road_objects_object_repeat::s_type& t_road_objects_object_repeat::
s ()
{
  return this->s_.get ();
}

void t_road_objects_object_repeat::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_object_repeat::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_objects_object_repeat::length_type& t_road_objects_object_repeat::
length () const
{
  return this->length_.get ();
}

t_road_objects_object_repeat::length_type& t_road_objects_object_repeat::
length ()
{
  return this->length_.get ();
}

void t_road_objects_object_repeat::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_object_repeat::
length (::std::unique_ptr< length_type > x)
{
  this->length_.set (std::move (x));
}

const t_road_objects_object_repeat::distance_type& t_road_objects_object_repeat::
distance () const
{
  return this->distance_.get ();
}

t_road_objects_object_repeat::distance_type& t_road_objects_object_repeat::
distance ()
{
  return this->distance_.get ();
}

void t_road_objects_object_repeat::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

void t_road_objects_object_repeat::
distance (::std::unique_ptr< distance_type > x)
{
  this->distance_.set (std::move (x));
}

const t_road_objects_object_repeat::tStart_type& t_road_objects_object_repeat::
tStart () const
{
  return this->tStart_.get ();
}

t_road_objects_object_repeat::tStart_type& t_road_objects_object_repeat::
tStart ()
{
  return this->tStart_.get ();
}

void t_road_objects_object_repeat::
tStart (const tStart_type& x)
{
  this->tStart_.set (x);
}

const t_road_objects_object_repeat::tEnd_type& t_road_objects_object_repeat::
tEnd () const
{
  return this->tEnd_.get ();
}

t_road_objects_object_repeat::tEnd_type& t_road_objects_object_repeat::
tEnd ()
{
  return this->tEnd_.get ();
}

void t_road_objects_object_repeat::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

const t_road_objects_object_repeat::heightStart_type& t_road_objects_object_repeat::
heightStart () const
{
  return this->heightStart_.get ();
}

t_road_objects_object_repeat::heightStart_type& t_road_objects_object_repeat::
heightStart ()
{
  return this->heightStart_.get ();
}

void t_road_objects_object_repeat::
heightStart (const heightStart_type& x)
{
  this->heightStart_.set (x);
}

const t_road_objects_object_repeat::heightEnd_type& t_road_objects_object_repeat::
heightEnd () const
{
  return this->heightEnd_.get ();
}

t_road_objects_object_repeat::heightEnd_type& t_road_objects_object_repeat::
heightEnd ()
{
  return this->heightEnd_.get ();
}

void t_road_objects_object_repeat::
heightEnd (const heightEnd_type& x)
{
  this->heightEnd_.set (x);
}

const t_road_objects_object_repeat::zOffsetStart_type& t_road_objects_object_repeat::
zOffsetStart () const
{
  return this->zOffsetStart_.get ();
}

t_road_objects_object_repeat::zOffsetStart_type& t_road_objects_object_repeat::
zOffsetStart ()
{
  return this->zOffsetStart_.get ();
}

void t_road_objects_object_repeat::
zOffsetStart (const zOffsetStart_type& x)
{
  this->zOffsetStart_.set (x);
}

const t_road_objects_object_repeat::zOffsetEnd_type& t_road_objects_object_repeat::
zOffsetEnd () const
{
  return this->zOffsetEnd_.get ();
}

t_road_objects_object_repeat::zOffsetEnd_type& t_road_objects_object_repeat::
zOffsetEnd ()
{
  return this->zOffsetEnd_.get ();
}

void t_road_objects_object_repeat::
zOffsetEnd (const zOffsetEnd_type& x)
{
  this->zOffsetEnd_.set (x);
}

const t_road_objects_object_repeat::widthStart_type& t_road_objects_object_repeat::
widthStart () const
{
  return this->widthStart_.get ();
}

t_road_objects_object_repeat::widthStart_type& t_road_objects_object_repeat::
widthStart ()
{
  return this->widthStart_.get ();
}

void t_road_objects_object_repeat::
widthStart (const widthStart_type& x)
{
  this->widthStart_.set (x);
}

void t_road_objects_object_repeat::
widthStart (::std::unique_ptr< widthStart_type > x)
{
  this->widthStart_.set (std::move (x));
}

const t_road_objects_object_repeat::widthEnd_type& t_road_objects_object_repeat::
widthEnd () const
{
  return this->widthEnd_.get ();
}

t_road_objects_object_repeat::widthEnd_type& t_road_objects_object_repeat::
widthEnd ()
{
  return this->widthEnd_.get ();
}

void t_road_objects_object_repeat::
widthEnd (const widthEnd_type& x)
{
  this->widthEnd_.set (x);
}

void t_road_objects_object_repeat::
widthEnd (::std::unique_ptr< widthEnd_type > x)
{
  this->widthEnd_.set (std::move (x));
}

const t_road_objects_object_repeat::lengthStart_optional& t_road_objects_object_repeat::
lengthStart () const
{
  return this->lengthStart_;
}

t_road_objects_object_repeat::lengthStart_optional& t_road_objects_object_repeat::
lengthStart ()
{
  return this->lengthStart_;
}

void t_road_objects_object_repeat::
lengthStart (const lengthStart_type& x)
{
  this->lengthStart_.set (x);
}

void t_road_objects_object_repeat::
lengthStart (const lengthStart_optional& x)
{
  this->lengthStart_ = x;
}

void t_road_objects_object_repeat::
lengthStart (::std::unique_ptr< lengthStart_type > x)
{
  this->lengthStart_.set (std::move (x));
}

const t_road_objects_object_repeat::lengthEnd_optional& t_road_objects_object_repeat::
lengthEnd () const
{
  return this->lengthEnd_;
}

t_road_objects_object_repeat::lengthEnd_optional& t_road_objects_object_repeat::
lengthEnd ()
{
  return this->lengthEnd_;
}

void t_road_objects_object_repeat::
lengthEnd (const lengthEnd_type& x)
{
  this->lengthEnd_.set (x);
}

void t_road_objects_object_repeat::
lengthEnd (const lengthEnd_optional& x)
{
  this->lengthEnd_ = x;
}

void t_road_objects_object_repeat::
lengthEnd (::std::unique_ptr< lengthEnd_type > x)
{
  this->lengthEnd_.set (std::move (x));
}

const t_road_objects_object_repeat::radiusStart_optional& t_road_objects_object_repeat::
radiusStart () const
{
  return this->radiusStart_;
}

t_road_objects_object_repeat::radiusStart_optional& t_road_objects_object_repeat::
radiusStart ()
{
  return this->radiusStart_;
}

void t_road_objects_object_repeat::
radiusStart (const radiusStart_type& x)
{
  this->radiusStart_.set (x);
}

void t_road_objects_object_repeat::
radiusStart (const radiusStart_optional& x)
{
  this->radiusStart_ = x;
}

void t_road_objects_object_repeat::
radiusStart (::std::unique_ptr< radiusStart_type > x)
{
  this->radiusStart_.set (std::move (x));
}

const t_road_objects_object_repeat::radiusEnd_optional& t_road_objects_object_repeat::
radiusEnd () const
{
  return this->radiusEnd_;
}

t_road_objects_object_repeat::radiusEnd_optional& t_road_objects_object_repeat::
radiusEnd ()
{
  return this->radiusEnd_;
}

void t_road_objects_object_repeat::
radiusEnd (const radiusEnd_type& x)
{
  this->radiusEnd_.set (x);
}

void t_road_objects_object_repeat::
radiusEnd (const radiusEnd_optional& x)
{
  this->radiusEnd_ = x;
}

void t_road_objects_object_repeat::
radiusEnd (::std::unique_ptr< radiusEnd_type > x)
{
  this->radiusEnd_.set (std::move (x));
}


// t_road_objects_object_outlines
// 

const t_road_objects_object_outlines::outline_sequence& t_road_objects_object_outlines::
outline () const
{
  return this->outline_;
}

t_road_objects_object_outlines::outline_sequence& t_road_objects_object_outlines::
outline ()
{
  return this->outline_;
}

void t_road_objects_object_outlines::
outline (const outline_sequence& s)
{
  this->outline_ = s;
}

const t_road_objects_object_outlines::userData_sequence& t_road_objects_object_outlines::
userData () const
{
  return this->userData_;
}

t_road_objects_object_outlines::userData_sequence& t_road_objects_object_outlines::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_outlines::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_outlines::include_sequence& t_road_objects_object_outlines::
include () const
{
  return this->include_;
}

t_road_objects_object_outlines::include_sequence& t_road_objects_object_outlines::
include ()
{
  return this->include_;
}

void t_road_objects_object_outlines::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_outlines::dataQuality_optional& t_road_objects_object_outlines::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_outlines::dataQuality_optional& t_road_objects_object_outlines::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_outlines::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_outlines::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_outlines::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_objects_object_outlines_outline
// 

const t_road_objects_object_outlines_outline::cornerRoad_sequence& t_road_objects_object_outlines_outline::
cornerRoad () const
{
  return this->cornerRoad_;
}

t_road_objects_object_outlines_outline::cornerRoad_sequence& t_road_objects_object_outlines_outline::
cornerRoad ()
{
  return this->cornerRoad_;
}

void t_road_objects_object_outlines_outline::
cornerRoad (const cornerRoad_sequence& s)
{
  this->cornerRoad_ = s;
}

const t_road_objects_object_outlines_outline::cornerLocal_sequence& t_road_objects_object_outlines_outline::
cornerLocal () const
{
  return this->cornerLocal_;
}

t_road_objects_object_outlines_outline::cornerLocal_sequence& t_road_objects_object_outlines_outline::
cornerLocal ()
{
  return this->cornerLocal_;
}

void t_road_objects_object_outlines_outline::
cornerLocal (const cornerLocal_sequence& s)
{
  this->cornerLocal_ = s;
}

const t_road_objects_object_outlines_outline::userData_sequence& t_road_objects_object_outlines_outline::
userData () const
{
  return this->userData_;
}

t_road_objects_object_outlines_outline::userData_sequence& t_road_objects_object_outlines_outline::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_outlines_outline::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_outlines_outline::include_sequence& t_road_objects_object_outlines_outline::
include () const
{
  return this->include_;
}

t_road_objects_object_outlines_outline::include_sequence& t_road_objects_object_outlines_outline::
include ()
{
  return this->include_;
}

void t_road_objects_object_outlines_outline::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_outlines_outline::dataQuality_optional& t_road_objects_object_outlines_outline::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_outlines_outline::dataQuality_optional& t_road_objects_object_outlines_outline::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_outlines_outline::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_outlines_outline::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_outlines_outline::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_outlines_outline::id_type& t_road_objects_object_outlines_outline::
id () const
{
  return this->id_.get ();
}

t_road_objects_object_outlines_outline::id_type& t_road_objects_object_outlines_outline::
id ()
{
  return this->id_.get ();
}

void t_road_objects_object_outlines_outline::
id (const id_type& x)
{
  this->id_.set (x);
}

const t_road_objects_object_outlines_outline::fillType_type& t_road_objects_object_outlines_outline::
fillType () const
{
  return this->fillType_.get ();
}

t_road_objects_object_outlines_outline::fillType_type& t_road_objects_object_outlines_outline::
fillType ()
{
  return this->fillType_.get ();
}

void t_road_objects_object_outlines_outline::
fillType (const fillType_type& x)
{
  this->fillType_.set (x);
}

void t_road_objects_object_outlines_outline::
fillType (::std::unique_ptr< fillType_type > x)
{
  this->fillType_.set (std::move (x));
}

const t_road_objects_object_outlines_outline::outer_type& t_road_objects_object_outlines_outline::
outer () const
{
  return this->outer_.get ();
}

t_road_objects_object_outlines_outline::outer_type& t_road_objects_object_outlines_outline::
outer ()
{
  return this->outer_.get ();
}

void t_road_objects_object_outlines_outline::
outer (const outer_type& x)
{
  this->outer_.set (x);
}

void t_road_objects_object_outlines_outline::
outer (::std::unique_ptr< outer_type > x)
{
  this->outer_.set (std::move (x));
}

const t_road_objects_object_outlines_outline::closed_type& t_road_objects_object_outlines_outline::
closed () const
{
  return this->closed_.get ();
}

t_road_objects_object_outlines_outline::closed_type& t_road_objects_object_outlines_outline::
closed ()
{
  return this->closed_.get ();
}

void t_road_objects_object_outlines_outline::
closed (const closed_type& x)
{
  this->closed_.set (x);
}

void t_road_objects_object_outlines_outline::
closed (::std::unique_ptr< closed_type > x)
{
  this->closed_.set (std::move (x));
}

const t_road_objects_object_outlines_outline::laneType_type& t_road_objects_object_outlines_outline::
laneType () const
{
  return this->laneType_.get ();
}

t_road_objects_object_outlines_outline::laneType_type& t_road_objects_object_outlines_outline::
laneType ()
{
  return this->laneType_.get ();
}

void t_road_objects_object_outlines_outline::
laneType (const laneType_type& x)
{
  this->laneType_.set (x);
}

void t_road_objects_object_outlines_outline::
laneType (::std::unique_ptr< laneType_type > x)
{
  this->laneType_.set (std::move (x));
}


// t_road_objects_object_outlines_outline_cornerRoad
// 

const t_road_objects_object_outlines_outline_cornerRoad::userData_sequence& t_road_objects_object_outlines_outline_cornerRoad::
userData () const
{
  return this->userData_;
}

t_road_objects_object_outlines_outline_cornerRoad::userData_sequence& t_road_objects_object_outlines_outline_cornerRoad::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_outlines_outline_cornerRoad::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_outlines_outline_cornerRoad::include_sequence& t_road_objects_object_outlines_outline_cornerRoad::
include () const
{
  return this->include_;
}

t_road_objects_object_outlines_outline_cornerRoad::include_sequence& t_road_objects_object_outlines_outline_cornerRoad::
include ()
{
  return this->include_;
}

void t_road_objects_object_outlines_outline_cornerRoad::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_outlines_outline_cornerRoad::dataQuality_optional& t_road_objects_object_outlines_outline_cornerRoad::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_outlines_outline_cornerRoad::dataQuality_optional& t_road_objects_object_outlines_outline_cornerRoad::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_outlines_outline_cornerRoad::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_outlines_outline_cornerRoad::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_outlines_outline_cornerRoad::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_outlines_outline_cornerRoad::s_type& t_road_objects_object_outlines_outline_cornerRoad::
s () const
{
  return this->s_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::s_type& t_road_objects_object_outlines_outline_cornerRoad::
s ()
{
  return this->s_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_object_outlines_outline_cornerRoad::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_objects_object_outlines_outline_cornerRoad::t_type& t_road_objects_object_outlines_outline_cornerRoad::
t () const
{
  return this->t_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::t_type& t_road_objects_object_outlines_outline_cornerRoad::
t ()
{
  return this->t_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_objects_object_outlines_outline_cornerRoad::dz_type& t_road_objects_object_outlines_outline_cornerRoad::
dz () const
{
  return this->dz_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::dz_type& t_road_objects_object_outlines_outline_cornerRoad::
dz ()
{
  return this->dz_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
dz (const dz_type& x)
{
  this->dz_.set (x);
}

const t_road_objects_object_outlines_outline_cornerRoad::height_type& t_road_objects_object_outlines_outline_cornerRoad::
height () const
{
  return this->height_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::height_type& t_road_objects_object_outlines_outline_cornerRoad::
height ()
{
  return this->height_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
height (const height_type& x)
{
  this->height_.set (x);
}

const t_road_objects_object_outlines_outline_cornerRoad::id_type& t_road_objects_object_outlines_outline_cornerRoad::
id () const
{
  return this->id_.get ();
}

t_road_objects_object_outlines_outline_cornerRoad::id_type& t_road_objects_object_outlines_outline_cornerRoad::
id ()
{
  return this->id_.get ();
}

void t_road_objects_object_outlines_outline_cornerRoad::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_objects_object_outlines_outline_cornerLocal
// 

const t_road_objects_object_outlines_outline_cornerLocal::userData_sequence& t_road_objects_object_outlines_outline_cornerLocal::
userData () const
{
  return this->userData_;
}

t_road_objects_object_outlines_outline_cornerLocal::userData_sequence& t_road_objects_object_outlines_outline_cornerLocal::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_outlines_outline_cornerLocal::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_outlines_outline_cornerLocal::include_sequence& t_road_objects_object_outlines_outline_cornerLocal::
include () const
{
  return this->include_;
}

t_road_objects_object_outlines_outline_cornerLocal::include_sequence& t_road_objects_object_outlines_outline_cornerLocal::
include ()
{
  return this->include_;
}

void t_road_objects_object_outlines_outline_cornerLocal::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_outlines_outline_cornerLocal::dataQuality_optional& t_road_objects_object_outlines_outline_cornerLocal::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_outlines_outline_cornerLocal::dataQuality_optional& t_road_objects_object_outlines_outline_cornerLocal::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_outlines_outline_cornerLocal::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_outlines_outline_cornerLocal::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_outlines_outline_cornerLocal::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_outlines_outline_cornerLocal::u_type& t_road_objects_object_outlines_outline_cornerLocal::
u () const
{
  return this->u_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::u_type& t_road_objects_object_outlines_outline_cornerLocal::
u ()
{
  return this->u_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
u (const u_type& x)
{
  this->u_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::v_type& t_road_objects_object_outlines_outline_cornerLocal::
v () const
{
  return this->v_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::v_type& t_road_objects_object_outlines_outline_cornerLocal::
v ()
{
  return this->v_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
v (const v_type& x)
{
  this->v_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::z_type& t_road_objects_object_outlines_outline_cornerLocal::
z () const
{
  return this->z_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::z_type& t_road_objects_object_outlines_outline_cornerLocal::
z ()
{
  return this->z_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
z (const z_type& x)
{
  this->z_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::height_type& t_road_objects_object_outlines_outline_cornerLocal::
height () const
{
  return this->height_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::height_type& t_road_objects_object_outlines_outline_cornerLocal::
height ()
{
  return this->height_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
height (const height_type& x)
{
  this->height_.set (x);
}

const t_road_objects_object_outlines_outline_cornerLocal::id_type& t_road_objects_object_outlines_outline_cornerLocal::
id () const
{
  return this->id_.get ();
}

t_road_objects_object_outlines_outline_cornerLocal::id_type& t_road_objects_object_outlines_outline_cornerLocal::
id ()
{
  return this->id_.get ();
}

void t_road_objects_object_outlines_outline_cornerLocal::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_objects_object_material
// 

const t_road_objects_object_material::userData_sequence& t_road_objects_object_material::
userData () const
{
  return this->userData_;
}

t_road_objects_object_material::userData_sequence& t_road_objects_object_material::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_material::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_material::include_sequence& t_road_objects_object_material::
include () const
{
  return this->include_;
}

t_road_objects_object_material::include_sequence& t_road_objects_object_material::
include ()
{
  return this->include_;
}

void t_road_objects_object_material::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_material::dataQuality_optional& t_road_objects_object_material::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_material::dataQuality_optional& t_road_objects_object_material::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_material::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_material::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_material::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_material::surface_optional& t_road_objects_object_material::
surface () const
{
  return this->surface_;
}

t_road_objects_object_material::surface_optional& t_road_objects_object_material::
surface ()
{
  return this->surface_;
}

void t_road_objects_object_material::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void t_road_objects_object_material::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void t_road_objects_object_material::
surface (::std::unique_ptr< surface_type > x)
{
  this->surface_.set (std::move (x));
}

const t_road_objects_object_material::friction_optional& t_road_objects_object_material::
friction () const
{
  return this->friction_;
}

t_road_objects_object_material::friction_optional& t_road_objects_object_material::
friction ()
{
  return this->friction_;
}

void t_road_objects_object_material::
friction (const friction_type& x)
{
  this->friction_.set (x);
}

void t_road_objects_object_material::
friction (const friction_optional& x)
{
  this->friction_ = x;
}

void t_road_objects_object_material::
friction (::std::unique_ptr< friction_type > x)
{
  this->friction_.set (std::move (x));
}

const t_road_objects_object_material::roughness_optional& t_road_objects_object_material::
roughness () const
{
  return this->roughness_;
}

t_road_objects_object_material::roughness_optional& t_road_objects_object_material::
roughness ()
{
  return this->roughness_;
}

void t_road_objects_object_material::
roughness (const roughness_type& x)
{
  this->roughness_.set (x);
}

void t_road_objects_object_material::
roughness (const roughness_optional& x)
{
  this->roughness_ = x;
}

void t_road_objects_object_material::
roughness (::std::unique_ptr< roughness_type > x)
{
  this->roughness_.set (std::move (x));
}


// t_road_objects_object_laneValidity
// 

const t_road_objects_object_laneValidity::userData_sequence& t_road_objects_object_laneValidity::
userData () const
{
  return this->userData_;
}

t_road_objects_object_laneValidity::userData_sequence& t_road_objects_object_laneValidity::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_laneValidity::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_laneValidity::include_sequence& t_road_objects_object_laneValidity::
include () const
{
  return this->include_;
}

t_road_objects_object_laneValidity::include_sequence& t_road_objects_object_laneValidity::
include ()
{
  return this->include_;
}

void t_road_objects_object_laneValidity::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_laneValidity::dataQuality_optional& t_road_objects_object_laneValidity::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_laneValidity::dataQuality_optional& t_road_objects_object_laneValidity::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_laneValidity::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_laneValidity::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_laneValidity::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_laneValidity::fromLane_type& t_road_objects_object_laneValidity::
fromLane () const
{
  return this->fromLane_.get ();
}

t_road_objects_object_laneValidity::fromLane_type& t_road_objects_object_laneValidity::
fromLane ()
{
  return this->fromLane_.get ();
}

void t_road_objects_object_laneValidity::
fromLane (const fromLane_type& x)
{
  this->fromLane_.set (x);
}

const t_road_objects_object_laneValidity::toLane_type& t_road_objects_object_laneValidity::
toLane () const
{
  return this->toLane_.get ();
}

t_road_objects_object_laneValidity::toLane_type& t_road_objects_object_laneValidity::
toLane ()
{
  return this->toLane_.get ();
}

void t_road_objects_object_laneValidity::
toLane (const toLane_type& x)
{
  this->toLane_.set (x);
}


// t_road_objects_object_parkingSpace
// 

const t_road_objects_object_parkingSpace::userData_sequence& t_road_objects_object_parkingSpace::
userData () const
{
  return this->userData_;
}

t_road_objects_object_parkingSpace::userData_sequence& t_road_objects_object_parkingSpace::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_parkingSpace::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_parkingSpace::include_sequence& t_road_objects_object_parkingSpace::
include () const
{
  return this->include_;
}

t_road_objects_object_parkingSpace::include_sequence& t_road_objects_object_parkingSpace::
include ()
{
  return this->include_;
}

void t_road_objects_object_parkingSpace::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_parkingSpace::dataQuality_optional& t_road_objects_object_parkingSpace::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_parkingSpace::dataQuality_optional& t_road_objects_object_parkingSpace::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_parkingSpace::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_parkingSpace::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_parkingSpace::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_parkingSpace::access_type& t_road_objects_object_parkingSpace::
access () const
{
  return this->access_.get ();
}

t_road_objects_object_parkingSpace::access_type& t_road_objects_object_parkingSpace::
access ()
{
  return this->access_.get ();
}

void t_road_objects_object_parkingSpace::
access (const access_type& x)
{
  this->access_.set (x);
}

void t_road_objects_object_parkingSpace::
access (::std::unique_ptr< access_type > x)
{
  this->access_.set (std::move (x));
}

const t_road_objects_object_parkingSpace::restrictions_optional& t_road_objects_object_parkingSpace::
restrictions () const
{
  return this->restrictions_;
}

t_road_objects_object_parkingSpace::restrictions_optional& t_road_objects_object_parkingSpace::
restrictions ()
{
  return this->restrictions_;
}

void t_road_objects_object_parkingSpace::
restrictions (const restrictions_type& x)
{
  this->restrictions_.set (x);
}

void t_road_objects_object_parkingSpace::
restrictions (const restrictions_optional& x)
{
  this->restrictions_ = x;
}

void t_road_objects_object_parkingSpace::
restrictions (::std::unique_ptr< restrictions_type > x)
{
  this->restrictions_.set (std::move (x));
}


// e_road_objects_object_parkingSpace_access
// 

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (value v)
: ::xml_schema::string (_xsd_e_road_objects_object_parkingSpace_access_literals_[v])
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const char* v)
: ::xml_schema::string (v)
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const e_road_objects_object_parkingSpace_access& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_objects_object_parkingSpace_access& e_road_objects_object_parkingSpace_access::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_objects_object_parkingSpace_access_literals_[v]);

  return *this;
}


// t_road_objects_object_markings
// 

const t_road_objects_object_markings::marking_sequence& t_road_objects_object_markings::
marking () const
{
  return this->marking_;
}

t_road_objects_object_markings::marking_sequence& t_road_objects_object_markings::
marking ()
{
  return this->marking_;
}

void t_road_objects_object_markings::
marking (const marking_sequence& s)
{
  this->marking_ = s;
}

const t_road_objects_object_markings::userData_sequence& t_road_objects_object_markings::
userData () const
{
  return this->userData_;
}

t_road_objects_object_markings::userData_sequence& t_road_objects_object_markings::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_markings::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_markings::include_sequence& t_road_objects_object_markings::
include () const
{
  return this->include_;
}

t_road_objects_object_markings::include_sequence& t_road_objects_object_markings::
include ()
{
  return this->include_;
}

void t_road_objects_object_markings::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_markings::dataQuality_optional& t_road_objects_object_markings::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_markings::dataQuality_optional& t_road_objects_object_markings::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_markings::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_markings::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_markings::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_objects_object_markings_marking
// 

const t_road_objects_object_markings_marking::cornerReference_sequence& t_road_objects_object_markings_marking::
cornerReference () const
{
  return this->cornerReference_;
}

t_road_objects_object_markings_marking::cornerReference_sequence& t_road_objects_object_markings_marking::
cornerReference ()
{
  return this->cornerReference_;
}

void t_road_objects_object_markings_marking::
cornerReference (const cornerReference_sequence& s)
{
  this->cornerReference_ = s;
}

const t_road_objects_object_markings_marking::userData_sequence& t_road_objects_object_markings_marking::
userData () const
{
  return this->userData_;
}

t_road_objects_object_markings_marking::userData_sequence& t_road_objects_object_markings_marking::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_markings_marking::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_markings_marking::include_sequence& t_road_objects_object_markings_marking::
include () const
{
  return this->include_;
}

t_road_objects_object_markings_marking::include_sequence& t_road_objects_object_markings_marking::
include ()
{
  return this->include_;
}

void t_road_objects_object_markings_marking::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_markings_marking::dataQuality_optional& t_road_objects_object_markings_marking::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_markings_marking::dataQuality_optional& t_road_objects_object_markings_marking::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_markings_marking::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_markings_marking::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_markings_marking::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_markings_marking::side_type& t_road_objects_object_markings_marking::
side () const
{
  return this->side_.get ();
}

t_road_objects_object_markings_marking::side_type& t_road_objects_object_markings_marking::
side ()
{
  return this->side_.get ();
}

void t_road_objects_object_markings_marking::
side (const side_type& x)
{
  this->side_.set (x);
}

void t_road_objects_object_markings_marking::
side (::std::unique_ptr< side_type > x)
{
  this->side_.set (std::move (x));
}

const t_road_objects_object_markings_marking::weight_type& t_road_objects_object_markings_marking::
weight () const
{
  return this->weight_.get ();
}

t_road_objects_object_markings_marking::weight_type& t_road_objects_object_markings_marking::
weight ()
{
  return this->weight_.get ();
}

void t_road_objects_object_markings_marking::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void t_road_objects_object_markings_marking::
weight (::std::unique_ptr< weight_type > x)
{
  this->weight_.set (std::move (x));
}

const t_road_objects_object_markings_marking::width_optional& t_road_objects_object_markings_marking::
width () const
{
  return this->width_;
}

t_road_objects_object_markings_marking::width_optional& t_road_objects_object_markings_marking::
width ()
{
  return this->width_;
}

void t_road_objects_object_markings_marking::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_objects_object_markings_marking::
width (const width_optional& x)
{
  this->width_ = x;
}

void t_road_objects_object_markings_marking::
width (::std::unique_ptr< width_type > x)
{
  this->width_.set (std::move (x));
}

const t_road_objects_object_markings_marking::color_type& t_road_objects_object_markings_marking::
color () const
{
  return this->color_.get ();
}

t_road_objects_object_markings_marking::color_type& t_road_objects_object_markings_marking::
color ()
{
  return this->color_.get ();
}

void t_road_objects_object_markings_marking::
color (const color_type& x)
{
  this->color_.set (x);
}

void t_road_objects_object_markings_marking::
color (::std::unique_ptr< color_type > x)
{
  this->color_.set (std::move (x));
}

const t_road_objects_object_markings_marking::zOffset_optional& t_road_objects_object_markings_marking::
zOffset () const
{
  return this->zOffset_;
}

t_road_objects_object_markings_marking::zOffset_optional& t_road_objects_object_markings_marking::
zOffset ()
{
  return this->zOffset_;
}

void t_road_objects_object_markings_marking::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void t_road_objects_object_markings_marking::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

void t_road_objects_object_markings_marking::
zOffset (::std::unique_ptr< zOffset_type > x)
{
  this->zOffset_.set (std::move (x));
}

const t_road_objects_object_markings_marking::spaceLength_type& t_road_objects_object_markings_marking::
spaceLength () const
{
  return this->spaceLength_.get ();
}

t_road_objects_object_markings_marking::spaceLength_type& t_road_objects_object_markings_marking::
spaceLength ()
{
  return this->spaceLength_.get ();
}

void t_road_objects_object_markings_marking::
spaceLength (const spaceLength_type& x)
{
  this->spaceLength_.set (x);
}

void t_road_objects_object_markings_marking::
spaceLength (::std::unique_ptr< spaceLength_type > x)
{
  this->spaceLength_.set (std::move (x));
}

const t_road_objects_object_markings_marking::lineLength_type& t_road_objects_object_markings_marking::
lineLength () const
{
  return this->lineLength_.get ();
}

t_road_objects_object_markings_marking::lineLength_type& t_road_objects_object_markings_marking::
lineLength ()
{
  return this->lineLength_.get ();
}

void t_road_objects_object_markings_marking::
lineLength (const lineLength_type& x)
{
  this->lineLength_.set (x);
}

void t_road_objects_object_markings_marking::
lineLength (::std::unique_ptr< lineLength_type > x)
{
  this->lineLength_.set (std::move (x));
}

const t_road_objects_object_markings_marking::startOffset_type& t_road_objects_object_markings_marking::
startOffset () const
{
  return this->startOffset_.get ();
}

t_road_objects_object_markings_marking::startOffset_type& t_road_objects_object_markings_marking::
startOffset ()
{
  return this->startOffset_.get ();
}

void t_road_objects_object_markings_marking::
startOffset (const startOffset_type& x)
{
  this->startOffset_.set (x);
}

const t_road_objects_object_markings_marking::stopOffset_type& t_road_objects_object_markings_marking::
stopOffset () const
{
  return this->stopOffset_.get ();
}

t_road_objects_object_markings_marking::stopOffset_type& t_road_objects_object_markings_marking::
stopOffset ()
{
  return this->stopOffset_.get ();
}

void t_road_objects_object_markings_marking::
stopOffset (const stopOffset_type& x)
{
  this->stopOffset_.set (x);
}


// t_road_objects_object_markings_marking_cornerReference
// 

const t_road_objects_object_markings_marking_cornerReference::userData_sequence& t_road_objects_object_markings_marking_cornerReference::
userData () const
{
  return this->userData_;
}

t_road_objects_object_markings_marking_cornerReference::userData_sequence& t_road_objects_object_markings_marking_cornerReference::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_markings_marking_cornerReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_markings_marking_cornerReference::include_sequence& t_road_objects_object_markings_marking_cornerReference::
include () const
{
  return this->include_;
}

t_road_objects_object_markings_marking_cornerReference::include_sequence& t_road_objects_object_markings_marking_cornerReference::
include ()
{
  return this->include_;
}

void t_road_objects_object_markings_marking_cornerReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_markings_marking_cornerReference::dataQuality_optional& t_road_objects_object_markings_marking_cornerReference::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_markings_marking_cornerReference::dataQuality_optional& t_road_objects_object_markings_marking_cornerReference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_markings_marking_cornerReference::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_markings_marking_cornerReference::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_markings_marking_cornerReference::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_markings_marking_cornerReference::id_type& t_road_objects_object_markings_marking_cornerReference::
id () const
{
  return this->id_.get ();
}

t_road_objects_object_markings_marking_cornerReference::id_type& t_road_objects_object_markings_marking_cornerReference::
id ()
{
  return this->id_.get ();
}

void t_road_objects_object_markings_marking_cornerReference::
id (const id_type& x)
{
  this->id_.set (x);
}


// t_road_objects_object_borders
// 

const t_road_objects_object_borders::border_sequence& t_road_objects_object_borders::
border () const
{
  return this->border_;
}

t_road_objects_object_borders::border_sequence& t_road_objects_object_borders::
border ()
{
  return this->border_;
}

void t_road_objects_object_borders::
border (const border_sequence& s)
{
  this->border_ = s;
}

const t_road_objects_object_borders::userData_sequence& t_road_objects_object_borders::
userData () const
{
  return this->userData_;
}

t_road_objects_object_borders::userData_sequence& t_road_objects_object_borders::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_borders::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_borders::include_sequence& t_road_objects_object_borders::
include () const
{
  return this->include_;
}

t_road_objects_object_borders::include_sequence& t_road_objects_object_borders::
include ()
{
  return this->include_;
}

void t_road_objects_object_borders::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_borders::dataQuality_optional& t_road_objects_object_borders::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_borders::dataQuality_optional& t_road_objects_object_borders::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_borders::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_borders::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_borders::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_objects_object_borders_border
// 

const t_road_objects_object_borders_border::cornerReference_sequence& t_road_objects_object_borders_border::
cornerReference () const
{
  return this->cornerReference_;
}

t_road_objects_object_borders_border::cornerReference_sequence& t_road_objects_object_borders_border::
cornerReference ()
{
  return this->cornerReference_;
}

void t_road_objects_object_borders_border::
cornerReference (const cornerReference_sequence& s)
{
  this->cornerReference_ = s;
}

const t_road_objects_object_borders_border::userData_sequence& t_road_objects_object_borders_border::
userData () const
{
  return this->userData_;
}

t_road_objects_object_borders_border::userData_sequence& t_road_objects_object_borders_border::
userData ()
{
  return this->userData_;
}

void t_road_objects_object_borders_border::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_object_borders_border::include_sequence& t_road_objects_object_borders_border::
include () const
{
  return this->include_;
}

t_road_objects_object_borders_border::include_sequence& t_road_objects_object_borders_border::
include ()
{
  return this->include_;
}

void t_road_objects_object_borders_border::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_object_borders_border::dataQuality_optional& t_road_objects_object_borders_border::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_object_borders_border::dataQuality_optional& t_road_objects_object_borders_border::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_object_borders_border::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_object_borders_border::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_object_borders_border::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_object_borders_border::width_type& t_road_objects_object_borders_border::
width () const
{
  return this->width_.get ();
}

t_road_objects_object_borders_border::width_type& t_road_objects_object_borders_border::
width ()
{
  return this->width_.get ();
}

void t_road_objects_object_borders_border::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_objects_object_borders_border::
width (::std::unique_ptr< width_type > x)
{
  this->width_.set (std::move (x));
}

const t_road_objects_object_borders_border::type_type& t_road_objects_object_borders_border::
type () const
{
  return this->type_.get ();
}

t_road_objects_object_borders_border::type_type& t_road_objects_object_borders_border::
type ()
{
  return this->type_.get ();
}

void t_road_objects_object_borders_border::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_object_borders_border::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_objects_object_borders_border::outlineId_type& t_road_objects_object_borders_border::
outlineId () const
{
  return this->outlineId_.get ();
}

t_road_objects_object_borders_border::outlineId_type& t_road_objects_object_borders_border::
outlineId ()
{
  return this->outlineId_.get ();
}

void t_road_objects_object_borders_border::
outlineId (const outlineId_type& x)
{
  this->outlineId_.set (x);
}

const t_road_objects_object_borders_border::useCompleteOutline_optional& t_road_objects_object_borders_border::
useCompleteOutline () const
{
  return this->useCompleteOutline_;
}

t_road_objects_object_borders_border::useCompleteOutline_optional& t_road_objects_object_borders_border::
useCompleteOutline ()
{
  return this->useCompleteOutline_;
}

void t_road_objects_object_borders_border::
useCompleteOutline (const useCompleteOutline_type& x)
{
  this->useCompleteOutline_.set (x);
}

void t_road_objects_object_borders_border::
useCompleteOutline (const useCompleteOutline_optional& x)
{
  this->useCompleteOutline_ = x;
}

void t_road_objects_object_borders_border::
useCompleteOutline (::std::unique_ptr< useCompleteOutline_type > x)
{
  this->useCompleteOutline_.set (std::move (x));
}


// t_road_objects_objectReference
// 

const t_road_objects_objectReference::validity_sequence& t_road_objects_objectReference::
validity () const
{
  return this->validity_;
}

t_road_objects_objectReference::validity_sequence& t_road_objects_objectReference::
validity ()
{
  return this->validity_;
}

void t_road_objects_objectReference::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_objectReference::userData_sequence& t_road_objects_objectReference::
userData () const
{
  return this->userData_;
}

t_road_objects_objectReference::userData_sequence& t_road_objects_objectReference::
userData ()
{
  return this->userData_;
}

void t_road_objects_objectReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_objectReference::include_sequence& t_road_objects_objectReference::
include () const
{
  return this->include_;
}

t_road_objects_objectReference::include_sequence& t_road_objects_objectReference::
include ()
{
  return this->include_;
}

void t_road_objects_objectReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_objectReference::dataQuality_optional& t_road_objects_objectReference::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_objectReference::dataQuality_optional& t_road_objects_objectReference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_objectReference::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_objectReference::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_objectReference::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_objectReference::s_type& t_road_objects_objectReference::
s () const
{
  return this->s_.get ();
}

t_road_objects_objectReference::s_type& t_road_objects_objectReference::
s ()
{
  return this->s_.get ();
}

void t_road_objects_objectReference::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_objectReference::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_objects_objectReference::t_type& t_road_objects_objectReference::
t () const
{
  return this->t_.get ();
}

t_road_objects_objectReference::t_type& t_road_objects_objectReference::
t ()
{
  return this->t_.get ();
}

void t_road_objects_objectReference::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_objects_objectReference::id_type& t_road_objects_objectReference::
id () const
{
  return this->id_.get ();
}

t_road_objects_objectReference::id_type& t_road_objects_objectReference::
id ()
{
  return this->id_.get ();
}

void t_road_objects_objectReference::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_objectReference::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_objects_objectReference::zOffset_type& t_road_objects_objectReference::
zOffset () const
{
  return this->zOffset_.get ();
}

t_road_objects_objectReference::zOffset_type& t_road_objects_objectReference::
zOffset ()
{
  return this->zOffset_.get ();
}

void t_road_objects_objectReference::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

const t_road_objects_objectReference::validLength_type& t_road_objects_objectReference::
validLength () const
{
  return this->validLength_.get ();
}

t_road_objects_objectReference::validLength_type& t_road_objects_objectReference::
validLength ()
{
  return this->validLength_.get ();
}

void t_road_objects_objectReference::
validLength (const validLength_type& x)
{
  this->validLength_.set (x);
}

void t_road_objects_objectReference::
validLength (::std::unique_ptr< validLength_type > x)
{
  this->validLength_.set (std::move (x));
}

const t_road_objects_objectReference::orientation_type& t_road_objects_objectReference::
orientation () const
{
  return this->orientation_.get ();
}

t_road_objects_objectReference::orientation_type& t_road_objects_objectReference::
orientation ()
{
  return this->orientation_.get ();
}

void t_road_objects_objectReference::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_objects_objectReference::
orientation (::std::unique_ptr< orientation_type > x)
{
  this->orientation_.set (std::move (x));
}


// t_road_objects_tunnel
// 

const t_road_objects_tunnel::validity_sequence& t_road_objects_tunnel::
validity () const
{
  return this->validity_;
}

t_road_objects_tunnel::validity_sequence& t_road_objects_tunnel::
validity ()
{
  return this->validity_;
}

void t_road_objects_tunnel::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_tunnel::userData_sequence& t_road_objects_tunnel::
userData () const
{
  return this->userData_;
}

t_road_objects_tunnel::userData_sequence& t_road_objects_tunnel::
userData ()
{
  return this->userData_;
}

void t_road_objects_tunnel::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_tunnel::include_sequence& t_road_objects_tunnel::
include () const
{
  return this->include_;
}

t_road_objects_tunnel::include_sequence& t_road_objects_tunnel::
include ()
{
  return this->include_;
}

void t_road_objects_tunnel::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_tunnel::dataQuality_optional& t_road_objects_tunnel::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_tunnel::dataQuality_optional& t_road_objects_tunnel::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_tunnel::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_tunnel::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_tunnel::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_tunnel::s_type& t_road_objects_tunnel::
s () const
{
  return this->s_.get ();
}

t_road_objects_tunnel::s_type& t_road_objects_tunnel::
s ()
{
  return this->s_.get ();
}

void t_road_objects_tunnel::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_tunnel::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_objects_tunnel::length_type& t_road_objects_tunnel::
length () const
{
  return this->length_.get ();
}

t_road_objects_tunnel::length_type& t_road_objects_tunnel::
length ()
{
  return this->length_.get ();
}

void t_road_objects_tunnel::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_tunnel::
length (::std::unique_ptr< length_type > x)
{
  this->length_.set (std::move (x));
}

const t_road_objects_tunnel::name_optional& t_road_objects_tunnel::
name () const
{
  return this->name_;
}

t_road_objects_tunnel::name_optional& t_road_objects_tunnel::
name ()
{
  return this->name_;
}

void t_road_objects_tunnel::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_objects_tunnel::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_objects_tunnel::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road_objects_tunnel::id_type& t_road_objects_tunnel::
id () const
{
  return this->id_.get ();
}

t_road_objects_tunnel::id_type& t_road_objects_tunnel::
id ()
{
  return this->id_.get ();
}

void t_road_objects_tunnel::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_tunnel::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_objects_tunnel::type_type& t_road_objects_tunnel::
type () const
{
  return this->type_.get ();
}

t_road_objects_tunnel::type_type& t_road_objects_tunnel::
type ()
{
  return this->type_.get ();
}

void t_road_objects_tunnel::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_tunnel::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_objects_tunnel::lighting_optional& t_road_objects_tunnel::
lighting () const
{
  return this->lighting_;
}

t_road_objects_tunnel::lighting_optional& t_road_objects_tunnel::
lighting ()
{
  return this->lighting_;
}

void t_road_objects_tunnel::
lighting (const lighting_type& x)
{
  this->lighting_.set (x);
}

void t_road_objects_tunnel::
lighting (const lighting_optional& x)
{
  this->lighting_ = x;
}

void t_road_objects_tunnel::
lighting (::std::unique_ptr< lighting_type > x)
{
  this->lighting_.set (std::move (x));
}

const t_road_objects_tunnel::daylight_optional& t_road_objects_tunnel::
daylight () const
{
  return this->daylight_;
}

t_road_objects_tunnel::daylight_optional& t_road_objects_tunnel::
daylight ()
{
  return this->daylight_;
}

void t_road_objects_tunnel::
daylight (const daylight_type& x)
{
  this->daylight_.set (x);
}

void t_road_objects_tunnel::
daylight (const daylight_optional& x)
{
  this->daylight_ = x;
}

void t_road_objects_tunnel::
daylight (::std::unique_ptr< daylight_type > x)
{
  this->daylight_.set (std::move (x));
}


// t_road_objects_bridge
// 

const t_road_objects_bridge::validity_sequence& t_road_objects_bridge::
validity () const
{
  return this->validity_;
}

t_road_objects_bridge::validity_sequence& t_road_objects_bridge::
validity ()
{
  return this->validity_;
}

void t_road_objects_bridge::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_objects_bridge::userData_sequence& t_road_objects_bridge::
userData () const
{
  return this->userData_;
}

t_road_objects_bridge::userData_sequence& t_road_objects_bridge::
userData ()
{
  return this->userData_;
}

void t_road_objects_bridge::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_objects_bridge::include_sequence& t_road_objects_bridge::
include () const
{
  return this->include_;
}

t_road_objects_bridge::include_sequence& t_road_objects_bridge::
include ()
{
  return this->include_;
}

void t_road_objects_bridge::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_objects_bridge::dataQuality_optional& t_road_objects_bridge::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_objects_bridge::dataQuality_optional& t_road_objects_bridge::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_objects_bridge::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_objects_bridge::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_objects_bridge::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_objects_bridge::s_type& t_road_objects_bridge::
s () const
{
  return this->s_.get ();
}

t_road_objects_bridge::s_type& t_road_objects_bridge::
s ()
{
  return this->s_.get ();
}

void t_road_objects_bridge::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_objects_bridge::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_objects_bridge::length_type& t_road_objects_bridge::
length () const
{
  return this->length_.get ();
}

t_road_objects_bridge::length_type& t_road_objects_bridge::
length ()
{
  return this->length_.get ();
}

void t_road_objects_bridge::
length (const length_type& x)
{
  this->length_.set (x);
}

void t_road_objects_bridge::
length (::std::unique_ptr< length_type > x)
{
  this->length_.set (std::move (x));
}

const t_road_objects_bridge::name_optional& t_road_objects_bridge::
name () const
{
  return this->name_;
}

t_road_objects_bridge::name_optional& t_road_objects_bridge::
name ()
{
  return this->name_;
}

void t_road_objects_bridge::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_objects_bridge::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_objects_bridge::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road_objects_bridge::id_type& t_road_objects_bridge::
id () const
{
  return this->id_.get ();
}

t_road_objects_bridge::id_type& t_road_objects_bridge::
id ()
{
  return this->id_.get ();
}

void t_road_objects_bridge::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_objects_bridge::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_objects_bridge::type_type& t_road_objects_bridge::
type () const
{
  return this->type_.get ();
}

t_road_objects_bridge::type_type& t_road_objects_bridge::
type ()
{
  return this->type_.get ();
}

void t_road_objects_bridge::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_objects_bridge::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// t_road_signals
// 

const t_road_signals::signal_sequence& t_road_signals::
signal () const
{
  return this->signal_;
}

t_road_signals::signal_sequence& t_road_signals::
signal ()
{
  return this->signal_;
}

void t_road_signals::
signal (const signal_sequence& s)
{
  this->signal_ = s;
}

const t_road_signals::signalReference_sequence& t_road_signals::
signalReference () const
{
  return this->signalReference_;
}

t_road_signals::signalReference_sequence& t_road_signals::
signalReference ()
{
  return this->signalReference_;
}

void t_road_signals::
signalReference (const signalReference_sequence& s)
{
  this->signalReference_ = s;
}

const t_road_signals::userData_sequence& t_road_signals::
userData () const
{
  return this->userData_;
}

t_road_signals::userData_sequence& t_road_signals::
userData ()
{
  return this->userData_;
}

void t_road_signals::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_signals::include_sequence& t_road_signals::
include () const
{
  return this->include_;
}

t_road_signals::include_sequence& t_road_signals::
include ()
{
  return this->include_;
}

void t_road_signals::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_signals::dataQuality_optional& t_road_signals::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_signals::dataQuality_optional& t_road_signals::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_signals::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_signals::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_signals::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_signals_signal
// 

const t_road_signals_signal::validity_sequence& t_road_signals_signal::
validity () const
{
  return this->validity_;
}

t_road_signals_signal::validity_sequence& t_road_signals_signal::
validity ()
{
  return this->validity_;
}

void t_road_signals_signal::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_signals_signal::dependency_sequence& t_road_signals_signal::
dependency () const
{
  return this->dependency_;
}

t_road_signals_signal::dependency_sequence& t_road_signals_signal::
dependency ()
{
  return this->dependency_;
}

void t_road_signals_signal::
dependency (const dependency_sequence& s)
{
  this->dependency_ = s;
}

const t_road_signals_signal::reference_sequence& t_road_signals_signal::
reference () const
{
  return this->reference_;
}

t_road_signals_signal::reference_sequence& t_road_signals_signal::
reference ()
{
  return this->reference_;
}

void t_road_signals_signal::
reference (const reference_sequence& s)
{
  this->reference_ = s;
}

const t_road_signals_signal::positionRoad_optional& t_road_signals_signal::
positionRoad () const
{
  return this->positionRoad_;
}

t_road_signals_signal::positionRoad_optional& t_road_signals_signal::
positionRoad ()
{
  return this->positionRoad_;
}

void t_road_signals_signal::
positionRoad (const positionRoad_type& x)
{
  this->positionRoad_.set (x);
}

void t_road_signals_signal::
positionRoad (const positionRoad_optional& x)
{
  this->positionRoad_ = x;
}

void t_road_signals_signal::
positionRoad (::std::unique_ptr< positionRoad_type > x)
{
  this->positionRoad_.set (std::move (x));
}

const t_road_signals_signal::positionInertial_optional& t_road_signals_signal::
positionInertial () const
{
  return this->positionInertial_;
}

t_road_signals_signal::positionInertial_optional& t_road_signals_signal::
positionInertial ()
{
  return this->positionInertial_;
}

void t_road_signals_signal::
positionInertial (const positionInertial_type& x)
{
  this->positionInertial_.set (x);
}

void t_road_signals_signal::
positionInertial (const positionInertial_optional& x)
{
  this->positionInertial_ = x;
}

void t_road_signals_signal::
positionInertial (::std::unique_ptr< positionInertial_type > x)
{
  this->positionInertial_.set (std::move (x));
}

const t_road_signals_signal::userData_sequence& t_road_signals_signal::
userData () const
{
  return this->userData_;
}

t_road_signals_signal::userData_sequence& t_road_signals_signal::
userData ()
{
  return this->userData_;
}

void t_road_signals_signal::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_signals_signal::include_sequence& t_road_signals_signal::
include () const
{
  return this->include_;
}

t_road_signals_signal::include_sequence& t_road_signals_signal::
include ()
{
  return this->include_;
}

void t_road_signals_signal::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_signals_signal::dataQuality_optional& t_road_signals_signal::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_signals_signal::dataQuality_optional& t_road_signals_signal::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_signals_signal::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_signals_signal::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_signals_signal::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_signals_signal::s_type& t_road_signals_signal::
s () const
{
  return this->s_.get ();
}

t_road_signals_signal::s_type& t_road_signals_signal::
s ()
{
  return this->s_.get ();
}

void t_road_signals_signal::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_signals_signal::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_signals_signal::t_type& t_road_signals_signal::
t () const
{
  return this->t_.get ();
}

t_road_signals_signal::t_type& t_road_signals_signal::
t ()
{
  return this->t_.get ();
}

void t_road_signals_signal::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_signals_signal::id_type& t_road_signals_signal::
id () const
{
  return this->id_.get ();
}

t_road_signals_signal::id_type& t_road_signals_signal::
id ()
{
  return this->id_.get ();
}

void t_road_signals_signal::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_signals_signal::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_signals_signal::name_optional& t_road_signals_signal::
name () const
{
  return this->name_;
}

t_road_signals_signal::name_optional& t_road_signals_signal::
name ()
{
  return this->name_;
}

void t_road_signals_signal::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_signals_signal::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_signals_signal::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road_signals_signal::dynamic_type& t_road_signals_signal::
dynamic () const
{
  return this->dynamic_.get ();
}

t_road_signals_signal::dynamic_type& t_road_signals_signal::
dynamic ()
{
  return this->dynamic_.get ();
}

void t_road_signals_signal::
dynamic (const dynamic_type& x)
{
  this->dynamic_.set (x);
}

void t_road_signals_signal::
dynamic (::std::unique_ptr< dynamic_type > x)
{
  this->dynamic_.set (std::move (x));
}

const t_road_signals_signal::orientation_type& t_road_signals_signal::
orientation () const
{
  return this->orientation_.get ();
}

t_road_signals_signal::orientation_type& t_road_signals_signal::
orientation ()
{
  return this->orientation_.get ();
}

void t_road_signals_signal::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_signals_signal::
orientation (::std::unique_ptr< orientation_type > x)
{
  this->orientation_.set (std::move (x));
}

const t_road_signals_signal::zOffset_type& t_road_signals_signal::
zOffset () const
{
  return this->zOffset_.get ();
}

t_road_signals_signal::zOffset_type& t_road_signals_signal::
zOffset ()
{
  return this->zOffset_.get ();
}

void t_road_signals_signal::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

const t_road_signals_signal::country_optional& t_road_signals_signal::
country () const
{
  return this->country_;
}

t_road_signals_signal::country_optional& t_road_signals_signal::
country ()
{
  return this->country_;
}

void t_road_signals_signal::
country (const country_type& x)
{
  this->country_.set (x);
}

void t_road_signals_signal::
country (const country_optional& x)
{
  this->country_ = x;
}

void t_road_signals_signal::
country (::std::unique_ptr< country_type > x)
{
  this->country_.set (std::move (x));
}

const t_road_signals_signal::countryRevision_optional& t_road_signals_signal::
countryRevision () const
{
  return this->countryRevision_;
}

t_road_signals_signal::countryRevision_optional& t_road_signals_signal::
countryRevision ()
{
  return this->countryRevision_;
}

void t_road_signals_signal::
countryRevision (const countryRevision_type& x)
{
  this->countryRevision_.set (x);
}

void t_road_signals_signal::
countryRevision (const countryRevision_optional& x)
{
  this->countryRevision_ = x;
}

void t_road_signals_signal::
countryRevision (::std::unique_ptr< countryRevision_type > x)
{
  this->countryRevision_.set (std::move (x));
}

const t_road_signals_signal::type_type& t_road_signals_signal::
type () const
{
  return this->type_.get ();
}

t_road_signals_signal::type_type& t_road_signals_signal::
type ()
{
  return this->type_.get ();
}

void t_road_signals_signal::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_signals_signal::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_road_signals_signal::subtype_type& t_road_signals_signal::
subtype () const
{
  return this->subtype_.get ();
}

t_road_signals_signal::subtype_type& t_road_signals_signal::
subtype ()
{
  return this->subtype_.get ();
}

void t_road_signals_signal::
subtype (const subtype_type& x)
{
  this->subtype_.set (x);
}

void t_road_signals_signal::
subtype (::std::unique_ptr< subtype_type > x)
{
  this->subtype_.set (std::move (x));
}

const t_road_signals_signal::value_optional& t_road_signals_signal::
value () const
{
  return this->value_;
}

t_road_signals_signal::value_optional& t_road_signals_signal::
value ()
{
  return this->value_;
}

void t_road_signals_signal::
value (const value_type& x)
{
  this->value_.set (x);
}

void t_road_signals_signal::
value (const value_optional& x)
{
  this->value_ = x;
}

const t_road_signals_signal::unit_optional& t_road_signals_signal::
unit () const
{
  return this->unit_;
}

t_road_signals_signal::unit_optional& t_road_signals_signal::
unit ()
{
  return this->unit_;
}

void t_road_signals_signal::
unit (const unit_type& x)
{
  this->unit_.set (x);
}

void t_road_signals_signal::
unit (const unit_optional& x)
{
  this->unit_ = x;
}

void t_road_signals_signal::
unit (::std::unique_ptr< unit_type > x)
{
  this->unit_.set (std::move (x));
}

const t_road_signals_signal::height_type& t_road_signals_signal::
height () const
{
  return this->height_.get ();
}

t_road_signals_signal::height_type& t_road_signals_signal::
height ()
{
  return this->height_.get ();
}

void t_road_signals_signal::
height (const height_type& x)
{
  this->height_.set (x);
}

void t_road_signals_signal::
height (::std::unique_ptr< height_type > x)
{
  this->height_.set (std::move (x));
}

const t_road_signals_signal::width_type& t_road_signals_signal::
width () const
{
  return this->width_.get ();
}

t_road_signals_signal::width_type& t_road_signals_signal::
width ()
{
  return this->width_.get ();
}

void t_road_signals_signal::
width (const width_type& x)
{
  this->width_.set (x);
}

void t_road_signals_signal::
width (::std::unique_ptr< width_type > x)
{
  this->width_.set (std::move (x));
}

const t_road_signals_signal::text_optional& t_road_signals_signal::
text () const
{
  return this->text_;
}

t_road_signals_signal::text_optional& t_road_signals_signal::
text ()
{
  return this->text_;
}

void t_road_signals_signal::
text (const text_type& x)
{
  this->text_.set (x);
}

void t_road_signals_signal::
text (const text_optional& x)
{
  this->text_ = x;
}

void t_road_signals_signal::
text (::std::unique_ptr< text_type > x)
{
  this->text_.set (std::move (x));
}

const t_road_signals_signal::hOffset_optional& t_road_signals_signal::
hOffset () const
{
  return this->hOffset_;
}

t_road_signals_signal::hOffset_optional& t_road_signals_signal::
hOffset ()
{
  return this->hOffset_;
}

void t_road_signals_signal::
hOffset (const hOffset_type& x)
{
  this->hOffset_.set (x);
}

void t_road_signals_signal::
hOffset (const hOffset_optional& x)
{
  this->hOffset_ = x;
}

const t_road_signals_signal::pitch_optional& t_road_signals_signal::
pitch () const
{
  return this->pitch_;
}

t_road_signals_signal::pitch_optional& t_road_signals_signal::
pitch ()
{
  return this->pitch_;
}

void t_road_signals_signal::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void t_road_signals_signal::
pitch (const pitch_optional& x)
{
  this->pitch_ = x;
}

const t_road_signals_signal::roll_optional& t_road_signals_signal::
roll () const
{
  return this->roll_;
}

t_road_signals_signal::roll_optional& t_road_signals_signal::
roll ()
{
  return this->roll_;
}

void t_road_signals_signal::
roll (const roll_type& x)
{
  this->roll_.set (x);
}

void t_road_signals_signal::
roll (const roll_optional& x)
{
  this->roll_ = x;
}


// t_road_signals_signal_dependency
// 

const t_road_signals_signal_dependency::userData_sequence& t_road_signals_signal_dependency::
userData () const
{
  return this->userData_;
}

t_road_signals_signal_dependency::userData_sequence& t_road_signals_signal_dependency::
userData ()
{
  return this->userData_;
}

void t_road_signals_signal_dependency::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_signals_signal_dependency::include_sequence& t_road_signals_signal_dependency::
include () const
{
  return this->include_;
}

t_road_signals_signal_dependency::include_sequence& t_road_signals_signal_dependency::
include ()
{
  return this->include_;
}

void t_road_signals_signal_dependency::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_signals_signal_dependency::dataQuality_optional& t_road_signals_signal_dependency::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_signals_signal_dependency::dataQuality_optional& t_road_signals_signal_dependency::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_signals_signal_dependency::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_signals_signal_dependency::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_signals_signal_dependency::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_signals_signal_dependency::id_type& t_road_signals_signal_dependency::
id () const
{
  return this->id_.get ();
}

t_road_signals_signal_dependency::id_type& t_road_signals_signal_dependency::
id ()
{
  return this->id_.get ();
}

void t_road_signals_signal_dependency::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_signals_signal_dependency::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_signals_signal_dependency::type_optional& t_road_signals_signal_dependency::
type () const
{
  return this->type_;
}

t_road_signals_signal_dependency::type_optional& t_road_signals_signal_dependency::
type ()
{
  return this->type_;
}

void t_road_signals_signal_dependency::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_signals_signal_dependency::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_road_signals_signal_dependency::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// t_road_signals_signal_reference
// 

const t_road_signals_signal_reference::userData_sequence& t_road_signals_signal_reference::
userData () const
{
  return this->userData_;
}

t_road_signals_signal_reference::userData_sequence& t_road_signals_signal_reference::
userData ()
{
  return this->userData_;
}

void t_road_signals_signal_reference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_signals_signal_reference::include_sequence& t_road_signals_signal_reference::
include () const
{
  return this->include_;
}

t_road_signals_signal_reference::include_sequence& t_road_signals_signal_reference::
include ()
{
  return this->include_;
}

void t_road_signals_signal_reference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_signals_signal_reference::dataQuality_optional& t_road_signals_signal_reference::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_signals_signal_reference::dataQuality_optional& t_road_signals_signal_reference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_signals_signal_reference::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_signals_signal_reference::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_signals_signal_reference::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_signals_signal_reference::elementType_type& t_road_signals_signal_reference::
elementType () const
{
  return this->elementType_.get ();
}

t_road_signals_signal_reference::elementType_type& t_road_signals_signal_reference::
elementType ()
{
  return this->elementType_.get ();
}

void t_road_signals_signal_reference::
elementType (const elementType_type& x)
{
  this->elementType_.set (x);
}

void t_road_signals_signal_reference::
elementType (::std::unique_ptr< elementType_type > x)
{
  this->elementType_.set (std::move (x));
}

const t_road_signals_signal_reference::elementId_type& t_road_signals_signal_reference::
elementId () const
{
  return this->elementId_.get ();
}

t_road_signals_signal_reference::elementId_type& t_road_signals_signal_reference::
elementId ()
{
  return this->elementId_.get ();
}

void t_road_signals_signal_reference::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void t_road_signals_signal_reference::
elementId (::std::unique_ptr< elementId_type > x)
{
  this->elementId_.set (std::move (x));
}

const t_road_signals_signal_reference::type_optional& t_road_signals_signal_reference::
type () const
{
  return this->type_;
}

t_road_signals_signal_reference::type_optional& t_road_signals_signal_reference::
type ()
{
  return this->type_;
}

void t_road_signals_signal_reference::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_road_signals_signal_reference::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_road_signals_signal_reference::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// e_road_signals_signal_reference_elementType
// 

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (value v)
: ::xml_schema::string (_xsd_e_road_signals_signal_reference_elementType_literals_[v])
{
}

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (const char* v)
: ::xml_schema::string (v)
{
}

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (const e_road_signals_signal_reference_elementType& v,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_signals_signal_reference_elementType& e_road_signals_signal_reference_elementType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_signals_signal_reference_elementType_literals_[v]);

  return *this;
}


// t_road_signals_signal_positionRoad
// 

const t_road_signals_signal_positionRoad::userData_sequence& t_road_signals_signal_positionRoad::
userData () const
{
  return this->userData_;
}

t_road_signals_signal_positionRoad::userData_sequence& t_road_signals_signal_positionRoad::
userData ()
{
  return this->userData_;
}

void t_road_signals_signal_positionRoad::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_signals_signal_positionRoad::include_sequence& t_road_signals_signal_positionRoad::
include () const
{
  return this->include_;
}

t_road_signals_signal_positionRoad::include_sequence& t_road_signals_signal_positionRoad::
include ()
{
  return this->include_;
}

void t_road_signals_signal_positionRoad::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_signals_signal_positionRoad::dataQuality_optional& t_road_signals_signal_positionRoad::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_signals_signal_positionRoad::dataQuality_optional& t_road_signals_signal_positionRoad::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_signals_signal_positionRoad::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_signals_signal_positionRoad::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_signals_signal_positionRoad::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_signals_signal_positionRoad::roadId_type& t_road_signals_signal_positionRoad::
roadId () const
{
  return this->roadId_.get ();
}

t_road_signals_signal_positionRoad::roadId_type& t_road_signals_signal_positionRoad::
roadId ()
{
  return this->roadId_.get ();
}

void t_road_signals_signal_positionRoad::
roadId (const roadId_type& x)
{
  this->roadId_.set (x);
}

void t_road_signals_signal_positionRoad::
roadId (::std::unique_ptr< roadId_type > x)
{
  this->roadId_.set (std::move (x));
}

const t_road_signals_signal_positionRoad::s_type& t_road_signals_signal_positionRoad::
s () const
{
  return this->s_.get ();
}

t_road_signals_signal_positionRoad::s_type& t_road_signals_signal_positionRoad::
s ()
{
  return this->s_.get ();
}

void t_road_signals_signal_positionRoad::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_signals_signal_positionRoad::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_signals_signal_positionRoad::t_type& t_road_signals_signal_positionRoad::
t () const
{
  return this->t_.get ();
}

t_road_signals_signal_positionRoad::t_type& t_road_signals_signal_positionRoad::
t ()
{
  return this->t_.get ();
}

void t_road_signals_signal_positionRoad::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_signals_signal_positionRoad::zOffset_type& t_road_signals_signal_positionRoad::
zOffset () const
{
  return this->zOffset_.get ();
}

t_road_signals_signal_positionRoad::zOffset_type& t_road_signals_signal_positionRoad::
zOffset ()
{
  return this->zOffset_.get ();
}

void t_road_signals_signal_positionRoad::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

const t_road_signals_signal_positionRoad::hOffset_type& t_road_signals_signal_positionRoad::
hOffset () const
{
  return this->hOffset_.get ();
}

t_road_signals_signal_positionRoad::hOffset_type& t_road_signals_signal_positionRoad::
hOffset ()
{
  return this->hOffset_.get ();
}

void t_road_signals_signal_positionRoad::
hOffset (const hOffset_type& x)
{
  this->hOffset_.set (x);
}

const t_road_signals_signal_positionRoad::pitch_optional& t_road_signals_signal_positionRoad::
pitch () const
{
  return this->pitch_;
}

t_road_signals_signal_positionRoad::pitch_optional& t_road_signals_signal_positionRoad::
pitch ()
{
  return this->pitch_;
}

void t_road_signals_signal_positionRoad::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void t_road_signals_signal_positionRoad::
pitch (const pitch_optional& x)
{
  this->pitch_ = x;
}

const t_road_signals_signal_positionRoad::roll_optional& t_road_signals_signal_positionRoad::
roll () const
{
  return this->roll_;
}

t_road_signals_signal_positionRoad::roll_optional& t_road_signals_signal_positionRoad::
roll ()
{
  return this->roll_;
}

void t_road_signals_signal_positionRoad::
roll (const roll_type& x)
{
  this->roll_.set (x);
}

void t_road_signals_signal_positionRoad::
roll (const roll_optional& x)
{
  this->roll_ = x;
}


// t_road_signals_signal_positionInertial
// 

const t_road_signals_signal_positionInertial::userData_sequence& t_road_signals_signal_positionInertial::
userData () const
{
  return this->userData_;
}

t_road_signals_signal_positionInertial::userData_sequence& t_road_signals_signal_positionInertial::
userData ()
{
  return this->userData_;
}

void t_road_signals_signal_positionInertial::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_signals_signal_positionInertial::include_sequence& t_road_signals_signal_positionInertial::
include () const
{
  return this->include_;
}

t_road_signals_signal_positionInertial::include_sequence& t_road_signals_signal_positionInertial::
include ()
{
  return this->include_;
}

void t_road_signals_signal_positionInertial::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_signals_signal_positionInertial::dataQuality_optional& t_road_signals_signal_positionInertial::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_signals_signal_positionInertial::dataQuality_optional& t_road_signals_signal_positionInertial::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_signals_signal_positionInertial::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_signals_signal_positionInertial::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_signals_signal_positionInertial::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_signals_signal_positionInertial::x_type& t_road_signals_signal_positionInertial::
x () const
{
  return this->x_.get ();
}

t_road_signals_signal_positionInertial::x_type& t_road_signals_signal_positionInertial::
x ()
{
  return this->x_.get ();
}

void t_road_signals_signal_positionInertial::
x (const x_type& x)
{
  this->x_.set (x);
}

const t_road_signals_signal_positionInertial::y_type& t_road_signals_signal_positionInertial::
y () const
{
  return this->y_.get ();
}

t_road_signals_signal_positionInertial::y_type& t_road_signals_signal_positionInertial::
y ()
{
  return this->y_.get ();
}

void t_road_signals_signal_positionInertial::
y (const y_type& x)
{
  this->y_.set (x);
}

const t_road_signals_signal_positionInertial::z_type& t_road_signals_signal_positionInertial::
z () const
{
  return this->z_.get ();
}

t_road_signals_signal_positionInertial::z_type& t_road_signals_signal_positionInertial::
z ()
{
  return this->z_.get ();
}

void t_road_signals_signal_positionInertial::
z (const z_type& x)
{
  this->z_.set (x);
}

const t_road_signals_signal_positionInertial::hdg_type& t_road_signals_signal_positionInertial::
hdg () const
{
  return this->hdg_.get ();
}

t_road_signals_signal_positionInertial::hdg_type& t_road_signals_signal_positionInertial::
hdg ()
{
  return this->hdg_.get ();
}

void t_road_signals_signal_positionInertial::
hdg (const hdg_type& x)
{
  this->hdg_.set (x);
}

const t_road_signals_signal_positionInertial::pitch_optional& t_road_signals_signal_positionInertial::
pitch () const
{
  return this->pitch_;
}

t_road_signals_signal_positionInertial::pitch_optional& t_road_signals_signal_positionInertial::
pitch ()
{
  return this->pitch_;
}

void t_road_signals_signal_positionInertial::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void t_road_signals_signal_positionInertial::
pitch (const pitch_optional& x)
{
  this->pitch_ = x;
}

const t_road_signals_signal_positionInertial::roll_optional& t_road_signals_signal_positionInertial::
roll () const
{
  return this->roll_;
}

t_road_signals_signal_positionInertial::roll_optional& t_road_signals_signal_positionInertial::
roll ()
{
  return this->roll_;
}

void t_road_signals_signal_positionInertial::
roll (const roll_type& x)
{
  this->roll_.set (x);
}

void t_road_signals_signal_positionInertial::
roll (const roll_optional& x)
{
  this->roll_ = x;
}


// t_road_signals_signalReference
// 

const t_road_signals_signalReference::validity_sequence& t_road_signals_signalReference::
validity () const
{
  return this->validity_;
}

t_road_signals_signalReference::validity_sequence& t_road_signals_signalReference::
validity ()
{
  return this->validity_;
}

void t_road_signals_signalReference::
validity (const validity_sequence& s)
{
  this->validity_ = s;
}

const t_road_signals_signalReference::userData_sequence& t_road_signals_signalReference::
userData () const
{
  return this->userData_;
}

t_road_signals_signalReference::userData_sequence& t_road_signals_signalReference::
userData ()
{
  return this->userData_;
}

void t_road_signals_signalReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_signals_signalReference::include_sequence& t_road_signals_signalReference::
include () const
{
  return this->include_;
}

t_road_signals_signalReference::include_sequence& t_road_signals_signalReference::
include ()
{
  return this->include_;
}

void t_road_signals_signalReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_signals_signalReference::dataQuality_optional& t_road_signals_signalReference::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_signals_signalReference::dataQuality_optional& t_road_signals_signalReference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_signals_signalReference::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_signals_signalReference::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_signals_signalReference::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_signals_signalReference::s_type& t_road_signals_signalReference::
s () const
{
  return this->s_.get ();
}

t_road_signals_signalReference::s_type& t_road_signals_signalReference::
s ()
{
  return this->s_.get ();
}

void t_road_signals_signalReference::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_signals_signalReference::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_signals_signalReference::t_type& t_road_signals_signalReference::
t () const
{
  return this->t_.get ();
}

t_road_signals_signalReference::t_type& t_road_signals_signalReference::
t ()
{
  return this->t_.get ();
}

void t_road_signals_signalReference::
t (const t_type& x)
{
  this->t_.set (x);
}

const t_road_signals_signalReference::id_type& t_road_signals_signalReference::
id () const
{
  return this->id_.get ();
}

t_road_signals_signalReference::id_type& t_road_signals_signalReference::
id ()
{
  return this->id_.get ();
}

void t_road_signals_signalReference::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_signals_signalReference::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_signals_signalReference::orientation_type& t_road_signals_signalReference::
orientation () const
{
  return this->orientation_.get ();
}

t_road_signals_signalReference::orientation_type& t_road_signals_signalReference::
orientation ()
{
  return this->orientation_.get ();
}

void t_road_signals_signalReference::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_signals_signalReference::
orientation (::std::unique_ptr< orientation_type > x)
{
  this->orientation_.set (std::move (x));
}


// t_road_surface
// 

const t_road_surface::CRG_sequence& t_road_surface::
CRG () const
{
  return this->CRG_;
}

t_road_surface::CRG_sequence& t_road_surface::
CRG ()
{
  return this->CRG_;
}

void t_road_surface::
CRG (const CRG_sequence& s)
{
  this->CRG_ = s;
}

const t_road_surface::userData_sequence& t_road_surface::
userData () const
{
  return this->userData_;
}

t_road_surface::userData_sequence& t_road_surface::
userData ()
{
  return this->userData_;
}

void t_road_surface::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_surface::include_sequence& t_road_surface::
include () const
{
  return this->include_;
}

t_road_surface::include_sequence& t_road_surface::
include ()
{
  return this->include_;
}

void t_road_surface::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_surface::dataQuality_optional& t_road_surface::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_surface::dataQuality_optional& t_road_surface::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_surface::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_surface::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_surface::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_surface_CRG
// 

const t_road_surface_CRG::userData_sequence& t_road_surface_CRG::
userData () const
{
  return this->userData_;
}

t_road_surface_CRG::userData_sequence& t_road_surface_CRG::
userData ()
{
  return this->userData_;
}

void t_road_surface_CRG::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_surface_CRG::include_sequence& t_road_surface_CRG::
include () const
{
  return this->include_;
}

t_road_surface_CRG::include_sequence& t_road_surface_CRG::
include ()
{
  return this->include_;
}

void t_road_surface_CRG::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_surface_CRG::dataQuality_optional& t_road_surface_CRG::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_surface_CRG::dataQuality_optional& t_road_surface_CRG::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_surface_CRG::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_surface_CRG::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_surface_CRG::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_surface_CRG::file_type& t_road_surface_CRG::
file () const
{
  return this->file_.get ();
}

t_road_surface_CRG::file_type& t_road_surface_CRG::
file ()
{
  return this->file_.get ();
}

void t_road_surface_CRG::
file (const file_type& x)
{
  this->file_.set (x);
}

void t_road_surface_CRG::
file (::std::unique_ptr< file_type > x)
{
  this->file_.set (std::move (x));
}

const t_road_surface_CRG::sStart_type& t_road_surface_CRG::
sStart () const
{
  return this->sStart_.get ();
}

t_road_surface_CRG::sStart_type& t_road_surface_CRG::
sStart ()
{
  return this->sStart_.get ();
}

void t_road_surface_CRG::
sStart (const sStart_type& x)
{
  this->sStart_.set (x);
}

void t_road_surface_CRG::
sStart (::std::unique_ptr< sStart_type > x)
{
  this->sStart_.set (std::move (x));
}

const t_road_surface_CRG::sEnd_type& t_road_surface_CRG::
sEnd () const
{
  return this->sEnd_.get ();
}

t_road_surface_CRG::sEnd_type& t_road_surface_CRG::
sEnd ()
{
  return this->sEnd_.get ();
}

void t_road_surface_CRG::
sEnd (const sEnd_type& x)
{
  this->sEnd_.set (x);
}

void t_road_surface_CRG::
sEnd (::std::unique_ptr< sEnd_type > x)
{
  this->sEnd_.set (std::move (x));
}

const t_road_surface_CRG::orientation_type& t_road_surface_CRG::
orientation () const
{
  return this->orientation_.get ();
}

t_road_surface_CRG::orientation_type& t_road_surface_CRG::
orientation ()
{
  return this->orientation_.get ();
}

void t_road_surface_CRG::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void t_road_surface_CRG::
orientation (::std::unique_ptr< orientation_type > x)
{
  this->orientation_.set (std::move (x));
}

const t_road_surface_CRG::mode_type& t_road_surface_CRG::
mode () const
{
  return this->mode_.get ();
}

t_road_surface_CRG::mode_type& t_road_surface_CRG::
mode ()
{
  return this->mode_.get ();
}

void t_road_surface_CRG::
mode (const mode_type& x)
{
  this->mode_.set (x);
}

void t_road_surface_CRG::
mode (::std::unique_ptr< mode_type > x)
{
  this->mode_.set (std::move (x));
}

const t_road_surface_CRG::purpose_optional& t_road_surface_CRG::
purpose () const
{
  return this->purpose_;
}

t_road_surface_CRG::purpose_optional& t_road_surface_CRG::
purpose ()
{
  return this->purpose_;
}

void t_road_surface_CRG::
purpose (const purpose_type& x)
{
  this->purpose_.set (x);
}

void t_road_surface_CRG::
purpose (const purpose_optional& x)
{
  this->purpose_ = x;
}

void t_road_surface_CRG::
purpose (::std::unique_ptr< purpose_type > x)
{
  this->purpose_.set (std::move (x));
}

const t_road_surface_CRG::sOffset_optional& t_road_surface_CRG::
sOffset () const
{
  return this->sOffset_;
}

t_road_surface_CRG::sOffset_optional& t_road_surface_CRG::
sOffset ()
{
  return this->sOffset_;
}

void t_road_surface_CRG::
sOffset (const sOffset_type& x)
{
  this->sOffset_.set (x);
}

void t_road_surface_CRG::
sOffset (const sOffset_optional& x)
{
  this->sOffset_ = x;
}

const t_road_surface_CRG::tOffset_optional& t_road_surface_CRG::
tOffset () const
{
  return this->tOffset_;
}

t_road_surface_CRG::tOffset_optional& t_road_surface_CRG::
tOffset ()
{
  return this->tOffset_;
}

void t_road_surface_CRG::
tOffset (const tOffset_type& x)
{
  this->tOffset_.set (x);
}

void t_road_surface_CRG::
tOffset (const tOffset_optional& x)
{
  this->tOffset_ = x;
}

const t_road_surface_CRG::zOffset_optional& t_road_surface_CRG::
zOffset () const
{
  return this->zOffset_;
}

t_road_surface_CRG::zOffset_optional& t_road_surface_CRG::
zOffset ()
{
  return this->zOffset_;
}

void t_road_surface_CRG::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void t_road_surface_CRG::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const t_road_surface_CRG::zScale_optional& t_road_surface_CRG::
zScale () const
{
  return this->zScale_;
}

t_road_surface_CRG::zScale_optional& t_road_surface_CRG::
zScale ()
{
  return this->zScale_;
}

void t_road_surface_CRG::
zScale (const zScale_type& x)
{
  this->zScale_.set (x);
}

void t_road_surface_CRG::
zScale (const zScale_optional& x)
{
  this->zScale_ = x;
}

const t_road_surface_CRG::hOffset_optional& t_road_surface_CRG::
hOffset () const
{
  return this->hOffset_;
}

t_road_surface_CRG::hOffset_optional& t_road_surface_CRG::
hOffset ()
{
  return this->hOffset_;
}

void t_road_surface_CRG::
hOffset (const hOffset_type& x)
{
  this->hOffset_.set (x);
}

void t_road_surface_CRG::
hOffset (const hOffset_optional& x)
{
  this->hOffset_ = x;
}


// e_road_surface_CRG_purpose
// 

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (value v)
: ::xml_schema::string (_xsd_e_road_surface_CRG_purpose_literals_[v])
{
}

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (const char* v)
: ::xml_schema::string (v)
{
}

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (const e_road_surface_CRG_purpose& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_surface_CRG_purpose& e_road_surface_CRG_purpose::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_surface_CRG_purpose_literals_[v]);

  return *this;
}


// e_road_surface_CRG_mode
// 

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (value v)
: ::xml_schema::string (_xsd_e_road_surface_CRG_mode_literals_[v])
{
}

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (const char* v)
: ::xml_schema::string (v)
{
}

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (const e_road_surface_CRG_mode& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_surface_CRG_mode& e_road_surface_CRG_mode::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_surface_CRG_mode_literals_[v]);

  return *this;
}


// t_road_railroad
// 

const t_road_railroad::switch_sequence& t_road_railroad::
switch_ () const
{
  return this->switch__;
}

t_road_railroad::switch_sequence& t_road_railroad::
switch_ ()
{
  return this->switch__;
}

void t_road_railroad::
switch_ (const switch_sequence& s)
{
  this->switch__ = s;
}

const t_road_railroad::userData_sequence& t_road_railroad::
userData () const
{
  return this->userData_;
}

t_road_railroad::userData_sequence& t_road_railroad::
userData ()
{
  return this->userData_;
}

void t_road_railroad::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_railroad::include_sequence& t_road_railroad::
include () const
{
  return this->include_;
}

t_road_railroad::include_sequence& t_road_railroad::
include ()
{
  return this->include_;
}

void t_road_railroad::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_railroad::dataQuality_optional& t_road_railroad::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_railroad::dataQuality_optional& t_road_railroad::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_railroad::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_railroad::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_railroad::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_road_railroad_switch
// 

const t_road_railroad_switch::mainTrack_type& t_road_railroad_switch::
mainTrack () const
{
  return this->mainTrack_.get ();
}

t_road_railroad_switch::mainTrack_type& t_road_railroad_switch::
mainTrack ()
{
  return this->mainTrack_.get ();
}

void t_road_railroad_switch::
mainTrack (const mainTrack_type& x)
{
  this->mainTrack_.set (x);
}

void t_road_railroad_switch::
mainTrack (::std::unique_ptr< mainTrack_type > x)
{
  this->mainTrack_.set (std::move (x));
}

const t_road_railroad_switch::sideTrack_type& t_road_railroad_switch::
sideTrack () const
{
  return this->sideTrack_.get ();
}

t_road_railroad_switch::sideTrack_type& t_road_railroad_switch::
sideTrack ()
{
  return this->sideTrack_.get ();
}

void t_road_railroad_switch::
sideTrack (const sideTrack_type& x)
{
  this->sideTrack_.set (x);
}

void t_road_railroad_switch::
sideTrack (::std::unique_ptr< sideTrack_type > x)
{
  this->sideTrack_.set (std::move (x));
}

const t_road_railroad_switch::partner_optional& t_road_railroad_switch::
partner () const
{
  return this->partner_;
}

t_road_railroad_switch::partner_optional& t_road_railroad_switch::
partner ()
{
  return this->partner_;
}

void t_road_railroad_switch::
partner (const partner_type& x)
{
  this->partner_.set (x);
}

void t_road_railroad_switch::
partner (const partner_optional& x)
{
  this->partner_ = x;
}

void t_road_railroad_switch::
partner (::std::unique_ptr< partner_type > x)
{
  this->partner_.set (std::move (x));
}

const t_road_railroad_switch::userData_sequence& t_road_railroad_switch::
userData () const
{
  return this->userData_;
}

t_road_railroad_switch::userData_sequence& t_road_railroad_switch::
userData ()
{
  return this->userData_;
}

void t_road_railroad_switch::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_railroad_switch::include_sequence& t_road_railroad_switch::
include () const
{
  return this->include_;
}

t_road_railroad_switch::include_sequence& t_road_railroad_switch::
include ()
{
  return this->include_;
}

void t_road_railroad_switch::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_railroad_switch::dataQuality_optional& t_road_railroad_switch::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_railroad_switch::dataQuality_optional& t_road_railroad_switch::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_railroad_switch::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_railroad_switch::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_railroad_switch::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_railroad_switch::name_type& t_road_railroad_switch::
name () const
{
  return this->name_.get ();
}

t_road_railroad_switch::name_type& t_road_railroad_switch::
name ()
{
  return this->name_.get ();
}

void t_road_railroad_switch::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_railroad_switch::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road_railroad_switch::id_type& t_road_railroad_switch::
id () const
{
  return this->id_.get ();
}

t_road_railroad_switch::id_type& t_road_railroad_switch::
id ()
{
  return this->id_.get ();
}

void t_road_railroad_switch::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_railroad_switch::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_railroad_switch::position_type& t_road_railroad_switch::
position () const
{
  return this->position_.get ();
}

t_road_railroad_switch::position_type& t_road_railroad_switch::
position ()
{
  return this->position_.get ();
}

void t_road_railroad_switch::
position (const position_type& x)
{
  this->position_.set (x);
}

void t_road_railroad_switch::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}


// e_road_railroad_switch_position
// 

e_road_railroad_switch_position::
e_road_railroad_switch_position (value v)
: ::xml_schema::string (_xsd_e_road_railroad_switch_position_literals_[v])
{
}

e_road_railroad_switch_position::
e_road_railroad_switch_position (const char* v)
: ::xml_schema::string (v)
{
}

e_road_railroad_switch_position::
e_road_railroad_switch_position (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_road_railroad_switch_position::
e_road_railroad_switch_position (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_road_railroad_switch_position::
e_road_railroad_switch_position (const e_road_railroad_switch_position& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_road_railroad_switch_position& e_road_railroad_switch_position::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_road_railroad_switch_position_literals_[v]);

  return *this;
}


// t_road_railroad_switch_mainTrack
// 

const t_road_railroad_switch_mainTrack::userData_sequence& t_road_railroad_switch_mainTrack::
userData () const
{
  return this->userData_;
}

t_road_railroad_switch_mainTrack::userData_sequence& t_road_railroad_switch_mainTrack::
userData ()
{
  return this->userData_;
}

void t_road_railroad_switch_mainTrack::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_railroad_switch_mainTrack::include_sequence& t_road_railroad_switch_mainTrack::
include () const
{
  return this->include_;
}

t_road_railroad_switch_mainTrack::include_sequence& t_road_railroad_switch_mainTrack::
include ()
{
  return this->include_;
}

void t_road_railroad_switch_mainTrack::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_railroad_switch_mainTrack::dataQuality_optional& t_road_railroad_switch_mainTrack::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_railroad_switch_mainTrack::dataQuality_optional& t_road_railroad_switch_mainTrack::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_railroad_switch_mainTrack::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_railroad_switch_mainTrack::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_railroad_switch_mainTrack::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_railroad_switch_mainTrack::id_type& t_road_railroad_switch_mainTrack::
id () const
{
  return this->id_.get ();
}

t_road_railroad_switch_mainTrack::id_type& t_road_railroad_switch_mainTrack::
id ()
{
  return this->id_.get ();
}

void t_road_railroad_switch_mainTrack::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_railroad_switch_mainTrack::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_railroad_switch_mainTrack::s_type& t_road_railroad_switch_mainTrack::
s () const
{
  return this->s_.get ();
}

t_road_railroad_switch_mainTrack::s_type& t_road_railroad_switch_mainTrack::
s ()
{
  return this->s_.get ();
}

void t_road_railroad_switch_mainTrack::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_railroad_switch_mainTrack::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_railroad_switch_mainTrack::dir_type& t_road_railroad_switch_mainTrack::
dir () const
{
  return this->dir_.get ();
}

t_road_railroad_switch_mainTrack::dir_type& t_road_railroad_switch_mainTrack::
dir ()
{
  return this->dir_.get ();
}

void t_road_railroad_switch_mainTrack::
dir (const dir_type& x)
{
  this->dir_.set (x);
}

void t_road_railroad_switch_mainTrack::
dir (::std::unique_ptr< dir_type > x)
{
  this->dir_.set (std::move (x));
}


// t_road_railroad_switch_sideTrack
// 

const t_road_railroad_switch_sideTrack::userData_sequence& t_road_railroad_switch_sideTrack::
userData () const
{
  return this->userData_;
}

t_road_railroad_switch_sideTrack::userData_sequence& t_road_railroad_switch_sideTrack::
userData ()
{
  return this->userData_;
}

void t_road_railroad_switch_sideTrack::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_railroad_switch_sideTrack::include_sequence& t_road_railroad_switch_sideTrack::
include () const
{
  return this->include_;
}

t_road_railroad_switch_sideTrack::include_sequence& t_road_railroad_switch_sideTrack::
include ()
{
  return this->include_;
}

void t_road_railroad_switch_sideTrack::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_railroad_switch_sideTrack::dataQuality_optional& t_road_railroad_switch_sideTrack::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_railroad_switch_sideTrack::dataQuality_optional& t_road_railroad_switch_sideTrack::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_railroad_switch_sideTrack::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_railroad_switch_sideTrack::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_railroad_switch_sideTrack::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_railroad_switch_sideTrack::id_type& t_road_railroad_switch_sideTrack::
id () const
{
  return this->id_.get ();
}

t_road_railroad_switch_sideTrack::id_type& t_road_railroad_switch_sideTrack::
id ()
{
  return this->id_.get ();
}

void t_road_railroad_switch_sideTrack::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_railroad_switch_sideTrack::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_road_railroad_switch_sideTrack::s_type& t_road_railroad_switch_sideTrack::
s () const
{
  return this->s_.get ();
}

t_road_railroad_switch_sideTrack::s_type& t_road_railroad_switch_sideTrack::
s ()
{
  return this->s_.get ();
}

void t_road_railroad_switch_sideTrack::
s (const s_type& x)
{
  this->s_.set (x);
}

void t_road_railroad_switch_sideTrack::
s (::std::unique_ptr< s_type > x)
{
  this->s_.set (std::move (x));
}

const t_road_railroad_switch_sideTrack::dir_type& t_road_railroad_switch_sideTrack::
dir () const
{
  return this->dir_.get ();
}

t_road_railroad_switch_sideTrack::dir_type& t_road_railroad_switch_sideTrack::
dir ()
{
  return this->dir_.get ();
}

void t_road_railroad_switch_sideTrack::
dir (const dir_type& x)
{
  this->dir_.set (x);
}

void t_road_railroad_switch_sideTrack::
dir (::std::unique_ptr< dir_type > x)
{
  this->dir_.set (std::move (x));
}


// t_road_railroad_switch_partner
// 

const t_road_railroad_switch_partner::userData_sequence& t_road_railroad_switch_partner::
userData () const
{
  return this->userData_;
}

t_road_railroad_switch_partner::userData_sequence& t_road_railroad_switch_partner::
userData ()
{
  return this->userData_;
}

void t_road_railroad_switch_partner::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_road_railroad_switch_partner::include_sequence& t_road_railroad_switch_partner::
include () const
{
  return this->include_;
}

t_road_railroad_switch_partner::include_sequence& t_road_railroad_switch_partner::
include ()
{
  return this->include_;
}

void t_road_railroad_switch_partner::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_road_railroad_switch_partner::dataQuality_optional& t_road_railroad_switch_partner::
dataQuality () const
{
  return this->dataQuality_;
}

t_road_railroad_switch_partner::dataQuality_optional& t_road_railroad_switch_partner::
dataQuality ()
{
  return this->dataQuality_;
}

void t_road_railroad_switch_partner::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_road_railroad_switch_partner::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_road_railroad_switch_partner::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_road_railroad_switch_partner::name_optional& t_road_railroad_switch_partner::
name () const
{
  return this->name_;
}

t_road_railroad_switch_partner::name_optional& t_road_railroad_switch_partner::
name ()
{
  return this->name_;
}

void t_road_railroad_switch_partner::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_road_railroad_switch_partner::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_road_railroad_switch_partner::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_road_railroad_switch_partner::id_type& t_road_railroad_switch_partner::
id () const
{
  return this->id_.get ();
}

t_road_railroad_switch_partner::id_type& t_road_railroad_switch_partner::
id ()
{
  return this->id_.get ();
}

void t_road_railroad_switch_partner::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_road_railroad_switch_partner::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// t_controller
// 

const t_controller::control_sequence& t_controller::
control () const
{
  return this->control_;
}

t_controller::control_sequence& t_controller::
control ()
{
  return this->control_;
}

void t_controller::
control (const control_sequence& s)
{
  this->control_ = s;
}

const t_controller::userData_sequence& t_controller::
userData () const
{
  return this->userData_;
}

t_controller::userData_sequence& t_controller::
userData ()
{
  return this->userData_;
}

void t_controller::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_controller::include_sequence& t_controller::
include () const
{
  return this->include_;
}

t_controller::include_sequence& t_controller::
include ()
{
  return this->include_;
}

void t_controller::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_controller::dataQuality_optional& t_controller::
dataQuality () const
{
  return this->dataQuality_;
}

t_controller::dataQuality_optional& t_controller::
dataQuality ()
{
  return this->dataQuality_;
}

void t_controller::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_controller::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_controller::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_controller::id_type& t_controller::
id () const
{
  return this->id_.get ();
}

t_controller::id_type& t_controller::
id ()
{
  return this->id_.get ();
}

void t_controller::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_controller::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_controller::name_optional& t_controller::
name () const
{
  return this->name_;
}

t_controller::name_optional& t_controller::
name ()
{
  return this->name_;
}

void t_controller::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_controller::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_controller::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_controller::sequence_optional& t_controller::
sequence () const
{
  return this->sequence_;
}

t_controller::sequence_optional& t_controller::
sequence ()
{
  return this->sequence_;
}

void t_controller::
sequence (const sequence_type& x)
{
  this->sequence_.set (x);
}

void t_controller::
sequence (const sequence_optional& x)
{
  this->sequence_ = x;
}


// t_controller_control
// 

const t_controller_control::userData_sequence& t_controller_control::
userData () const
{
  return this->userData_;
}

t_controller_control::userData_sequence& t_controller_control::
userData ()
{
  return this->userData_;
}

void t_controller_control::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_controller_control::include_sequence& t_controller_control::
include () const
{
  return this->include_;
}

t_controller_control::include_sequence& t_controller_control::
include ()
{
  return this->include_;
}

void t_controller_control::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_controller_control::dataQuality_optional& t_controller_control::
dataQuality () const
{
  return this->dataQuality_;
}

t_controller_control::dataQuality_optional& t_controller_control::
dataQuality ()
{
  return this->dataQuality_;
}

void t_controller_control::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_controller_control::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_controller_control::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_controller_control::signalId_type& t_controller_control::
signalId () const
{
  return this->signalId_.get ();
}

t_controller_control::signalId_type& t_controller_control::
signalId ()
{
  return this->signalId_.get ();
}

void t_controller_control::
signalId (const signalId_type& x)
{
  this->signalId_.set (x);
}

void t_controller_control::
signalId (::std::unique_ptr< signalId_type > x)
{
  this->signalId_.set (std::move (x));
}

const t_controller_control::type_optional& t_controller_control::
type () const
{
  return this->type_;
}

t_controller_control::type_optional& t_controller_control::
type ()
{
  return this->type_;
}

void t_controller_control::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_controller_control::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_controller_control::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// t_junction
// 

const t_junction::connection_sequence& t_junction::
connection () const
{
  return this->connection_;
}

t_junction::connection_sequence& t_junction::
connection ()
{
  return this->connection_;
}

void t_junction::
connection (const connection_sequence& s)
{
  this->connection_ = s;
}

const t_junction::priority_sequence& t_junction::
priority () const
{
  return this->priority_;
}

t_junction::priority_sequence& t_junction::
priority ()
{
  return this->priority_;
}

void t_junction::
priority (const priority_sequence& s)
{
  this->priority_ = s;
}

const t_junction::controller_sequence& t_junction::
controller () const
{
  return this->controller_;
}

t_junction::controller_sequence& t_junction::
controller ()
{
  return this->controller_;
}

void t_junction::
controller (const controller_sequence& s)
{
  this->controller_ = s;
}

const t_junction::surface_optional& t_junction::
surface () const
{
  return this->surface_;
}

t_junction::surface_optional& t_junction::
surface ()
{
  return this->surface_;
}

void t_junction::
surface (const surface_type& x)
{
  this->surface_.set (x);
}

void t_junction::
surface (const surface_optional& x)
{
  this->surface_ = x;
}

void t_junction::
surface (::std::unique_ptr< surface_type > x)
{
  this->surface_.set (std::move (x));
}

const t_junction::userData_sequence& t_junction::
userData () const
{
  return this->userData_;
}

t_junction::userData_sequence& t_junction::
userData ()
{
  return this->userData_;
}

void t_junction::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction::include_sequence& t_junction::
include () const
{
  return this->include_;
}

t_junction::include_sequence& t_junction::
include ()
{
  return this->include_;
}

void t_junction::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction::dataQuality_optional& t_junction::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction::dataQuality_optional& t_junction::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junction::name_optional& t_junction::
name () const
{
  return this->name_;
}

t_junction::name_optional& t_junction::
name ()
{
  return this->name_;
}

void t_junction::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_junction::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_junction::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_junction::id_type& t_junction::
id () const
{
  return this->id_.get ();
}

t_junction::id_type& t_junction::
id ()
{
  return this->id_.get ();
}

void t_junction::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_junction::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_junction::type_optional& t_junction::
type () const
{
  return this->type_;
}

t_junction::type_optional& t_junction::
type ()
{
  return this->type_;
}

void t_junction::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_junction::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_junction::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// e_junction_type
// 

e_junction_type::
e_junction_type (value v)
: ::xml_schema::string (_xsd_e_junction_type_literals_[v])
{
}

e_junction_type::
e_junction_type (const char* v)
: ::xml_schema::string (v)
{
}

e_junction_type::
e_junction_type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_junction_type::
e_junction_type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_junction_type::
e_junction_type (const e_junction_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_junction_type& e_junction_type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_junction_type_literals_[v]);

  return *this;
}


// t_junction_connection
// 

const t_junction_connection::predecessor_optional& t_junction_connection::
predecessor () const
{
  return this->predecessor_;
}

t_junction_connection::predecessor_optional& t_junction_connection::
predecessor ()
{
  return this->predecessor_;
}

void t_junction_connection::
predecessor (const predecessor_type& x)
{
  this->predecessor_.set (x);
}

void t_junction_connection::
predecessor (const predecessor_optional& x)
{
  this->predecessor_ = x;
}

void t_junction_connection::
predecessor (::std::unique_ptr< predecessor_type > x)
{
  this->predecessor_.set (std::move (x));
}

const t_junction_connection::successor_optional& t_junction_connection::
successor () const
{
  return this->successor_;
}

t_junction_connection::successor_optional& t_junction_connection::
successor ()
{
  return this->successor_;
}

void t_junction_connection::
successor (const successor_type& x)
{
  this->successor_.set (x);
}

void t_junction_connection::
successor (const successor_optional& x)
{
  this->successor_ = x;
}

void t_junction_connection::
successor (::std::unique_ptr< successor_type > x)
{
  this->successor_.set (std::move (x));
}

const t_junction_connection::laneLink_sequence& t_junction_connection::
laneLink () const
{
  return this->laneLink_;
}

t_junction_connection::laneLink_sequence& t_junction_connection::
laneLink ()
{
  return this->laneLink_;
}

void t_junction_connection::
laneLink (const laneLink_sequence& s)
{
  this->laneLink_ = s;
}

const t_junction_connection::userData_sequence& t_junction_connection::
userData () const
{
  return this->userData_;
}

t_junction_connection::userData_sequence& t_junction_connection::
userData ()
{
  return this->userData_;
}

void t_junction_connection::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction_connection::include_sequence& t_junction_connection::
include () const
{
  return this->include_;
}

t_junction_connection::include_sequence& t_junction_connection::
include ()
{
  return this->include_;
}

void t_junction_connection::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction_connection::dataQuality_optional& t_junction_connection::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction_connection::dataQuality_optional& t_junction_connection::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction_connection::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction_connection::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction_connection::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junction_connection::id_type& t_junction_connection::
id () const
{
  return this->id_.get ();
}

t_junction_connection::id_type& t_junction_connection::
id ()
{
  return this->id_.get ();
}

void t_junction_connection::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_junction_connection::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_junction_connection::incomingRoad_type& t_junction_connection::
incomingRoad () const
{
  return this->incomingRoad_.get ();
}

t_junction_connection::incomingRoad_type& t_junction_connection::
incomingRoad ()
{
  return this->incomingRoad_.get ();
}

void t_junction_connection::
incomingRoad (const incomingRoad_type& x)
{
  this->incomingRoad_.set (x);
}

void t_junction_connection::
incomingRoad (::std::unique_ptr< incomingRoad_type > x)
{
  this->incomingRoad_.set (std::move (x));
}

const t_junction_connection::connectingRoad_type& t_junction_connection::
connectingRoad () const
{
  return this->connectingRoad_.get ();
}

t_junction_connection::connectingRoad_type& t_junction_connection::
connectingRoad ()
{
  return this->connectingRoad_.get ();
}

void t_junction_connection::
connectingRoad (const connectingRoad_type& x)
{
  this->connectingRoad_.set (x);
}

void t_junction_connection::
connectingRoad (::std::unique_ptr< connectingRoad_type > x)
{
  this->connectingRoad_.set (std::move (x));
}

const t_junction_connection::contactPoint_type& t_junction_connection::
contactPoint () const
{
  return this->contactPoint_.get ();
}

t_junction_connection::contactPoint_type& t_junction_connection::
contactPoint ()
{
  return this->contactPoint_.get ();
}

void t_junction_connection::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void t_junction_connection::
contactPoint (::std::unique_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (std::move (x));
}

const t_junction_connection::connectionMaster_optional& t_junction_connection::
connectionMaster () const
{
  return this->connectionMaster_;
}

t_junction_connection::connectionMaster_optional& t_junction_connection::
connectionMaster ()
{
  return this->connectionMaster_;
}

void t_junction_connection::
connectionMaster (const connectionMaster_type& x)
{
  this->connectionMaster_.set (x);
}

void t_junction_connection::
connectionMaster (const connectionMaster_optional& x)
{
  this->connectionMaster_ = x;
}

void t_junction_connection::
connectionMaster (::std::unique_ptr< connectionMaster_type > x)
{
  this->connectionMaster_.set (std::move (x));
}

const t_junction_connection::type_optional& t_junction_connection::
type () const
{
  return this->type_;
}

t_junction_connection::type_optional& t_junction_connection::
type ()
{
  return this->type_;
}

void t_junction_connection::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_junction_connection::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_junction_connection::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// t_junction_predecessorSuccessor
// 

const t_junction_predecessorSuccessor::userData_sequence& t_junction_predecessorSuccessor::
userData () const
{
  return this->userData_;
}

t_junction_predecessorSuccessor::userData_sequence& t_junction_predecessorSuccessor::
userData ()
{
  return this->userData_;
}

void t_junction_predecessorSuccessor::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction_predecessorSuccessor::include_sequence& t_junction_predecessorSuccessor::
include () const
{
  return this->include_;
}

t_junction_predecessorSuccessor::include_sequence& t_junction_predecessorSuccessor::
include ()
{
  return this->include_;
}

void t_junction_predecessorSuccessor::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction_predecessorSuccessor::dataQuality_optional& t_junction_predecessorSuccessor::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction_predecessorSuccessor::dataQuality_optional& t_junction_predecessorSuccessor::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction_predecessorSuccessor::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction_predecessorSuccessor::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction_predecessorSuccessor::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junction_predecessorSuccessor::elementType_type& t_junction_predecessorSuccessor::
elementType () const
{
  return this->elementType_.get ();
}

const t_junction_predecessorSuccessor::elementType_type& t_junction_predecessorSuccessor::
elementType_default_value ()
{
  return elementType_default_value_;
}

const t_junction_predecessorSuccessor::elementId_type& t_junction_predecessorSuccessor::
elementId () const
{
  return this->elementId_.get ();
}

t_junction_predecessorSuccessor::elementId_type& t_junction_predecessorSuccessor::
elementId ()
{
  return this->elementId_.get ();
}

void t_junction_predecessorSuccessor::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void t_junction_predecessorSuccessor::
elementId (::std::unique_ptr< elementId_type > x)
{
  this->elementId_.set (std::move (x));
}

const t_junction_predecessorSuccessor::elementS_type& t_junction_predecessorSuccessor::
elementS () const
{
  return this->elementS_.get ();
}

t_junction_predecessorSuccessor::elementS_type& t_junction_predecessorSuccessor::
elementS ()
{
  return this->elementS_.get ();
}

void t_junction_predecessorSuccessor::
elementS (const elementS_type& x)
{
  this->elementS_.set (x);
}

void t_junction_predecessorSuccessor::
elementS (::std::unique_ptr< elementS_type > x)
{
  this->elementS_.set (std::move (x));
}

const t_junction_predecessorSuccessor::elementDir_type& t_junction_predecessorSuccessor::
elementDir () const
{
  return this->elementDir_.get ();
}

t_junction_predecessorSuccessor::elementDir_type& t_junction_predecessorSuccessor::
elementDir ()
{
  return this->elementDir_.get ();
}

void t_junction_predecessorSuccessor::
elementDir (const elementDir_type& x)
{
  this->elementDir_.set (x);
}

void t_junction_predecessorSuccessor::
elementDir (::std::unique_ptr< elementDir_type > x)
{
  this->elementDir_.set (std::move (x));
}


// t_junction_connection_laneLink
// 

const t_junction_connection_laneLink::userData_sequence& t_junction_connection_laneLink::
userData () const
{
  return this->userData_;
}

t_junction_connection_laneLink::userData_sequence& t_junction_connection_laneLink::
userData ()
{
  return this->userData_;
}

void t_junction_connection_laneLink::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction_connection_laneLink::include_sequence& t_junction_connection_laneLink::
include () const
{
  return this->include_;
}

t_junction_connection_laneLink::include_sequence& t_junction_connection_laneLink::
include ()
{
  return this->include_;
}

void t_junction_connection_laneLink::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction_connection_laneLink::dataQuality_optional& t_junction_connection_laneLink::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction_connection_laneLink::dataQuality_optional& t_junction_connection_laneLink::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction_connection_laneLink::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction_connection_laneLink::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction_connection_laneLink::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junction_connection_laneLink::from_type& t_junction_connection_laneLink::
from () const
{
  return this->from_.get ();
}

t_junction_connection_laneLink::from_type& t_junction_connection_laneLink::
from ()
{
  return this->from_.get ();
}

void t_junction_connection_laneLink::
from (const from_type& x)
{
  this->from_.set (x);
}

const t_junction_connection_laneLink::to_type& t_junction_connection_laneLink::
to () const
{
  return this->to_.get ();
}

t_junction_connection_laneLink::to_type& t_junction_connection_laneLink::
to ()
{
  return this->to_.get ();
}

void t_junction_connection_laneLink::
to (const to_type& x)
{
  this->to_.set (x);
}


// t_junction_priority
// 

const t_junction_priority::userData_sequence& t_junction_priority::
userData () const
{
  return this->userData_;
}

t_junction_priority::userData_sequence& t_junction_priority::
userData ()
{
  return this->userData_;
}

void t_junction_priority::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction_priority::include_sequence& t_junction_priority::
include () const
{
  return this->include_;
}

t_junction_priority::include_sequence& t_junction_priority::
include ()
{
  return this->include_;
}

void t_junction_priority::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction_priority::dataQuality_optional& t_junction_priority::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction_priority::dataQuality_optional& t_junction_priority::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction_priority::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction_priority::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction_priority::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junction_priority::high_optional& t_junction_priority::
high () const
{
  return this->high_;
}

t_junction_priority::high_optional& t_junction_priority::
high ()
{
  return this->high_;
}

void t_junction_priority::
high (const high_type& x)
{
  this->high_.set (x);
}

void t_junction_priority::
high (const high_optional& x)
{
  this->high_ = x;
}

void t_junction_priority::
high (::std::unique_ptr< high_type > x)
{
  this->high_.set (std::move (x));
}

const t_junction_priority::low_optional& t_junction_priority::
low () const
{
  return this->low_;
}

t_junction_priority::low_optional& t_junction_priority::
low ()
{
  return this->low_;
}

void t_junction_priority::
low (const low_type& x)
{
  this->low_.set (x);
}

void t_junction_priority::
low (const low_optional& x)
{
  this->low_ = x;
}

void t_junction_priority::
low (::std::unique_ptr< low_type > x)
{
  this->low_.set (std::move (x));
}


// t_junction_controller
// 

const t_junction_controller::userData_sequence& t_junction_controller::
userData () const
{
  return this->userData_;
}

t_junction_controller::userData_sequence& t_junction_controller::
userData ()
{
  return this->userData_;
}

void t_junction_controller::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction_controller::include_sequence& t_junction_controller::
include () const
{
  return this->include_;
}

t_junction_controller::include_sequence& t_junction_controller::
include ()
{
  return this->include_;
}

void t_junction_controller::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction_controller::dataQuality_optional& t_junction_controller::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction_controller::dataQuality_optional& t_junction_controller::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction_controller::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction_controller::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction_controller::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junction_controller::id_type& t_junction_controller::
id () const
{
  return this->id_.get ();
}

t_junction_controller::id_type& t_junction_controller::
id ()
{
  return this->id_.get ();
}

void t_junction_controller::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_junction_controller::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_junction_controller::type_optional& t_junction_controller::
type () const
{
  return this->type_;
}

t_junction_controller::type_optional& t_junction_controller::
type ()
{
  return this->type_;
}

void t_junction_controller::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_junction_controller::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_junction_controller::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const t_junction_controller::sequence_optional& t_junction_controller::
sequence () const
{
  return this->sequence_;
}

t_junction_controller::sequence_optional& t_junction_controller::
sequence ()
{
  return this->sequence_;
}

void t_junction_controller::
sequence (const sequence_type& x)
{
  this->sequence_.set (x);
}

void t_junction_controller::
sequence (const sequence_optional& x)
{
  this->sequence_ = x;
}


// t_junction_surface
// 

const t_junction_surface::CRG_sequence& t_junction_surface::
CRG () const
{
  return this->CRG_;
}

t_junction_surface::CRG_sequence& t_junction_surface::
CRG ()
{
  return this->CRG_;
}

void t_junction_surface::
CRG (const CRG_sequence& s)
{
  this->CRG_ = s;
}

const t_junction_surface::userData_sequence& t_junction_surface::
userData () const
{
  return this->userData_;
}

t_junction_surface::userData_sequence& t_junction_surface::
userData ()
{
  return this->userData_;
}

void t_junction_surface::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction_surface::include_sequence& t_junction_surface::
include () const
{
  return this->include_;
}

t_junction_surface::include_sequence& t_junction_surface::
include ()
{
  return this->include_;
}

void t_junction_surface::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction_surface::dataQuality_optional& t_junction_surface::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction_surface::dataQuality_optional& t_junction_surface::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction_surface::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction_surface::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction_surface::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


// t_junction_surface_CRG
// 

const t_junction_surface_CRG::userData_sequence& t_junction_surface_CRG::
userData () const
{
  return this->userData_;
}

t_junction_surface_CRG::userData_sequence& t_junction_surface_CRG::
userData ()
{
  return this->userData_;
}

void t_junction_surface_CRG::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junction_surface_CRG::include_sequence& t_junction_surface_CRG::
include () const
{
  return this->include_;
}

t_junction_surface_CRG::include_sequence& t_junction_surface_CRG::
include ()
{
  return this->include_;
}

void t_junction_surface_CRG::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junction_surface_CRG::dataQuality_optional& t_junction_surface_CRG::
dataQuality () const
{
  return this->dataQuality_;
}

t_junction_surface_CRG::dataQuality_optional& t_junction_surface_CRG::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junction_surface_CRG::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junction_surface_CRG::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junction_surface_CRG::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junction_surface_CRG::file_type& t_junction_surface_CRG::
file () const
{
  return this->file_.get ();
}

t_junction_surface_CRG::file_type& t_junction_surface_CRG::
file ()
{
  return this->file_.get ();
}

void t_junction_surface_CRG::
file (const file_type& x)
{
  this->file_.set (x);
}

void t_junction_surface_CRG::
file (::std::unique_ptr< file_type > x)
{
  this->file_.set (std::move (x));
}

const t_junction_surface_CRG::mode_type& t_junction_surface_CRG::
mode () const
{
  return this->mode_.get ();
}

const t_junction_surface_CRG::mode_type& t_junction_surface_CRG::
mode_default_value ()
{
  return mode_default_value_;
}

const t_junction_surface_CRG::purpose_optional& t_junction_surface_CRG::
purpose () const
{
  return this->purpose_;
}

t_junction_surface_CRG::purpose_optional& t_junction_surface_CRG::
purpose ()
{
  return this->purpose_;
}

void t_junction_surface_CRG::
purpose (const purpose_type& x)
{
  this->purpose_.set (x);
}

void t_junction_surface_CRG::
purpose (const purpose_optional& x)
{
  this->purpose_ = x;
}

void t_junction_surface_CRG::
purpose (::std::unique_ptr< purpose_type > x)
{
  this->purpose_.set (std::move (x));
}

const t_junction_surface_CRG::zOffset_optional& t_junction_surface_CRG::
zOffset () const
{
  return this->zOffset_;
}

t_junction_surface_CRG::zOffset_optional& t_junction_surface_CRG::
zOffset ()
{
  return this->zOffset_;
}

void t_junction_surface_CRG::
zOffset (const zOffset_type& x)
{
  this->zOffset_.set (x);
}

void t_junction_surface_CRG::
zOffset (const zOffset_optional& x)
{
  this->zOffset_ = x;
}

const t_junction_surface_CRG::zScale_optional& t_junction_surface_CRG::
zScale () const
{
  return this->zScale_;
}

t_junction_surface_CRG::zScale_optional& t_junction_surface_CRG::
zScale ()
{
  return this->zScale_;
}

void t_junction_surface_CRG::
zScale (const zScale_type& x)
{
  this->zScale_.set (x);
}

void t_junction_surface_CRG::
zScale (const zScale_optional& x)
{
  this->zScale_ = x;
}


// t_junctionGroup
// 

const t_junctionGroup::junctionReference_sequence& t_junctionGroup::
junctionReference () const
{
  return this->junctionReference_;
}

t_junctionGroup::junctionReference_sequence& t_junctionGroup::
junctionReference ()
{
  return this->junctionReference_;
}

void t_junctionGroup::
junctionReference (const junctionReference_sequence& s)
{
  this->junctionReference_ = s;
}

const t_junctionGroup::userData_sequence& t_junctionGroup::
userData () const
{
  return this->userData_;
}

t_junctionGroup::userData_sequence& t_junctionGroup::
userData ()
{
  return this->userData_;
}

void t_junctionGroup::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junctionGroup::include_sequence& t_junctionGroup::
include () const
{
  return this->include_;
}

t_junctionGroup::include_sequence& t_junctionGroup::
include ()
{
  return this->include_;
}

void t_junctionGroup::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junctionGroup::dataQuality_optional& t_junctionGroup::
dataQuality () const
{
  return this->dataQuality_;
}

t_junctionGroup::dataQuality_optional& t_junctionGroup::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junctionGroup::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junctionGroup::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junctionGroup::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junctionGroup::name_optional& t_junctionGroup::
name () const
{
  return this->name_;
}

t_junctionGroup::name_optional& t_junctionGroup::
name ()
{
  return this->name_;
}

void t_junctionGroup::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_junctionGroup::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_junctionGroup::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_junctionGroup::id_type& t_junctionGroup::
id () const
{
  return this->id_.get ();
}

t_junctionGroup::id_type& t_junctionGroup::
id ()
{
  return this->id_.get ();
}

void t_junctionGroup::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_junctionGroup::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_junctionGroup::type_type& t_junctionGroup::
type () const
{
  return this->type_.get ();
}

t_junctionGroup::type_type& t_junctionGroup::
type ()
{
  return this->type_.get ();
}

void t_junctionGroup::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_junctionGroup::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// e_junctionGroup_type
// 

e_junctionGroup_type::
e_junctionGroup_type (value v)
: ::xml_schema::string (_xsd_e_junctionGroup_type_literals_[v])
{
}

e_junctionGroup_type::
e_junctionGroup_type (const char* v)
: ::xml_schema::string (v)
{
}

e_junctionGroup_type::
e_junctionGroup_type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_junctionGroup_type::
e_junctionGroup_type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_junctionGroup_type::
e_junctionGroup_type (const e_junctionGroup_type& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_junctionGroup_type& e_junctionGroup_type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_junctionGroup_type_literals_[v]);

  return *this;
}


// t_junctionGroup_junctionReference
// 

const t_junctionGroup_junctionReference::userData_sequence& t_junctionGroup_junctionReference::
userData () const
{
  return this->userData_;
}

t_junctionGroup_junctionReference::userData_sequence& t_junctionGroup_junctionReference::
userData ()
{
  return this->userData_;
}

void t_junctionGroup_junctionReference::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_junctionGroup_junctionReference::include_sequence& t_junctionGroup_junctionReference::
include () const
{
  return this->include_;
}

t_junctionGroup_junctionReference::include_sequence& t_junctionGroup_junctionReference::
include ()
{
  return this->include_;
}

void t_junctionGroup_junctionReference::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_junctionGroup_junctionReference::dataQuality_optional& t_junctionGroup_junctionReference::
dataQuality () const
{
  return this->dataQuality_;
}

t_junctionGroup_junctionReference::dataQuality_optional& t_junctionGroup_junctionReference::
dataQuality ()
{
  return this->dataQuality_;
}

void t_junctionGroup_junctionReference::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_junctionGroup_junctionReference::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_junctionGroup_junctionReference::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_junctionGroup_junctionReference::junction_type& t_junctionGroup_junctionReference::
junction () const
{
  return this->junction_.get ();
}

t_junctionGroup_junctionReference::junction_type& t_junctionGroup_junctionReference::
junction ()
{
  return this->junction_.get ();
}

void t_junctionGroup_junctionReference::
junction (const junction_type& x)
{
  this->junction_.set (x);
}

void t_junctionGroup_junctionReference::
junction (::std::unique_ptr< junction_type > x)
{
  this->junction_.set (std::move (x));
}


// t_station
// 

const t_station::platform_sequence& t_station::
platform () const
{
  return this->platform_;
}

t_station::platform_sequence& t_station::
platform ()
{
  return this->platform_;
}

void t_station::
platform (const platform_sequence& s)
{
  this->platform_ = s;
}

const t_station::userData_sequence& t_station::
userData () const
{
  return this->userData_;
}

t_station::userData_sequence& t_station::
userData ()
{
  return this->userData_;
}

void t_station::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_station::include_sequence& t_station::
include () const
{
  return this->include_;
}

t_station::include_sequence& t_station::
include ()
{
  return this->include_;
}

void t_station::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_station::dataQuality_optional& t_station::
dataQuality () const
{
  return this->dataQuality_;
}

t_station::dataQuality_optional& t_station::
dataQuality ()
{
  return this->dataQuality_;
}

void t_station::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_station::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_station::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_station::name_type& t_station::
name () const
{
  return this->name_.get ();
}

t_station::name_type& t_station::
name ()
{
  return this->name_.get ();
}

void t_station::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_station::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_station::id_type& t_station::
id () const
{
  return this->id_.get ();
}

t_station::id_type& t_station::
id ()
{
  return this->id_.get ();
}

void t_station::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_station::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const t_station::type_optional& t_station::
type () const
{
  return this->type_;
}

t_station::type_optional& t_station::
type ()
{
  return this->type_;
}

void t_station::
type (const type_type& x)
{
  this->type_.set (x);
}

void t_station::
type (const type_optional& x)
{
  this->type_ = x;
}

void t_station::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// e_station_type
// 

e_station_type::
e_station_type (value v)
: ::xml_schema::string (_xsd_e_station_type_literals_[v])
{
}

e_station_type::
e_station_type (const char* v)
: ::xml_schema::string (v)
{
}

e_station_type::
e_station_type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_station_type::
e_station_type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_station_type::
e_station_type (const e_station_type& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_station_type& e_station_type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_station_type_literals_[v]);

  return *this;
}


// t_station_platform
// 

const t_station_platform::segment_sequence& t_station_platform::
segment () const
{
  return this->segment_;
}

t_station_platform::segment_sequence& t_station_platform::
segment ()
{
  return this->segment_;
}

void t_station_platform::
segment (const segment_sequence& s)
{
  this->segment_ = s;
}

const t_station_platform::userData_sequence& t_station_platform::
userData () const
{
  return this->userData_;
}

t_station_platform::userData_sequence& t_station_platform::
userData ()
{
  return this->userData_;
}

void t_station_platform::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_station_platform::include_sequence& t_station_platform::
include () const
{
  return this->include_;
}

t_station_platform::include_sequence& t_station_platform::
include ()
{
  return this->include_;
}

void t_station_platform::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_station_platform::dataQuality_optional& t_station_platform::
dataQuality () const
{
  return this->dataQuality_;
}

t_station_platform::dataQuality_optional& t_station_platform::
dataQuality ()
{
  return this->dataQuality_;
}

void t_station_platform::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_station_platform::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_station_platform::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_station_platform::name_optional& t_station_platform::
name () const
{
  return this->name_;
}

t_station_platform::name_optional& t_station_platform::
name ()
{
  return this->name_;
}

void t_station_platform::
name (const name_type& x)
{
  this->name_.set (x);
}

void t_station_platform::
name (const name_optional& x)
{
  this->name_ = x;
}

void t_station_platform::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const t_station_platform::id_type& t_station_platform::
id () const
{
  return this->id_.get ();
}

t_station_platform::id_type& t_station_platform::
id ()
{
  return this->id_.get ();
}

void t_station_platform::
id (const id_type& x)
{
  this->id_.set (x);
}

void t_station_platform::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// t_station_platform_segment
// 

const t_station_platform_segment::userData_sequence& t_station_platform_segment::
userData () const
{
  return this->userData_;
}

t_station_platform_segment::userData_sequence& t_station_platform_segment::
userData ()
{
  return this->userData_;
}

void t_station_platform_segment::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const t_station_platform_segment::include_sequence& t_station_platform_segment::
include () const
{
  return this->include_;
}

t_station_platform_segment::include_sequence& t_station_platform_segment::
include ()
{
  return this->include_;
}

void t_station_platform_segment::
include (const include_sequence& s)
{
  this->include_ = s;
}

const t_station_platform_segment::dataQuality_optional& t_station_platform_segment::
dataQuality () const
{
  return this->dataQuality_;
}

t_station_platform_segment::dataQuality_optional& t_station_platform_segment::
dataQuality ()
{
  return this->dataQuality_;
}

void t_station_platform_segment::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void t_station_platform_segment::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void t_station_platform_segment::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}

const t_station_platform_segment::roadId_type& t_station_platform_segment::
roadId () const
{
  return this->roadId_.get ();
}

t_station_platform_segment::roadId_type& t_station_platform_segment::
roadId ()
{
  return this->roadId_.get ();
}

void t_station_platform_segment::
roadId (const roadId_type& x)
{
  this->roadId_.set (x);
}

void t_station_platform_segment::
roadId (::std::unique_ptr< roadId_type > x)
{
  this->roadId_.set (std::move (x));
}

const t_station_platform_segment::sStart_type& t_station_platform_segment::
sStart () const
{
  return this->sStart_.get ();
}

t_station_platform_segment::sStart_type& t_station_platform_segment::
sStart ()
{
  return this->sStart_.get ();
}

void t_station_platform_segment::
sStart (const sStart_type& x)
{
  this->sStart_.set (x);
}

void t_station_platform_segment::
sStart (::std::unique_ptr< sStart_type > x)
{
  this->sStart_.set (std::move (x));
}

const t_station_platform_segment::sEnd_type& t_station_platform_segment::
sEnd () const
{
  return this->sEnd_.get ();
}

t_station_platform_segment::sEnd_type& t_station_platform_segment::
sEnd ()
{
  return this->sEnd_.get ();
}

void t_station_platform_segment::
sEnd (const sEnd_type& x)
{
  this->sEnd_.set (x);
}

void t_station_platform_segment::
sEnd (::std::unique_ptr< sEnd_type > x)
{
  this->sEnd_.set (std::move (x));
}

const t_station_platform_segment::side_type& t_station_platform_segment::
side () const
{
  return this->side_.get ();
}

t_station_platform_segment::side_type& t_station_platform_segment::
side ()
{
  return this->side_.get ();
}

void t_station_platform_segment::
side (const side_type& x)
{
  this->side_.set (x);
}

void t_station_platform_segment::
side (::std::unique_ptr< side_type > x)
{
  this->side_.set (std::move (x));
}


// e_station_platform_segment_side
// 

e_station_platform_segment_side::
e_station_platform_segment_side (value v)
: ::xml_schema::string (_xsd_e_station_platform_segment_side_literals_[v])
{
}

e_station_platform_segment_side::
e_station_platform_segment_side (const char* v)
: ::xml_schema::string (v)
{
}

e_station_platform_segment_side::
e_station_platform_segment_side (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_station_platform_segment_side::
e_station_platform_segment_side (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_station_platform_segment_side::
e_station_platform_segment_side (const e_station_platform_segment_side& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_station_platform_segment_side& e_station_platform_segment_side::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_station_platform_segment_side_literals_[v]);

  return *this;
}


// t_userData
// 

const t_userData::code_type& t_userData::
code () const
{
  return this->code_.get ();
}

t_userData::code_type& t_userData::
code ()
{
  return this->code_.get ();
}

void t_userData::
code (const code_type& x)
{
  this->code_.set (x);
}

void t_userData::
code (::std::unique_ptr< code_type > x)
{
  this->code_.set (std::move (x));
}

const t_userData::value_type& t_userData::
value () const
{
  return this->value_.get ();
}

t_userData::value_type& t_userData::
value ()
{
  return this->value_.get ();
}

void t_userData::
value (const value_type& x)
{
  this->value_.set (x);
}

void t_userData::
value (::std::unique_ptr< value_type > x)
{
  this->value_.set (std::move (x));
}


// t_include
// 

const t_include::file_type& t_include::
file () const
{
  return this->file_.get ();
}

t_include::file_type& t_include::
file ()
{
  return this->file_.get ();
}

void t_include::
file (const file_type& x)
{
  this->file_.set (x);
}

void t_include::
file (::std::unique_ptr< file_type > x)
{
  this->file_.set (std::move (x));
}


// t_dataQuality
// 

const t_dataQuality::error_optional& t_dataQuality::
error () const
{
  return this->error_;
}

t_dataQuality::error_optional& t_dataQuality::
error ()
{
  return this->error_;
}

void t_dataQuality::
error (const error_type& x)
{
  this->error_.set (x);
}

void t_dataQuality::
error (const error_optional& x)
{
  this->error_ = x;
}

void t_dataQuality::
error (::std::unique_ptr< error_type > x)
{
  this->error_.set (std::move (x));
}

const t_dataQuality::rawData_optional& t_dataQuality::
rawData () const
{
  return this->rawData_;
}

t_dataQuality::rawData_optional& t_dataQuality::
rawData ()
{
  return this->rawData_;
}

void t_dataQuality::
rawData (const rawData_type& x)
{
  this->rawData_.set (x);
}

void t_dataQuality::
rawData (const rawData_optional& x)
{
  this->rawData_ = x;
}

void t_dataQuality::
rawData (::std::unique_ptr< rawData_type > x)
{
  this->rawData_.set (std::move (x));
}


// t_dataQuality_Error
// 

const t_dataQuality_Error::xyAbsolute_type& t_dataQuality_Error::
xyAbsolute () const
{
  return this->xyAbsolute_.get ();
}

t_dataQuality_Error::xyAbsolute_type& t_dataQuality_Error::
xyAbsolute ()
{
  return this->xyAbsolute_.get ();
}

void t_dataQuality_Error::
xyAbsolute (const xyAbsolute_type& x)
{
  this->xyAbsolute_.set (x);
}

const t_dataQuality_Error::zAbsolute_type& t_dataQuality_Error::
zAbsolute () const
{
  return this->zAbsolute_.get ();
}

t_dataQuality_Error::zAbsolute_type& t_dataQuality_Error::
zAbsolute ()
{
  return this->zAbsolute_.get ();
}

void t_dataQuality_Error::
zAbsolute (const zAbsolute_type& x)
{
  this->zAbsolute_.set (x);
}

const t_dataQuality_Error::xyRelative_type& t_dataQuality_Error::
xyRelative () const
{
  return this->xyRelative_.get ();
}

t_dataQuality_Error::xyRelative_type& t_dataQuality_Error::
xyRelative ()
{
  return this->xyRelative_.get ();
}

void t_dataQuality_Error::
xyRelative (const xyRelative_type& x)
{
  this->xyRelative_.set (x);
}

const t_dataQuality_Error::zRelative_type& t_dataQuality_Error::
zRelative () const
{
  return this->zRelative_.get ();
}

t_dataQuality_Error::zRelative_type& t_dataQuality_Error::
zRelative ()
{
  return this->zRelative_.get ();
}

void t_dataQuality_Error::
zRelative (const zRelative_type& x)
{
  this->zRelative_.set (x);
}


// t_dataQuality_RawData
// 

const t_dataQuality_RawData::date_type& t_dataQuality_RawData::
date () const
{
  return this->date_.get ();
}

t_dataQuality_RawData::date_type& t_dataQuality_RawData::
date ()
{
  return this->date_.get ();
}

void t_dataQuality_RawData::
date (const date_type& x)
{
  this->date_.set (x);
}

void t_dataQuality_RawData::
date (::std::unique_ptr< date_type > x)
{
  this->date_.set (std::move (x));
}

const t_dataQuality_RawData::source_type& t_dataQuality_RawData::
source () const
{
  return this->source_.get ();
}

t_dataQuality_RawData::source_type& t_dataQuality_RawData::
source ()
{
  return this->source_.get ();
}

void t_dataQuality_RawData::
source (const source_type& x)
{
  this->source_.set (x);
}

void t_dataQuality_RawData::
source (::std::unique_ptr< source_type > x)
{
  this->source_.set (std::move (x));
}

const t_dataQuality_RawData::sourceComment_optional& t_dataQuality_RawData::
sourceComment () const
{
  return this->sourceComment_;
}

t_dataQuality_RawData::sourceComment_optional& t_dataQuality_RawData::
sourceComment ()
{
  return this->sourceComment_;
}

void t_dataQuality_RawData::
sourceComment (const sourceComment_type& x)
{
  this->sourceComment_.set (x);
}

void t_dataQuality_RawData::
sourceComment (const sourceComment_optional& x)
{
  this->sourceComment_ = x;
}

void t_dataQuality_RawData::
sourceComment (::std::unique_ptr< sourceComment_type > x)
{
  this->sourceComment_.set (std::move (x));
}

const t_dataQuality_RawData::postProcessing_type& t_dataQuality_RawData::
postProcessing () const
{
  return this->postProcessing_.get ();
}

t_dataQuality_RawData::postProcessing_type& t_dataQuality_RawData::
postProcessing ()
{
  return this->postProcessing_.get ();
}

void t_dataQuality_RawData::
postProcessing (const postProcessing_type& x)
{
  this->postProcessing_.set (x);
}

void t_dataQuality_RawData::
postProcessing (::std::unique_ptr< postProcessing_type > x)
{
  this->postProcessing_.set (std::move (x));
}

const t_dataQuality_RawData::postProcessingComment_optional& t_dataQuality_RawData::
postProcessingComment () const
{
  return this->postProcessingComment_;
}

t_dataQuality_RawData::postProcessingComment_optional& t_dataQuality_RawData::
postProcessingComment ()
{
  return this->postProcessingComment_;
}

void t_dataQuality_RawData::
postProcessingComment (const postProcessingComment_type& x)
{
  this->postProcessingComment_.set (x);
}

void t_dataQuality_RawData::
postProcessingComment (const postProcessingComment_optional& x)
{
  this->postProcessingComment_ = x;
}

void t_dataQuality_RawData::
postProcessingComment (::std::unique_ptr< postProcessingComment_type > x)
{
  this->postProcessingComment_.set (std::move (x));
}


// e_dataQuality_RawData_Source
// 

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (value v)
: ::xml_schema::string (_xsd_e_dataQuality_RawData_Source_literals_[v])
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const char* v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const e_dataQuality_RawData_Source& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_dataQuality_RawData_Source& e_dataQuality_RawData_Source::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_dataQuality_RawData_Source_literals_[v]);

  return *this;
}


// e_dataQuality_RawData_PostProcessing
// 

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (value v)
: ::xml_schema::string (_xsd_e_dataQuality_RawData_PostProcessing_literals_[v])
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const char* v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const e_dataQuality_RawData_PostProcessing& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_dataQuality_RawData_PostProcessing& e_dataQuality_RawData_PostProcessing::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_dataQuality_RawData_PostProcessing_literals_[v]);

  return *this;
}


// e_unitDistance
// 

e_unitDistance::
e_unitDistance (value v)
: ::xml_schema::string (_xsd_e_unitDistance_literals_[v])
{
}

e_unitDistance::
e_unitDistance (const char* v)
: ::xml_schema::string (v)
{
}

e_unitDistance::
e_unitDistance (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitDistance::
e_unitDistance (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitDistance::
e_unitDistance (const e_unitDistance& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitDistance& e_unitDistance::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitDistance_literals_[v]);

  return *this;
}


// e_unitSpeed
// 

e_unitSpeed::
e_unitSpeed (value v)
: ::xml_schema::string (_xsd_e_unitSpeed_literals_[v])
{
}

e_unitSpeed::
e_unitSpeed (const char* v)
: ::xml_schema::string (v)
{
}

e_unitSpeed::
e_unitSpeed (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitSpeed::
e_unitSpeed (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitSpeed::
e_unitSpeed (const e_unitSpeed& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitSpeed& e_unitSpeed::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitSpeed_literals_[v]);

  return *this;
}


// e_unitMass
// 

e_unitMass::
e_unitMass (value v)
: ::xml_schema::string (_xsd_e_unitMass_literals_[v])
{
}

e_unitMass::
e_unitMass (const char* v)
: ::xml_schema::string (v)
{
}

e_unitMass::
e_unitMass (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitMass::
e_unitMass (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitMass::
e_unitMass (const e_unitMass& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitMass& e_unitMass::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitMass_literals_[v]);

  return *this;
}


// e_unitSlope
// 

e_unitSlope::
e_unitSlope (value v)
: ::xml_schema::string (_xsd_e_unitSlope_literals_[v])
{
}

e_unitSlope::
e_unitSlope (const char* v)
: ::xml_schema::string (v)
{
}

e_unitSlope::
e_unitSlope (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unitSlope::
e_unitSlope (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unitSlope::
e_unitSlope (const e_unitSlope& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unitSlope& e_unitSlope::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unitSlope_literals_[v]);

  return *this;
}


// e_unit
// 

e_unit::
e_unit (value v)
: ::xml_schema::string (_xsd_e_unit_literals_[v])
{
}

e_unit::
e_unit (const char* v)
: ::xml_schema::string (v)
{
}

e_unit::
e_unit (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_unit::
e_unit (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_unit::
e_unit (const e_unit& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_unit& e_unit::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_unit_literals_[v]);

  return *this;
}


// e_roadType
// 

e_roadType::
e_roadType (value v)
: ::xml_schema::string (_xsd_e_roadType_literals_[v])
{
}

e_roadType::
e_roadType (const char* v)
: ::xml_schema::string (v)
{
}

e_roadType::
e_roadType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadType::
e_roadType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadType::
e_roadType (const e_roadType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadType& e_roadType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadType_literals_[v]);

  return *this;
}


// e_roadMarkType
// 

e_roadMarkType::
e_roadMarkType (value v)
: ::xml_schema::string (_xsd_e_roadMarkType_literals_[v])
{
}

e_roadMarkType::
e_roadMarkType (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkType::
e_roadMarkType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkType::
e_roadMarkType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkType::
e_roadMarkType (const e_roadMarkType& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkType& e_roadMarkType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkType_literals_[v]);

  return *this;
}


// e_roadMarkWeight
// 

e_roadMarkWeight::
e_roadMarkWeight (value v)
: ::xml_schema::string (_xsd_e_roadMarkWeight_literals_[v])
{
}

e_roadMarkWeight::
e_roadMarkWeight (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkWeight::
e_roadMarkWeight (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkWeight::
e_roadMarkWeight (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkWeight::
e_roadMarkWeight (const e_roadMarkWeight& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkWeight& e_roadMarkWeight::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkWeight_literals_[v]);

  return *this;
}


// e_roadMarkColor
// 

e_roadMarkColor::
e_roadMarkColor (value v)
: ::xml_schema::string (_xsd_e_roadMarkColor_literals_[v])
{
}

e_roadMarkColor::
e_roadMarkColor (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkColor::
e_roadMarkColor (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkColor::
e_roadMarkColor (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkColor::
e_roadMarkColor (const e_roadMarkColor& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkColor& e_roadMarkColor::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkColor_literals_[v]);

  return *this;
}


// e_laneType
// 

e_laneType::
e_laneType (value v)
: ::xml_schema::string (_xsd_e_laneType_literals_[v])
{
}

e_laneType::
e_laneType (const char* v)
: ::xml_schema::string (v)
{
}

e_laneType::
e_laneType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_laneType::
e_laneType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_laneType::
e_laneType (const e_laneType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_laneType& e_laneType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_laneType_literals_[v]);

  return *this;
}


// e_objectType
// 

e_objectType::
e_objectType (value v)
: ::xml_schema::string (_xsd_e_objectType_literals_[v])
{
}

e_objectType::
e_objectType (const char* v)
: ::xml_schema::string (v)
{
}

e_objectType::
e_objectType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_objectType::
e_objectType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_objectType::
e_objectType (const e_objectType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_objectType& e_objectType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_objectType_literals_[v]);

  return *this;
}


// e_tunnelType
// 

e_tunnelType::
e_tunnelType (value v)
: ::xml_schema::string (_xsd_e_tunnelType_literals_[v])
{
}

e_tunnelType::
e_tunnelType (const char* v)
: ::xml_schema::string (v)
{
}

e_tunnelType::
e_tunnelType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_tunnelType::
e_tunnelType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_tunnelType::
e_tunnelType (const e_tunnelType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_tunnelType& e_tunnelType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_tunnelType_literals_[v]);

  return *this;
}


// e_bridgeType
// 

e_bridgeType::
e_bridgeType (value v)
: ::xml_schema::string (_xsd_e_bridgeType_literals_[v])
{
}

e_bridgeType::
e_bridgeType (const char* v)
: ::xml_schema::string (v)
{
}

e_bridgeType::
e_bridgeType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_bridgeType::
e_bridgeType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_bridgeType::
e_bridgeType (const e_bridgeType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_bridgeType& e_bridgeType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_bridgeType_literals_[v]);

  return *this;
}


// e_accessRestrictionType
// 

e_accessRestrictionType::
e_accessRestrictionType (value v)
: ::xml_schema::string (_xsd_e_accessRestrictionType_literals_[v])
{
}

e_accessRestrictionType::
e_accessRestrictionType (const char* v)
: ::xml_schema::string (v)
{
}

e_accessRestrictionType::
e_accessRestrictionType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_accessRestrictionType::
e_accessRestrictionType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_accessRestrictionType::
e_accessRestrictionType (const e_accessRestrictionType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_accessRestrictionType& e_accessRestrictionType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_accessRestrictionType_literals_[v]);

  return *this;
}


// e_countryCode
//

e_countryCode::
e_countryCode (const char* s)
: ::xml_schema::string (s)
{
}

e_countryCode::
e_countryCode (const ::std::string& s)
: ::xml_schema::string (s)
{
}

e_countryCode::
e_countryCode (const e_countryCode& o,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (o, f, c)
{
}

// e_countryCode_deprecated
// 

e_countryCode_deprecated::
e_countryCode_deprecated (value v)
: ::xml_schema::string (_xsd_e_countryCode_deprecated_literals_[v])
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const char* v)
: ::xml_schema::string (v)
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_countryCode_deprecated::
e_countryCode_deprecated (const e_countryCode_deprecated& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_countryCode_deprecated& e_countryCode_deprecated::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_countryCode_deprecated_literals_[v]);

  return *this;
}


// e_countryCode_iso3166alpha3
// 


// e_sideType
// 

e_sideType::
e_sideType (value v)
: ::xml_schema::string (_xsd_e_sideType_literals_[v])
{
}

e_sideType::
e_sideType (const char* v)
: ::xml_schema::string (v)
{
}

e_sideType::
e_sideType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_sideType::
e_sideType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_sideType::
e_sideType (const e_sideType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_sideType& e_sideType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_sideType_literals_[v]);

  return *this;
}


// e_outlineFillType
// 

e_outlineFillType::
e_outlineFillType (value v)
: ::xml_schema::string (_xsd_e_outlineFillType_literals_[v])
{
}

e_outlineFillType::
e_outlineFillType (const char* v)
: ::xml_schema::string (v)
{
}

e_outlineFillType::
e_outlineFillType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_outlineFillType::
e_outlineFillType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_outlineFillType::
e_outlineFillType (const e_outlineFillType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_outlineFillType& e_outlineFillType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_outlineFillType_literals_[v]);

  return *this;
}


// e_borderType
// 

e_borderType::
e_borderType (value v)
: ::xml_schema::string (_xsd_e_borderType_literals_[v])
{
}

e_borderType::
e_borderType (const char* v)
: ::xml_schema::string (v)
{
}

e_borderType::
e_borderType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_borderType::
e_borderType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_borderType::
e_borderType (const e_borderType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_borderType& e_borderType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_borderType_literals_[v]);

  return *this;
}


// e_contactPoint
// 

e_contactPoint::
e_contactPoint (value v)
: ::xml_schema::string (_xsd_e_contactPoint_literals_[v])
{
}

e_contactPoint::
e_contactPoint (const char* v)
: ::xml_schema::string (v)
{
}

e_contactPoint::
e_contactPoint (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_contactPoint::
e_contactPoint (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_contactPoint::
e_contactPoint (const e_contactPoint& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_contactPoint& e_contactPoint::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_contactPoint_literals_[v]);

  return *this;
}


// e_elementDir
// 

e_elementDir::
e_elementDir (value v)
: ::xml_schema::string (_xsd_e_elementDir_literals_[v])
{
}

e_elementDir::
e_elementDir (const char* v)
: ::xml_schema::string (v)
{
}

e_elementDir::
e_elementDir (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_elementDir::
e_elementDir (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_elementDir::
e_elementDir (const e_elementDir& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_elementDir& e_elementDir::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_elementDir_literals_[v]);

  return *this;
}


// e_direction
// 

e_direction::
e_direction (value v)
: ::xml_schema::string (_xsd_e_direction_literals_[v])
{
}

e_direction::
e_direction (const char* v)
: ::xml_schema::string (v)
{
}

e_direction::
e_direction (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_direction::
e_direction (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_direction::
e_direction (const e_direction& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_direction& e_direction::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_direction_literals_[v]);

  return *this;
}


// e_roadMarkRule
// 

e_roadMarkRule::
e_roadMarkRule (value v)
: ::xml_schema::string (_xsd_e_roadMarkRule_literals_[v])
{
}

e_roadMarkRule::
e_roadMarkRule (const char* v)
: ::xml_schema::string (v)
{
}

e_roadMarkRule::
e_roadMarkRule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkRule::
e_roadMarkRule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_roadMarkRule::
e_roadMarkRule (const e_roadMarkRule& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_roadMarkRule& e_roadMarkRule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_roadMarkRule_literals_[v]);

  return *this;
}


// e_orientation
// 

e_orientation::
e_orientation (value v)
: ::xml_schema::string (_xsd_e_orientation_literals_[v])
{
}

e_orientation::
e_orientation (const char* v)
: ::xml_schema::string (v)
{
}

e_orientation::
e_orientation (const ::std::string& v)
: ::xml_schema::string (v)
{
}

e_orientation::
e_orientation (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

e_orientation::
e_orientation (const e_orientation& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

e_orientation& e_orientation::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_e_orientation_literals_[v]);

  return *this;
}


// OpenDRIVE
// 

const OpenDRIVE::header_type& OpenDRIVE::
header () const
{
  return this->header_.get ();
}

OpenDRIVE::header_type& OpenDRIVE::
header ()
{
  return this->header_.get ();
}

void OpenDRIVE::
header (const header_type& x)
{
  this->header_.set (x);
}

void OpenDRIVE::
header (::std::unique_ptr< header_type > x)
{
  this->header_.set (std::move (x));
}

const OpenDRIVE::road_sequence& OpenDRIVE::
road () const
{
  return this->road_;
}

OpenDRIVE::road_sequence& OpenDRIVE::
road ()
{
  return this->road_;
}

void OpenDRIVE::
road (const road_sequence& s)
{
  this->road_ = s;
}

const OpenDRIVE::controller_sequence& OpenDRIVE::
controller () const
{
  return this->controller_;
}

OpenDRIVE::controller_sequence& OpenDRIVE::
controller ()
{
  return this->controller_;
}

void OpenDRIVE::
controller (const controller_sequence& s)
{
  this->controller_ = s;
}

const OpenDRIVE::junction_sequence& OpenDRIVE::
junction () const
{
  return this->junction_;
}

OpenDRIVE::junction_sequence& OpenDRIVE::
junction ()
{
  return this->junction_;
}

void OpenDRIVE::
junction (const junction_sequence& s)
{
  this->junction_ = s;
}

const OpenDRIVE::junctionGroup_sequence& OpenDRIVE::
junctionGroup () const
{
  return this->junctionGroup_;
}

OpenDRIVE::junctionGroup_sequence& OpenDRIVE::
junctionGroup ()
{
  return this->junctionGroup_;
}

void OpenDRIVE::
junctionGroup (const junctionGroup_sequence& s)
{
  this->junctionGroup_ = s;
}

const OpenDRIVE::station_sequence& OpenDRIVE::
station () const
{
  return this->station_;
}

OpenDRIVE::station_sequence& OpenDRIVE::
station ()
{
  return this->station_;
}

void OpenDRIVE::
station (const station_sequence& s)
{
  this->station_ = s;
}

const OpenDRIVE::userData_sequence& OpenDRIVE::
userData () const
{
  return this->userData_;
}

OpenDRIVE::userData_sequence& OpenDRIVE::
userData ()
{
  return this->userData_;
}

void OpenDRIVE::
userData (const userData_sequence& s)
{
  this->userData_ = s;
}

const OpenDRIVE::include_sequence& OpenDRIVE::
include () const
{
  return this->include_;
}

OpenDRIVE::include_sequence& OpenDRIVE::
include ()
{
  return this->include_;
}

void OpenDRIVE::
include (const include_sequence& s)
{
  this->include_ = s;
}

const OpenDRIVE::dataQuality_optional& OpenDRIVE::
dataQuality () const
{
  return this->dataQuality_;
}

OpenDRIVE::dataQuality_optional& OpenDRIVE::
dataQuality ()
{
  return this->dataQuality_;
}

void OpenDRIVE::
dataQuality (const dataQuality_type& x)
{
  this->dataQuality_.set (x);
}

void OpenDRIVE::
dataQuality (const dataQuality_optional& x)
{
  this->dataQuality_ = x;
}

void OpenDRIVE::
dataQuality (::std::unique_ptr< dataQuality_type > x)
{
  this->dataQuality_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// t_grEqZero
//

t_grEqZero::
t_grEqZero (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

t_grEqZero::
t_grEqZero (const t_grEqZero& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

t_grEqZero::
t_grEqZero (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

t_grEqZero::
t_grEqZero (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

t_grEqZero::
t_grEqZero (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

t_grEqZero* t_grEqZero::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_grEqZero (*this, f, c);
}

t_grEqZero::
~t_grEqZero ()
{
}

// t_grZero
//

t_grZero::
t_grZero (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

t_grZero::
t_grZero (const t_grZero& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

t_grZero::
t_grZero (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

t_grZero::
t_grZero (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

t_grZero::
t_grZero (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

t_grZero* t_grZero::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_grZero (*this, f, c);
}

t_grZero::
~t_grZero ()
{
}

// t_zeroOne
//

t_zeroOne::
t_zeroOne (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

t_zeroOne::
t_zeroOne (const t_zeroOne& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

t_zeroOne::
t_zeroOne (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

t_zeroOne::
t_zeroOne (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

t_zeroOne::
t_zeroOne (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

t_zeroOne* t_zeroOne::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_zeroOne (*this, f, c);
}

t_zeroOne::
~t_zeroOne ()
{
}

// t_bool
//

t_bool::
t_bool (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_t_bool_convert ();
}

t_bool::
t_bool (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_t_bool_convert ();
}

t_bool::
t_bool (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_t_bool_convert ();
}

t_bool* t_bool::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_bool (*this, f, c);
}

t_bool::value t_bool::
_xsd_t_bool_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_t_bool_literals_);
  const value* i (::std::lower_bound (
                    _xsd_t_bool_indexes_,
                    _xsd_t_bool_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_t_bool_indexes_ + 2 || _xsd_t_bool_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const t_bool::
_xsd_t_bool_literals_[2] =
{
  "true",
  "false"
};

const t_bool::value t_bool::
_xsd_t_bool_indexes_[2] =
{
  ::t_bool::false_,
  ::t_bool::true_
};

// t_yesNo
//

t_yesNo::
t_yesNo (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_t_yesNo_convert ();
}

t_yesNo::
t_yesNo (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_t_yesNo_convert ();
}

t_yesNo::
t_yesNo (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_t_yesNo_convert ();
}

t_yesNo* t_yesNo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_yesNo (*this, f, c);
}

t_yesNo::value t_yesNo::
_xsd_t_yesNo_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_t_yesNo_literals_);
  const value* i (::std::lower_bound (
                    _xsd_t_yesNo_indexes_,
                    _xsd_t_yesNo_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_t_yesNo_indexes_ + 2 || _xsd_t_yesNo_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const t_yesNo::
_xsd_t_yesNo_literals_[2] =
{
  "yes",
  "no"
};

const t_yesNo::value t_yesNo::
_xsd_t_yesNo_indexes_[2] =
{
  ::t_yesNo::no,
  ::t_yesNo::yes
};

// t_header_Version
//

t_header_Version::
t_header_Version (const ::xml_schema::float_& _xsd_float__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (_xsd_float__base)
{
}

t_header_Version::
t_header_Version (const t_header_Version& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c)
{
}

t_header_Version::
t_header_Version (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f, c)
{
}

t_header_Version::
t_header_Version (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (a, f, c)
{
}

t_header_Version::
t_header_Version (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

t_header_Version* t_header_Version::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_header_Version (*this, f, c);
}

t_header_Version::
~t_header_Version ()
{
}

// t_maxSpeed
//

t_maxSpeed::
t_maxSpeed (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

t_maxSpeed::
t_maxSpeed (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

t_maxSpeed::
t_maxSpeed (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

t_maxSpeed* t_maxSpeed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_maxSpeed (*this, f, c);
}

// e_maxSpeedString
//

e_maxSpeedString::
e_maxSpeedString (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_maxSpeedString_convert ();
}

e_maxSpeedString::
e_maxSpeedString (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_maxSpeedString_convert ();
}

e_maxSpeedString::
e_maxSpeedString (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_maxSpeedString_convert ();
}

e_maxSpeedString* e_maxSpeedString::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_maxSpeedString (*this, f, c);
}

e_maxSpeedString::value e_maxSpeedString::
_xsd_e_maxSpeedString_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_maxSpeedString_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_maxSpeedString_indexes_,
                    _xsd_e_maxSpeedString_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_maxSpeedString_indexes_ + 2 || _xsd_e_maxSpeedString_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_maxSpeedString::
_xsd_e_maxSpeedString_literals_[2] =
{
  "no limit",
  "undefined"
};

const e_maxSpeedString::value e_maxSpeedString::
_xsd_e_maxSpeedString_indexes_[2] =
{
  ::e_maxSpeedString::no_limit,
  ::e_maxSpeedString::undefined
};

// t_junction_id
//

t_junction_id::
t_junction_id ()
: ::xml_schema::string ()
{
}

t_junction_id::
t_junction_id (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

t_junction_id::
t_junction_id (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

t_junction_id::
t_junction_id (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

t_junction_id::
t_junction_id (const t_junction_id& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

t_junction_id::
t_junction_id (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

t_junction_id::
t_junction_id (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

t_junction_id::
t_junction_id (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

t_junction_id* t_junction_id::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_id (*this, f, c);
}

t_junction_id::
~t_junction_id ()
{
}

// t_header
//

t_header::
t_header ()
: ::xml_schema::type (),
  geoReference_ (this),
  offset_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  revMajor_ (revMajor_default_value (), this),
  revMinor_ (revMinor_default_value (), this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  vendor_ (this)
{
}

t_header::
t_header (const t_header& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geoReference_ (x.geoReference_, f, this),
  offset_ (x.offset_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  revMajor_ (x.revMajor_, f, this),
  revMinor_ (x.revMinor_, f, this),
  name_ (x.name_, f, this),
  version_ (x.version_, f, this),
  date_ (x.date_, f, this),
  north_ (x.north_, f, this),
  south_ (x.south_, f, this),
  east_ (x.east_, f, this),
  west_ (x.west_, f, this),
  vendor_ (x.vendor_, f, this)
{
}

t_header::
t_header (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geoReference_ (this),
  offset_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  revMajor_ (this),
  revMinor_ (this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  vendor_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geoReference
    //
    if (n.name () == "geoReference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geoReference_type > r (
        geoReference_traits::create (i, f, this));

      if (!this->geoReference_)
      {
        this->geoReference_.set (::std::move (r));
        continue;
      }
    }

    // offset
    //
    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< offset_type > r (
        offset_traits::create (i, f, this));

      if (!this->offset_)
      {
        this->offset_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "revMajor" && n.namespace_ ().empty ())
    {
      this->revMajor_.set (revMajor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "revMinor" && n.namespace_ ().empty ())
    {
      this->revMinor_.set (revMinor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "date" && n.namespace_ ().empty ())
    {
      this->date_.set (date_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "north" && n.namespace_ ().empty ())
    {
      this->north_.set (north_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "south" && n.namespace_ ().empty ())
    {
      this->south_.set (south_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "east" && n.namespace_ ().empty ())
    {
      this->east_.set (east_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "west" && n.namespace_ ().empty ())
    {
      this->west_.set (west_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vendor" && n.namespace_ ().empty ())
    {
      this->vendor_.set (vendor_traits::create (i, f, this));
      continue;
    }
  }

  if (!revMajor_.present ())
  {
    this->revMajor_.set (revMajor_default_value ());
  }

  if (!revMinor_.present ())
  {
    this->revMinor_.set (revMinor_default_value ());
  }
}

t_header* t_header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_header (*this, f, c);
}

t_header& t_header::
operator= (const t_header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geoReference_ = x.geoReference_;
    this->offset_ = x.offset_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->revMajor_ = x.revMajor_;
    this->revMinor_ = x.revMinor_;
    this->name_ = x.name_;
    this->version_ = x.version_;
    this->date_ = x.date_;
    this->north_ = x.north_;
    this->south_ = x.south_;
    this->east_ = x.east_;
    this->west_ = x.west_;
    this->vendor_ = x.vendor_;
  }

  return *this;
}

t_header::
~t_header ()
{
}

// t_header_GeoReference
//

t_header_GeoReference::
t_header_GeoReference ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_header_GeoReference::
t_header_GeoReference (const t_header_GeoReference& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_header_GeoReference::
t_header_GeoReference (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_header_GeoReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_header_GeoReference* t_header_GeoReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_header_GeoReference (*this, f, c);
}

t_header_GeoReference& t_header_GeoReference::
operator= (const t_header_GeoReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_header_GeoReference::
~t_header_GeoReference ()
{
}

// t_header_Offset
//

t_header_Offset::
t_header_Offset (const x_type& x,
                 const y_type& y,
                 const z_type& z,
                 const hdg_type& hdg)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  hdg_ (hdg, this)
{
}

t_header_Offset::
t_header_Offset (const t_header_Offset& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  hdg_ (x.hdg_, f, this)
{
}

t_header_Offset::
t_header_Offset (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  x_ (this),
  y_ (this),
  z_ (this),
  hdg_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_header_Offset::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!hdg_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hdg",
      "");
  }
}

t_header_Offset* t_header_Offset::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_header_Offset (*this, f, c);
}

t_header_Offset& t_header_Offset::
operator= (const t_header_Offset& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->hdg_ = x.hdg_;
  }

  return *this;
}

t_header_Offset::
~t_header_Offset ()
{
}

// t_road
//

t_road::
t_road (const planView_type& planView,
        const lanes_type& lanes,
        const length_type& length,
        const id_type& id,
        const junction_type& junction)
: ::xml_schema::type (),
  link_ (this),
  type_ (this),
  planView_ (planView, this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (lanes, this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  length_ (length, this),
  id_ (id, this),
  junction_ (junction, this),
  rule_ (this)
{
}

t_road::
t_road (::std::unique_ptr< planView_type > planView,
        ::std::unique_ptr< lanes_type > lanes,
        const length_type& length,
        const id_type& id,
        const junction_type& junction)
: ::xml_schema::type (),
  link_ (this),
  type_ (this),
  planView_ (std::move (planView), this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (std::move (lanes), this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  length_ (length, this),
  id_ (id, this),
  junction_ (junction, this),
  rule_ (this)
{
}

t_road::
t_road (const t_road& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  link_ (x.link_, f, this),
  type_ (x.type_, f, this),
  planView_ (x.planView_, f, this),
  elevationProfile_ (x.elevationProfile_, f, this),
  lateralProfile_ (x.lateralProfile_, f, this),
  lanes_ (x.lanes_, f, this),
  objects_ (x.objects_, f, this),
  signals_ (x.signals_, f, this),
  surface_ (x.surface_, f, this),
  railroad_ (x.railroad_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  length_ (x.length_, f, this),
  id_ (x.id_, f, this),
  junction_ (x.junction_, f, this),
  rule_ (x.rule_, f, this)
{
}

t_road::
t_road (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  link_ (this),
  type_ (this),
  planView_ (this),
  elevationProfile_ (this),
  lateralProfile_ (this),
  lanes_ (this),
  objects_ (this),
  signals_ (this),
  surface_ (this),
  railroad_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this),
  rule_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->link_)
      {
        this->link_.set (::std::move (r));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.push_back (::std::move (r));
      continue;
    }

    // planView
    //
    if (n.name () == "planView" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< planView_type > r (
        planView_traits::create (i, f, this));

      if (!planView_.present ())
      {
        this->planView_.set (::std::move (r));
        continue;
      }
    }

    // elevationProfile
    //
    if (n.name () == "elevationProfile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< elevationProfile_type > r (
        elevationProfile_traits::create (i, f, this));

      if (!this->elevationProfile_)
      {
        this->elevationProfile_.set (::std::move (r));
        continue;
      }
    }

    // lateralProfile
    //
    if (n.name () == "lateralProfile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lateralProfile_type > r (
        lateralProfile_traits::create (i, f, this));

      if (!this->lateralProfile_)
      {
        this->lateralProfile_.set (::std::move (r));
        continue;
      }
    }

    // lanes
    //
    if (n.name () == "lanes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lanes_type > r (
        lanes_traits::create (i, f, this));

      if (!lanes_.present ())
      {
        this->lanes_.set (::std::move (r));
        continue;
      }
    }

    // objects
    //
    if (n.name () == "objects" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< objects_type > r (
        objects_traits::create (i, f, this));

      if (!this->objects_)
      {
        this->objects_.set (::std::move (r));
        continue;
      }
    }

    // signals
    //
    if (n.name () == "signals" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< signals_type > r (
        signals_traits::create (i, f, this));

      if (!this->signals_)
      {
        this->signals_.set (::std::move (r));
        continue;
      }
    }

    // surface
    //
    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< surface_type > r (
        surface_traits::create (i, f, this));

      if (!this->surface_)
      {
        this->surface_.set (::std::move (r));
        continue;
      }
    }

    // railroad
    //
    if (n.name () == "railroad" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< railroad_type > r (
        railroad_traits::create (i, f, this));

      if (!this->railroad_)
      {
        this->railroad_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!planView_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "planView",
      "");
  }

  if (!lanes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lanes",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      this->junction_.set (junction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!junction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "junction",
      "");
  }
}

t_road* t_road::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road (*this, f, c);
}

t_road& t_road::
operator= (const t_road& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->link_ = x.link_;
    this->type_ = x.type_;
    this->planView_ = x.planView_;
    this->elevationProfile_ = x.elevationProfile_;
    this->lateralProfile_ = x.lateralProfile_;
    this->lanes_ = x.lanes_;
    this->objects_ = x.objects_;
    this->signals_ = x.signals_;
    this->surface_ = x.surface_;
    this->railroad_ = x.railroad_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->length_ = x.length_;
    this->id_ = x.id_;
    this->junction_ = x.junction_;
    this->rule_ = x.rule_;
  }

  return *this;
}

t_road::
~t_road ()
{
}

// e_trafficRule
//

e_trafficRule::
e_trafficRule (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_trafficRule_convert ();
}

e_trafficRule::
e_trafficRule (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_trafficRule_convert ();
}

e_trafficRule::
e_trafficRule (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_trafficRule_convert ();
}

e_trafficRule* e_trafficRule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_trafficRule (*this, f, c);
}

e_trafficRule::value e_trafficRule::
_xsd_e_trafficRule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_trafficRule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_trafficRule_indexes_,
                    _xsd_e_trafficRule_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_trafficRule_indexes_ + 2 || _xsd_e_trafficRule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_trafficRule::
_xsd_e_trafficRule_literals_[2] =
{
  "RHT",
  "LHT"
};

const e_trafficRule::value e_trafficRule::
_xsd_e_trafficRule_indexes_[2] =
{
  ::e_trafficRule::LHT,
  ::e_trafficRule::RHT
};

// t_road_link
//

t_road_link::
t_road_link ()
: ::xml_schema::type (),
  predecessor_ (this),
  successor_ (this),
  neighbor_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_link::
t_road_link (const t_road_link& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  neighbor_ (x.neighbor_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_link::
t_road_link (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  neighbor_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_link::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      if (!this->predecessor_)
      {
        this->predecessor_.set (::std::move (r));
        continue;
      }
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      if (!this->successor_)
      {
        this->successor_.set (::std::move (r));
        continue;
      }
    }

    // neighbor
    //
    if (n.name () == "neighbor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< neighbor_type > r (
        neighbor_traits::create (i, f, this));

      this->neighbor_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_link* t_road_link::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_link (*this, f, c);
}

t_road_link& t_road_link::
operator= (const t_road_link& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->neighbor_ = x.neighbor_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_link::
~t_road_link ()
{
}

// t_road_link_predecessorSuccessor
//

t_road_link_predecessorSuccessor::
t_road_link_predecessorSuccessor (const elementType_type& elementType,
                                  const elementId_type& elementId)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  elementType_ (elementType, this),
  elementId_ (elementId, this),
  contactPoint_ (this),
  elementS_ (this),
  elementDir_ (this)
{
}

t_road_link_predecessorSuccessor::
t_road_link_predecessorSuccessor (const t_road_link_predecessorSuccessor& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  elementType_ (x.elementType_, f, this),
  elementId_ (x.elementId_, f, this),
  contactPoint_ (x.contactPoint_, f, this),
  elementS_ (x.elementS_, f, this),
  elementDir_ (x.elementDir_, f, this)
{
}

t_road_link_predecessorSuccessor::
t_road_link_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  elementType_ (this),
  elementId_ (this),
  contactPoint_ (this),
  elementS_ (this),
  elementDir_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_link_predecessorSuccessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementS" && n.namespace_ ().empty ())
    {
      this->elementS_.set (elementS_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementDir" && n.namespace_ ().empty ())
    {
      this->elementDir_.set (elementDir_traits::create (i, f, this));
      continue;
    }
  }

  if (!elementType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementType",
      "");
  }

  if (!elementId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementId",
      "");
  }
}

t_road_link_predecessorSuccessor* t_road_link_predecessorSuccessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_link_predecessorSuccessor (*this, f, c);
}

t_road_link_predecessorSuccessor& t_road_link_predecessorSuccessor::
operator= (const t_road_link_predecessorSuccessor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->elementType_ = x.elementType_;
    this->elementId_ = x.elementId_;
    this->contactPoint_ = x.contactPoint_;
    this->elementS_ = x.elementS_;
    this->elementDir_ = x.elementDir_;
  }

  return *this;
}

t_road_link_predecessorSuccessor::
~t_road_link_predecessorSuccessor ()
{
}

// e_road_link_elementType
//

e_road_link_elementType::
e_road_link_elementType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_link_elementType_convert ();
}

e_road_link_elementType::
e_road_link_elementType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_link_elementType_convert ();
}

e_road_link_elementType::
e_road_link_elementType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_link_elementType_convert ();
}

e_road_link_elementType* e_road_link_elementType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_link_elementType (*this, f, c);
}

e_road_link_elementType::value e_road_link_elementType::
_xsd_e_road_link_elementType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_link_elementType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_link_elementType_indexes_,
                    _xsd_e_road_link_elementType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_road_link_elementType_indexes_ + 2 || _xsd_e_road_link_elementType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_link_elementType::
_xsd_e_road_link_elementType_literals_[2] =
{
  "road",
  "junction"
};

const e_road_link_elementType::value e_road_link_elementType::
_xsd_e_road_link_elementType_indexes_[2] =
{
  ::e_road_link_elementType::junction,
  ::e_road_link_elementType::road
};

// t_road_link_neighbor
//

t_road_link_neighbor::
t_road_link_neighbor (const side_type& side,
                      const elementId_type& elementId,
                      const direction_type& direction)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  side_ (side, this),
  elementId_ (elementId, this),
  direction_ (direction, this)
{
}

t_road_link_neighbor::
t_road_link_neighbor (const t_road_link_neighbor& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  side_ (x.side_, f, this),
  elementId_ (x.elementId_, f, this),
  direction_ (x.direction_, f, this)
{
}

t_road_link_neighbor::
t_road_link_neighbor (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  side_ (this),
  elementId_ (this),
  direction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_link_neighbor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "direction" && n.namespace_ ().empty ())
    {
      this->direction_.set (direction_traits::create (i, f, this));
      continue;
    }
  }

  if (!side_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "side",
      "");
  }

  if (!elementId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementId",
      "");
  }

  if (!direction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "direction",
      "");
  }
}

t_road_link_neighbor* t_road_link_neighbor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_link_neighbor (*this, f, c);
}

t_road_link_neighbor& t_road_link_neighbor::
operator= (const t_road_link_neighbor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->side_ = x.side_;
    this->elementId_ = x.elementId_;
    this->direction_ = x.direction_;
  }

  return *this;
}

t_road_link_neighbor::
~t_road_link_neighbor ()
{
}

// e_road_link_neighbor_side
//

e_road_link_neighbor_side::
e_road_link_neighbor_side (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_link_neighbor_side_convert ();
}

e_road_link_neighbor_side::
e_road_link_neighbor_side (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_link_neighbor_side_convert ();
}

e_road_link_neighbor_side::
e_road_link_neighbor_side (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_link_neighbor_side_convert ();
}

e_road_link_neighbor_side* e_road_link_neighbor_side::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_link_neighbor_side (*this, f, c);
}

e_road_link_neighbor_side::value e_road_link_neighbor_side::
_xsd_e_road_link_neighbor_side_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_link_neighbor_side_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_link_neighbor_side_indexes_,
                    _xsd_e_road_link_neighbor_side_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_road_link_neighbor_side_indexes_ + 2 || _xsd_e_road_link_neighbor_side_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_link_neighbor_side::
_xsd_e_road_link_neighbor_side_literals_[2] =
{
  "left",
  "right"
};

const e_road_link_neighbor_side::value e_road_link_neighbor_side::
_xsd_e_road_link_neighbor_side_indexes_[2] =
{
  ::e_road_link_neighbor_side::left,
  ::e_road_link_neighbor_side::right
};

// t_road_type
//

t_road_type::
t_road_type (const s_type& s,
             const type_type& type)
: ::xml_schema::type (),
  speed_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  type_ (type, this),
  country_ (this)
{
}

t_road_type::
t_road_type (const t_road_type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  speed_ (x.speed_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  type_ (x.type_, f, this),
  country_ (x.country_, f, this)
{
}

t_road_type::
t_road_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  speed_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  type_ (this),
  country_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // speed
    //
    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      if (!this->speed_)
      {
        this->speed_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "country" && n.namespace_ ().empty ())
    {
      this->country_.set (country_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_type* t_road_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_type (*this, f, c);
}

t_road_type& t_road_type::
operator= (const t_road_type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->speed_ = x.speed_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->type_ = x.type_;
    this->country_ = x.country_;
  }

  return *this;
}

t_road_type::
~t_road_type ()
{
}

// t_road_type_speed
//

t_road_type_speed::
t_road_type_speed (const max_type& fmax)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  fmax_ (fmax, this),
  unit_ (this)
{
}

t_road_type_speed::
t_road_type_speed (const t_road_type_speed& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  fmax_ (x.fmax_, f, this),
  unit_ (x.unit_, f, this)
{
}

t_road_type_speed::
t_road_type_speed (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  fmax_ (this),
  unit_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_type_speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->fmax_.set (max_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }
  }

  if (!fmax_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max",
      "");
  }
}

t_road_type_speed* t_road_type_speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_type_speed (*this, f, c);
}

t_road_type_speed& t_road_type_speed::
operator= (const t_road_type_speed& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->fmax_ = x.fmax_;
    this->unit_ = x.unit_;
  }

  return *this;
}

t_road_type_speed::
~t_road_type_speed ()
{
}

// t_road_planView
//

t_road_planView::
t_road_planView ()
: ::xml_schema::type (),
  geometry_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_planView::
t_road_planView (const t_road_planView& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_planView::
t_road_planView (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_planView::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      this->geometry_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_planView* t_road_planView::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView (*this, f, c);
}

t_road_planView& t_road_planView::
operator= (const t_road_planView& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_planView::
~t_road_planView ()
{
}

// t_road_planView_geometry
//

t_road_planView_geometry::
t_road_planView_geometry (const s_type& s,
                          const x_type& x,
                          const y_type& y,
                          const hdg_type& hdg,
                          const length_type& length)
: ::xml_schema::type (),
  line_ (this),
  spiral_ (this),
  arc_ (this),
  poly3_ (this),
  paramPoly3_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  x_ (x, this),
  y_ (y, this),
  hdg_ (hdg, this),
  length_ (length, this)
{
}

t_road_planView_geometry::
t_road_planView_geometry (const t_road_planView_geometry& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  line_ (x.line_, f, this),
  spiral_ (x.spiral_, f, this),
  arc_ (x.arc_, f, this),
  poly3_ (x.poly3_, f, this),
  paramPoly3_ (x.paramPoly3_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  hdg_ (x.hdg_, f, this),
  length_ (x.length_, f, this)
{
}

t_road_planView_geometry::
t_road_planView_geometry (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  spiral_ (this),
  arc_ (this),
  poly3_ (this),
  paramPoly3_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  x_ (this),
  y_ (this),
  hdg_ (this),
  length_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< line_type > r (
        line_traits::create (i, f, this));

      if (!this->line_)
      {
        this->line_.set (::std::move (r));
        continue;
      }
    }

    // spiral
    //
    if (n.name () == "spiral" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< spiral_type > r (
        spiral_traits::create (i, f, this));

      if (!this->spiral_)
      {
        this->spiral_.set (::std::move (r));
        continue;
      }
    }

    // arc
    //
    if (n.name () == "arc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< arc_type > r (
        arc_traits::create (i, f, this));

      if (!this->arc_)
      {
        this->arc_.set (::std::move (r));
        continue;
      }
    }

    // poly3
    //
    if (n.name () == "poly3" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< poly3_type > r (
        poly3_traits::create (i, f, this));

      if (!this->poly3_)
      {
        this->poly3_.set (::std::move (r));
        continue;
      }
    }

    // paramPoly3
    //
    if (n.name () == "paramPoly3" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< paramPoly3_type > r (
        paramPoly3_traits::create (i, f, this));

      if (!this->paramPoly3_)
      {
        this->paramPoly3_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!hdg_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hdg",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }
}

t_road_planView_geometry* t_road_planView_geometry::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry (*this, f, c);
}

t_road_planView_geometry& t_road_planView_geometry::
operator= (const t_road_planView_geometry& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->line_ = x.line_;
    this->spiral_ = x.spiral_;
    this->arc_ = x.arc_;
    this->poly3_ = x.poly3_;
    this->paramPoly3_ = x.paramPoly3_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->hdg_ = x.hdg_;
    this->length_ = x.length_;
  }

  return *this;
}

t_road_planView_geometry::
~t_road_planView_geometry ()
{
}

// t_road_planView_geometry_line
//

t_road_planView_geometry_line::
t_road_planView_geometry_line ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_planView_geometry_line::
t_road_planView_geometry_line (const t_road_planView_geometry_line& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_planView_geometry_line::
t_road_planView_geometry_line (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_line::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_planView_geometry_line* t_road_planView_geometry_line::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_line (*this, f, c);
}

t_road_planView_geometry_line& t_road_planView_geometry_line::
operator= (const t_road_planView_geometry_line& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_planView_geometry_line::
~t_road_planView_geometry_line ()
{
}

// t_road_planView_geometry_spiral
//

t_road_planView_geometry_spiral::
t_road_planView_geometry_spiral (const curvStart_type& curvStart,
                                 const curvEnd_type& curvEnd)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  curvStart_ (curvStart, this),
  curvEnd_ (curvEnd, this)
{
}

t_road_planView_geometry_spiral::
t_road_planView_geometry_spiral (const t_road_planView_geometry_spiral& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  curvStart_ (x.curvStart_, f, this),
  curvEnd_ (x.curvEnd_, f, this)
{
}

t_road_planView_geometry_spiral::
t_road_planView_geometry_spiral (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  curvStart_ (this),
  curvEnd_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_spiral::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "curvStart" && n.namespace_ ().empty ())
    {
      this->curvStart_.set (curvStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "curvEnd" && n.namespace_ ().empty ())
    {
      this->curvEnd_.set (curvEnd_traits::create (i, f, this));
      continue;
    }
  }

  if (!curvStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "curvStart",
      "");
  }

  if (!curvEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "curvEnd",
      "");
  }
}

t_road_planView_geometry_spiral* t_road_planView_geometry_spiral::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_spiral (*this, f, c);
}

t_road_planView_geometry_spiral& t_road_planView_geometry_spiral::
operator= (const t_road_planView_geometry_spiral& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->curvStart_ = x.curvStart_;
    this->curvEnd_ = x.curvEnd_;
  }

  return *this;
}

t_road_planView_geometry_spiral::
~t_road_planView_geometry_spiral ()
{
}

// t_road_planView_geometry_arc
//

t_road_planView_geometry_arc::
t_road_planView_geometry_arc (const curvature_type& curvature)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  curvature_ (curvature, this)
{
}

t_road_planView_geometry_arc::
t_road_planView_geometry_arc (const t_road_planView_geometry_arc& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  curvature_ (x.curvature_, f, this)
{
}

t_road_planView_geometry_arc::
t_road_planView_geometry_arc (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  curvature_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_arc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "curvature" && n.namespace_ ().empty ())
    {
      this->curvature_.set (curvature_traits::create (i, f, this));
      continue;
    }
  }

  if (!curvature_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "curvature",
      "");
  }
}

t_road_planView_geometry_arc* t_road_planView_geometry_arc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_arc (*this, f, c);
}

t_road_planView_geometry_arc& t_road_planView_geometry_arc::
operator= (const t_road_planView_geometry_arc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->curvature_ = x.curvature_;
  }

  return *this;
}

t_road_planView_geometry_arc::
~t_road_planView_geometry_arc ()
{
}

// t_road_planView_geometry_poly3
//

t_road_planView_geometry_poly3::
t_road_planView_geometry_poly3 (const a_type& a,
                                const b_type& b,
                                const c_type& c,
                                const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_planView_geometry_poly3::
t_road_planView_geometry_poly3 (const t_road_planView_geometry_poly3& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_planView_geometry_poly3::
t_road_planView_geometry_poly3 (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_poly3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_planView_geometry_poly3* t_road_planView_geometry_poly3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_poly3 (*this, f, c);
}

t_road_planView_geometry_poly3& t_road_planView_geometry_poly3::
operator= (const t_road_planView_geometry_poly3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_planView_geometry_poly3::
~t_road_planView_geometry_poly3 ()
{
}

// t_road_planView_geometry_paramPoly3
//

t_road_planView_geometry_paramPoly3::
t_road_planView_geometry_paramPoly3 (const aU_type& aU,
                                     const bU_type& bU,
                                     const cU_type& cU,
                                     const dU_type& dU,
                                     const aV_type& aV,
                                     const bV_type& bV,
                                     const cV_type& cV,
                                     const dV_type& dV,
                                     const pRange_type& pRange)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  aU_ (aU, this),
  bU_ (bU, this),
  cU_ (cU, this),
  dU_ (dU, this),
  aV_ (aV, this),
  bV_ (bV, this),
  cV_ (cV, this),
  dV_ (dV, this),
  pRange_ (pRange, this)
{
}

t_road_planView_geometry_paramPoly3::
t_road_planView_geometry_paramPoly3 (const t_road_planView_geometry_paramPoly3& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  aU_ (x.aU_, f, this),
  bU_ (x.bU_, f, this),
  cU_ (x.cU_, f, this),
  dU_ (x.dU_, f, this),
  aV_ (x.aV_, f, this),
  bV_ (x.bV_, f, this),
  cV_ (x.cV_, f, this),
  dV_ (x.dV_, f, this),
  pRange_ (x.pRange_, f, this)
{
}

t_road_planView_geometry_paramPoly3::
t_road_planView_geometry_paramPoly3 (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  aU_ (this),
  bU_ (this),
  cU_ (this),
  dU_ (this),
  aV_ (this),
  bV_ (this),
  cV_ (this),
  dV_ (this),
  pRange_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_planView_geometry_paramPoly3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "aU" && n.namespace_ ().empty ())
    {
      this->aU_.set (aU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bU" && n.namespace_ ().empty ())
    {
      this->bU_.set (bU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cU" && n.namespace_ ().empty ())
    {
      this->cU_.set (cU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dU" && n.namespace_ ().empty ())
    {
      this->dU_.set (dU_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "aV" && n.namespace_ ().empty ())
    {
      this->aV_.set (aV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "bV" && n.namespace_ ().empty ())
    {
      this->bV_.set (bV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cV" && n.namespace_ ().empty ())
    {
      this->cV_.set (cV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dV" && n.namespace_ ().empty ())
    {
      this->dV_.set (dV_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pRange" && n.namespace_ ().empty ())
    {
      this->pRange_.set (pRange_traits::create (i, f, this));
      continue;
    }
  }

  if (!aU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "aU",
      "");
  }

  if (!bU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "bU",
      "");
  }

  if (!cU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cU",
      "");
  }

  if (!dU_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dU",
      "");
  }

  if (!aV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "aV",
      "");
  }

  if (!bV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "bV",
      "");
  }

  if (!cV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cV",
      "");
  }

  if (!dV_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dV",
      "");
  }

  if (!pRange_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "pRange",
      "");
  }
}

t_road_planView_geometry_paramPoly3* t_road_planView_geometry_paramPoly3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_planView_geometry_paramPoly3 (*this, f, c);
}

t_road_planView_geometry_paramPoly3& t_road_planView_geometry_paramPoly3::
operator= (const t_road_planView_geometry_paramPoly3& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->aU_ = x.aU_;
    this->bU_ = x.bU_;
    this->cU_ = x.cU_;
    this->dU_ = x.dU_;
    this->aV_ = x.aV_;
    this->bV_ = x.bV_;
    this->cV_ = x.cV_;
    this->dV_ = x.dV_;
    this->pRange_ = x.pRange_;
  }

  return *this;
}

t_road_planView_geometry_paramPoly3::
~t_road_planView_geometry_paramPoly3 ()
{
}

// e_paramPoly3_pRange
//

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_paramPoly3_pRange_convert ();
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_paramPoly3_pRange_convert ();
}

e_paramPoly3_pRange::
e_paramPoly3_pRange (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_paramPoly3_pRange_convert ();
}

e_paramPoly3_pRange* e_paramPoly3_pRange::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_paramPoly3_pRange (*this, f, c);
}

e_paramPoly3_pRange::value e_paramPoly3_pRange::
_xsd_e_paramPoly3_pRange_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_paramPoly3_pRange_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_paramPoly3_pRange_indexes_,
                    _xsd_e_paramPoly3_pRange_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_paramPoly3_pRange_indexes_ + 2 || _xsd_e_paramPoly3_pRange_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_paramPoly3_pRange::
_xsd_e_paramPoly3_pRange_literals_[2] =
{
  "arcLength",
  "normalized"
};

const e_paramPoly3_pRange::value e_paramPoly3_pRange::
_xsd_e_paramPoly3_pRange_indexes_[2] =
{
  ::e_paramPoly3_pRange::arcLength,
  ::e_paramPoly3_pRange::normalized
};

// t_road_elevationProfile
//

t_road_elevationProfile::
t_road_elevationProfile ()
: ::xml_schema::type (),
  elevation_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_elevationProfile::
t_road_elevationProfile (const t_road_elevationProfile& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  elevation_ (x.elevation_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_elevationProfile::
t_road_elevationProfile (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  elevation_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_elevationProfile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // elevation
    //
    if (n.name () == "elevation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< elevation_type > r (
        elevation_traits::create (i, f, this));

      this->elevation_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_elevationProfile* t_road_elevationProfile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_elevationProfile (*this, f, c);
}

t_road_elevationProfile& t_road_elevationProfile::
operator= (const t_road_elevationProfile& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->elevation_ = x.elevation_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_elevationProfile::
~t_road_elevationProfile ()
{
}

// t_road_elevationProfile_elevation
//

t_road_elevationProfile_elevation::
t_road_elevationProfile_elevation (const s_type& s,
                                   const a_type& a,
                                   const b_type& b,
                                   const c_type& c,
                                   const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_elevationProfile_elevation::
t_road_elevationProfile_elevation (const t_road_elevationProfile_elevation& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_elevationProfile_elevation::
t_road_elevationProfile_elevation (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_elevationProfile_elevation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_elevationProfile_elevation* t_road_elevationProfile_elevation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_elevationProfile_elevation (*this, f, c);
}

t_road_elevationProfile_elevation& t_road_elevationProfile_elevation::
operator= (const t_road_elevationProfile_elevation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_elevationProfile_elevation::
~t_road_elevationProfile_elevation ()
{
}

// t_road_lateralProfile
//

t_road_lateralProfile::
t_road_lateralProfile ()
: ::xml_schema::type (),
  superelevation_ (this),
  crossfall_ (this),
  shape_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_lateralProfile::
t_road_lateralProfile (const t_road_lateralProfile& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  superelevation_ (x.superelevation_, f, this),
  crossfall_ (x.crossfall_, f, this),
  shape_ (x.shape_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lateralProfile::
t_road_lateralProfile (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  superelevation_ (this),
  crossfall_ (this),
  shape_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lateralProfile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // superelevation
    //
    if (n.name () == "superelevation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< superelevation_type > r (
        superelevation_traits::create (i, f, this));

      this->superelevation_.push_back (::std::move (r));
      continue;
    }

    // crossfall
    //
    if (n.name () == "crossfall" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< crossfall_type > r (
        crossfall_traits::create (i, f, this));

      this->crossfall_.push_back (::std::move (r));
      continue;
    }

    // shape
    //
    if (n.name () == "shape" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< shape_type > r (
        shape_traits::create (i, f, this));

      this->shape_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_lateralProfile* t_road_lateralProfile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lateralProfile (*this, f, c);
}

t_road_lateralProfile& t_road_lateralProfile::
operator= (const t_road_lateralProfile& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->superelevation_ = x.superelevation_;
    this->crossfall_ = x.crossfall_;
    this->shape_ = x.shape_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lateralProfile::
~t_road_lateralProfile ()
{
}

// t_road_lateralProfile_superelevation
//

t_road_lateralProfile_superelevation::
t_road_lateralProfile_superelevation (const s_type& s,
                                      const a_type& a,
                                      const b_type& b,
                                      const c_type& c,
                                      const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lateralProfile_superelevation::
t_road_lateralProfile_superelevation (const t_road_lateralProfile_superelevation& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lateralProfile_superelevation::
t_road_lateralProfile_superelevation (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lateralProfile_superelevation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lateralProfile_superelevation* t_road_lateralProfile_superelevation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lateralProfile_superelevation (*this, f, c);
}

t_road_lateralProfile_superelevation& t_road_lateralProfile_superelevation::
operator= (const t_road_lateralProfile_superelevation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lateralProfile_superelevation::
~t_road_lateralProfile_superelevation ()
{
}

// t_road_lateralProfile_crossfall
//

t_road_lateralProfile_crossfall::
t_road_lateralProfile_crossfall (const side_type& side,
                                 const s_type& s,
                                 const a_type& a,
                                 const b_type& b,
                                 const c_type& c,
                                 const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  side_ (side, this),
  s_ (s, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lateralProfile_crossfall::
t_road_lateralProfile_crossfall (const t_road_lateralProfile_crossfall& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  side_ (x.side_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lateralProfile_crossfall::
t_road_lateralProfile_crossfall (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  side_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lateralProfile_crossfall::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!side_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "side",
      "");
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lateralProfile_crossfall* t_road_lateralProfile_crossfall::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lateralProfile_crossfall (*this, f, c);
}

t_road_lateralProfile_crossfall& t_road_lateralProfile_crossfall::
operator= (const t_road_lateralProfile_crossfall& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->side_ = x.side_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lateralProfile_crossfall::
~t_road_lateralProfile_crossfall ()
{
}

// e_road_lateralProfile_crossfall_side
//

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_lateralProfile_crossfall_side_convert ();
}

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_lateralProfile_crossfall_side_convert ();
}

e_road_lateralProfile_crossfall_side::
e_road_lateralProfile_crossfall_side (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_lateralProfile_crossfall_side_convert ();
}

e_road_lateralProfile_crossfall_side* e_road_lateralProfile_crossfall_side::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_lateralProfile_crossfall_side (*this, f, c);
}

e_road_lateralProfile_crossfall_side::value e_road_lateralProfile_crossfall_side::
_xsd_e_road_lateralProfile_crossfall_side_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_lateralProfile_crossfall_side_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_lateralProfile_crossfall_side_indexes_,
                    _xsd_e_road_lateralProfile_crossfall_side_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_road_lateralProfile_crossfall_side_indexes_ + 3 || _xsd_e_road_lateralProfile_crossfall_side_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_lateralProfile_crossfall_side::
_xsd_e_road_lateralProfile_crossfall_side_literals_[3] =
{
  "left",
  "right",
  "both"
};

const e_road_lateralProfile_crossfall_side::value e_road_lateralProfile_crossfall_side::
_xsd_e_road_lateralProfile_crossfall_side_indexes_[3] =
{
  ::e_road_lateralProfile_crossfall_side::both,
  ::e_road_lateralProfile_crossfall_side::left,
  ::e_road_lateralProfile_crossfall_side::right
};

// t_road_lateralProfile_shape
//

t_road_lateralProfile_shape::
t_road_lateralProfile_shape (const s_type& s,
                             const t_type& t,
                             const a_type& a,
                             const b_type& b,
                             const c_type& c,
                             const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  t_ (t, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lateralProfile_shape::
t_road_lateralProfile_shape (const t_road_lateralProfile_shape& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lateralProfile_shape::
t_road_lateralProfile_shape (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  t_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lateralProfile_shape::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lateralProfile_shape* t_road_lateralProfile_shape::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lateralProfile_shape (*this, f, c);
}

t_road_lateralProfile_shape& t_road_lateralProfile_shape::
operator= (const t_road_lateralProfile_shape& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lateralProfile_shape::
~t_road_lateralProfile_shape ()
{
}

// t_road_lanes
//

t_road_lanes::
t_road_lanes ()
: ::xml_schema::type (),
  laneOffset_ (this),
  laneSection_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_lanes::
t_road_lanes (const t_road_lanes& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  laneOffset_ (x.laneOffset_, f, this),
  laneSection_ (x.laneSection_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes::
t_road_lanes (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  laneOffset_ (this),
  laneSection_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // laneOffset
    //
    if (n.name () == "laneOffset" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< laneOffset_type > r (
        laneOffset_traits::create (i, f, this));

      this->laneOffset_.push_back (::std::move (r));
      continue;
    }

    // laneSection
    //
    if (n.name () == "laneSection" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< laneSection_type > r (
        laneSection_traits::create (i, f, this));

      this->laneSection_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_lanes* t_road_lanes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes (*this, f, c);
}

t_road_lanes& t_road_lanes::
operator= (const t_road_lanes& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->laneOffset_ = x.laneOffset_;
    this->laneSection_ = x.laneSection_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes::
~t_road_lanes ()
{
}

// t_road_lanes_laneOffset
//

t_road_lanes_laneOffset::
t_road_lanes_laneOffset (const s_type& s,
                         const a_type& a,
                         const b_type& b,
                         const c_type& c,
                         const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneOffset::
t_road_lanes_laneOffset (const t_road_lanes_laneOffset& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneOffset::
t_road_lanes_laneOffset (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneOffset::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneOffset* t_road_lanes_laneOffset::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneOffset (*this, f, c);
}

t_road_lanes_laneOffset& t_road_lanes_laneOffset::
operator= (const t_road_lanes_laneOffset& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneOffset::
~t_road_lanes_laneOffset ()
{
}

// t_road_lanes_laneSection
//

t_road_lanes_laneSection::
t_road_lanes_laneSection (const s_type& s)
: ::xml_schema::type (),
  left_ (this),
  center_ (this),
  right_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  singleSide_ (this)
{
}

t_road_lanes_laneSection::
t_road_lanes_laneSection (const t_road_lanes_laneSection& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  left_ (x.left_, f, this),
  center_ (x.center_, f, this),
  right_ (x.right_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  singleSide_ (x.singleSide_, f, this)
{
}

t_road_lanes_laneSection::
t_road_lanes_laneSection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  center_ (this),
  right_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  singleSide_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!this->left_)
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< center_type > r (
        center_traits::create (i, f, this));

      if (!this->center_)
      {
        this->center_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!this->right_)
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "singleSide" && n.namespace_ ().empty ())
    {
      this->singleSide_.set (singleSide_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }
}

t_road_lanes_laneSection* t_road_lanes_laneSection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection (*this, f, c);
}

t_road_lanes_laneSection& t_road_lanes_laneSection::
operator= (const t_road_lanes_laneSection& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->left_ = x.left_;
    this->center_ = x.center_;
    this->right_ = x.right_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->singleSide_ = x.singleSide_;
  }

  return *this;
}

t_road_lanes_laneSection::
~t_road_lanes_laneSection ()
{
}

// t_road_lanes_laneSection_left
//

t_road_lanes_laneSection_left::
t_road_lanes_laneSection_left ()
: ::xml_schema::type (),
  lane_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_left::
t_road_lanes_laneSection_left (const t_road_lanes_laneSection_left& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_left::
t_road_lanes_laneSection_left (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_left::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_lanes_laneSection_left* t_road_lanes_laneSection_left::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_left (*this, f, c);
}

t_road_lanes_laneSection_left& t_road_lanes_laneSection_left::
operator= (const t_road_lanes_laneSection_left& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_left::
~t_road_lanes_laneSection_left ()
{
}

// t_road_lanes_laneSection_center
//

t_road_lanes_laneSection_center::
t_road_lanes_laneSection_center ()
: ::xml_schema::type (),
  lane_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_center::
t_road_lanes_laneSection_center (const t_road_lanes_laneSection_center& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_center::
t_road_lanes_laneSection_center (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_center::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_lanes_laneSection_center* t_road_lanes_laneSection_center::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_center (*this, f, c);
}

t_road_lanes_laneSection_center& t_road_lanes_laneSection_center::
operator= (const t_road_lanes_laneSection_center& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_center::
~t_road_lanes_laneSection_center ()
{
}

// t_road_lanes_laneSection_right
//

t_road_lanes_laneSection_right::
t_road_lanes_laneSection_right ()
: ::xml_schema::type (),
  lane_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_right::
t_road_lanes_laneSection_right (const t_road_lanes_laneSection_right& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_right::
t_road_lanes_laneSection_right (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_right::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_lanes_laneSection_right* t_road_lanes_laneSection_right::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_right (*this, f, c);
}

t_road_lanes_laneSection_right& t_road_lanes_laneSection_right::
operator= (const t_road_lanes_laneSection_right& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_right::
~t_road_lanes_laneSection_right ()
{
}

// t_road_lanes_laneSection_center_lane
//

t_road_lanes_laneSection_center_lane::
t_road_lanes_laneSection_center_lane (const type_type& type)
: ::xml_schema::type (),
  link_ (this),
  roadMark_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id_default_value (), this),
  type_ (type, this),
  level_ (this)
{
}

t_road_lanes_laneSection_center_lane::
t_road_lanes_laneSection_center_lane (const t_road_lanes_laneSection_center_lane& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  link_ (x.link_, f, this),
  roadMark_ (x.roadMark_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  level_ (x.level_, f, this)
{
}

t_road_lanes_laneSection_center_lane::
t_road_lanes_laneSection_center_lane (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  link_ (this),
  roadMark_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  type_ (this),
  level_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_center_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->link_)
      {
        this->link_.set (::std::move (r));
        continue;
      }
    }

    // roadMark
    //
    if (n.name () == "roadMark" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< roadMark_type > r (
        roadMark_traits::create (i, f, this));

      this->roadMark_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "level" && n.namespace_ ().empty ())
    {
      this->level_.set (level_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    this->id_.set (id_default_value ());
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_lanes_laneSection_center_lane* t_road_lanes_laneSection_center_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_center_lane (*this, f, c);
}

t_road_lanes_laneSection_center_lane& t_road_lanes_laneSection_center_lane::
operator= (const t_road_lanes_laneSection_center_lane& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->link_ = x.link_;
    this->roadMark_ = x.roadMark_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->level_ = x.level_;
  }

  return *this;
}

t_road_lanes_laneSection_center_lane::
~t_road_lanes_laneSection_center_lane ()
{
}

// t_road_lanes_laneSection_lr_lane
//

t_road_lanes_laneSection_lr_lane::
t_road_lanes_laneSection_lr_lane (const type_type& type)
: ::xml_schema::type (),
  link_ (this),
  width_ (this),
  border_ (this),
  roadMark_ (this),
  material_ (this),
  visibility_ (this),
  speed_ (this),
  access_ (this),
  height_ (this),
  rule_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  type_ (type, this),
  level_ (this)
{
}

t_road_lanes_laneSection_lr_lane::
t_road_lanes_laneSection_lr_lane (const t_road_lanes_laneSection_lr_lane& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  link_ (x.link_, f, this),
  width_ (x.width_, f, this),
  border_ (x.border_, f, this),
  roadMark_ (x.roadMark_, f, this),
  material_ (x.material_, f, this),
  visibility_ (x.visibility_, f, this),
  speed_ (x.speed_, f, this),
  access_ (x.access_, f, this),
  height_ (x.height_, f, this),
  rule_ (x.rule_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  type_ (x.type_, f, this),
  level_ (x.level_, f, this)
{
}

t_road_lanes_laneSection_lr_lane::
t_road_lanes_laneSection_lr_lane (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  link_ (this),
  width_ (this),
  border_ (this),
  roadMark_ (this),
  material_ (this),
  visibility_ (this),
  speed_ (this),
  access_ (this),
  height_ (this),
  rule_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  type_ (this),
  level_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!this->link_)
      {
        this->link_.set (::std::move (r));
        continue;
      }
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< width_type > r (
        width_traits::create (i, f, this));

      this->width_.push_back (::std::move (r));
      continue;
    }

    // border
    //
    if (n.name () == "border" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< border_type > r (
        border_traits::create (i, f, this));

      this->border_.push_back (::std::move (r));
      continue;
    }

    // roadMark
    //
    if (n.name () == "roadMark" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< roadMark_type > r (
        roadMark_traits::create (i, f, this));

      this->roadMark_.push_back (::std::move (r));
      continue;
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< material_type > r (
        material_traits::create (i, f, this));

      this->material_.push_back (::std::move (r));
      continue;
    }

    // visibility
    //
    if (n.name () == "visibility" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< visibility_type > r (
        visibility_traits::create (i, f, this));

      this->visibility_.push_back (::std::move (r));
      continue;
    }

    // speed
    //
    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      this->speed_.push_back (::std::move (r));
      continue;
    }

    // access
    //
    if (n.name () == "access" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< access_type > r (
        access_traits::create (i, f, this));

      this->access_.push_back (::std::move (r));
      continue;
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< height_type > r (
        height_traits::create (i, f, this));

      this->height_.push_back (::std::move (r));
      continue;
    }

    // rule
    //
    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< rule_type > r (
        rule_traits::create (i, f, this));

      this->rule_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "level" && n.namespace_ ().empty ())
    {
      this->level_.set (level_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_lanes_laneSection_lr_lane* t_road_lanes_laneSection_lr_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane (*this, f, c);
}

t_road_lanes_laneSection_lr_lane& t_road_lanes_laneSection_lr_lane::
operator= (const t_road_lanes_laneSection_lr_lane& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->link_ = x.link_;
    this->width_ = x.width_;
    this->border_ = x.border_;
    this->roadMark_ = x.roadMark_;
    this->material_ = x.material_;
    this->visibility_ = x.visibility_;
    this->speed_ = x.speed_;
    this->access_ = x.access_;
    this->height_ = x.height_;
    this->rule_ = x.rule_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->type_ = x.type_;
    this->level_ = x.level_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane::
~t_road_lanes_laneSection_lr_lane ()
{
}

// t_road_lanes_laneSection_left_lane
//

t_road_lanes_laneSection_left_lane::
t_road_lanes_laneSection_left_lane (const type_type& type,
                                    const id_type& id)
: ::t_road_lanes_laneSection_lr_lane (type),
  id_ (id, this)
{
}

t_road_lanes_laneSection_left_lane::
t_road_lanes_laneSection_left_lane (const t_road_lanes_laneSection_left_lane& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (x, f, c),
  id_ (x.id_, f, this)
{
}

t_road_lanes_laneSection_left_lane::
t_road_lanes_laneSection_left_lane (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_left_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::t_road_lanes_laneSection_lr_lane::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_lanes_laneSection_left_lane* t_road_lanes_laneSection_left_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_left_lane (*this, f, c);
}

t_road_lanes_laneSection_left_lane& t_road_lanes_laneSection_left_lane::
operator= (const t_road_lanes_laneSection_left_lane& x)
{
  if (this != &x)
  {
    static_cast< ::t_road_lanes_laneSection_lr_lane& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_lanes_laneSection_left_lane::
~t_road_lanes_laneSection_left_lane ()
{
}

// t_road_lanes_laneSection_right_lane
//

t_road_lanes_laneSection_right_lane::
t_road_lanes_laneSection_right_lane (const type_type& type,
                                     const id_type& id)
: ::t_road_lanes_laneSection_lr_lane (type),
  id_ (id, this)
{
}

t_road_lanes_laneSection_right_lane::
t_road_lanes_laneSection_right_lane (const t_road_lanes_laneSection_right_lane& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (x, f, c),
  id_ (x.id_, f, this)
{
}

t_road_lanes_laneSection_right_lane::
t_road_lanes_laneSection_right_lane (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::t_road_lanes_laneSection_lr_lane (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_right_lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::t_road_lanes_laneSection_lr_lane::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_lanes_laneSection_right_lane* t_road_lanes_laneSection_right_lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_right_lane (*this, f, c);
}

t_road_lanes_laneSection_right_lane& t_road_lanes_laneSection_right_lane::
operator= (const t_road_lanes_laneSection_right_lane& x)
{
  if (this != &x)
  {
    static_cast< ::t_road_lanes_laneSection_lr_lane& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_lanes_laneSection_right_lane::
~t_road_lanes_laneSection_right_lane ()
{
}

// t_road_lanes_laneSection_lcr_lane_link
//

t_road_lanes_laneSection_lcr_lane_link::
t_road_lanes_laneSection_lcr_lane_link ()
: ::xml_schema::type (),
  predecessor_ (this),
  successor_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_link::
t_road_lanes_laneSection_lcr_lane_link (const t_road_lanes_laneSection_lcr_lane_link& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_link::
t_road_lanes_laneSection_lcr_lane_link (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_link::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      this->predecessor_.push_back (::std::move (r));
      continue;
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      this->successor_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_lanes_laneSection_lcr_lane_link* t_road_lanes_laneSection_lcr_lane_link::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_link (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_link& t_road_lanes_laneSection_lcr_lane_link::
operator= (const t_road_lanes_laneSection_lcr_lane_link& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_link::
~t_road_lanes_laneSection_lcr_lane_link ()
{
}

// t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor
//

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const id_type& id)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this)
{
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& x,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                                             ::xml_schema::flags f,
                                                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor* t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
operator= (const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::
~t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor ()
{
}

// t_road_lanes_laneSection_lr_lane_width
//

t_road_lanes_laneSection_lr_lane_width::
t_road_lanes_laneSection_lr_lane_width (const sOffset_type& sOffset,
                                        const a_type& a,
                                        const b_type& b,
                                        const c_type& c,
                                        const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneSection_lr_lane_width::
t_road_lanes_laneSection_lr_lane_width (const t_road_lanes_laneSection_lr_lane_width& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_width::
t_road_lanes_laneSection_lr_lane_width (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_width::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_width* t_road_lanes_laneSection_lr_lane_width::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_width (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_width& t_road_lanes_laneSection_lr_lane_width::
operator= (const t_road_lanes_laneSection_lr_lane_width& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_width::
~t_road_lanes_laneSection_lr_lane_width ()
{
}

// t_road_lanes_laneSection_lr_lane_border
//

t_road_lanes_laneSection_lr_lane_border::
t_road_lanes_laneSection_lr_lane_border (const sOffset_type& sOffset,
                                         const a_type& a,
                                         const b_type& b,
                                         const c_type& c,
                                         const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneSection_lr_lane_border::
t_road_lanes_laneSection_lr_lane_border (const t_road_lanes_laneSection_lr_lane_border& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_border::
t_road_lanes_laneSection_lr_lane_border (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_border::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_border* t_road_lanes_laneSection_lr_lane_border::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_border (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_border& t_road_lanes_laneSection_lr_lane_border::
operator= (const t_road_lanes_laneSection_lr_lane_border& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_border::
~t_road_lanes_laneSection_lr_lane_border ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark
//

t_road_lanes_laneSection_lcr_lane_roadMark::
t_road_lanes_laneSection_lcr_lane_roadMark (const sOffset_type& sOffset,
                                            const type1_type& type1,
                                            const color_type& color)
: ::xml_schema::type (),
  sway_ (this),
  type_ (this),
  explicit__ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  type1_ (type1, this),
  weight_ (this),
  color_ (color, this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark::
t_road_lanes_laneSection_lcr_lane_roadMark (const t_road_lanes_laneSection_lcr_lane_roadMark& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  sway_ (x.sway_, f, this),
  type_ (x.type_, f, this),
  explicit__ (x.explicit__, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  type1_ (x.type1_, f, this),
  weight_ (x.weight_, f, this),
  color_ (x.color_, f, this),
  material_ (x.material_, f, this),
  width_ (x.width_, f, this),
  laneChange_ (x.laneChange_, f, this),
  height_ (x.height_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark::
t_road_lanes_laneSection_lcr_lane_roadMark (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  sway_ (this),
  type_ (this),
  explicit__ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  type1_ (this),
  weight_ (this),
  color_ (this),
  material_ (this),
  width_ (this),
  laneChange_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // sway
    //
    if (n.name () == "sway" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sway_type > r (
        sway_traits::create (i, f, this));

      this->sway_.push_back (::std::move (r));
      continue;
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!this->type_)
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // explicit
    //
    if (n.name () == "explicit" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< explicit_type > r (
        explicit_traits::create (i, f, this));

      if (!this->explicit__)
      {
        this->explicit__.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type1_.set (type1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      this->weight_.set (weight_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      this->material_.set (material_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "laneChange" && n.namespace_ ().empty ())
    {
      this->laneChange_.set (laneChange_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!type1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!color_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "color",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark* t_road_lanes_laneSection_lcr_lane_roadMark::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark& t_road_lanes_laneSection_lcr_lane_roadMark::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->sway_ = x.sway_;
    this->type_ = x.type_;
    this->explicit__ = x.explicit__;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->type1_ = x.type1_;
    this->weight_ = x.weight_;
    this->color_ = x.color_;
    this->material_ = x.material_;
    this->width_ = x.width_;
    this->laneChange_ = x.laneChange_;
    this->height_ = x.height_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark::
~t_road_lanes_laneSection_lcr_lane_roadMark ()
{
}

// e_road_lanes_laneSection_lcr_lane_roadMark_laneChange
//

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert ();
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xercesc::DOMAttr& a,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert ();
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::std::string& s,
                                                       const ::xercesc::DOMElement* e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert ();
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange* e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (*this, f, c);
}

e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::value e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_,
                    _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_ + 4 || _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[4] =
{
  "increase",
  "decrease",
  "both",
  "none"
};

const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::value e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::
_xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_[4] =
{
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::both,
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::decrease,
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::increase,
  ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange::none
};

// t_road_lanes_laneSection_lcr_lane_roadMark_sway
//

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
t_road_lanes_laneSection_lcr_lane_roadMark_sway (const ds_type& ds,
                                                 const a_type& a,
                                                 const b_type& b,
                                                 const c_type& c,
                                                 const d_type& d)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  ds_ (ds, this),
  a_ (a, this),
  b_ (b, this),
  c_ (c, this),
  d_ (d, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
t_road_lanes_laneSection_lcr_lane_roadMark_sway (const t_road_lanes_laneSection_lcr_lane_roadMark_sway& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  ds_ (x.ds_, f, this),
  a_ (x.a_, f, this),
  b_ (x.b_, f, this),
  c_ (x.c_, f, this),
  d_ (x.d_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
t_road_lanes_laneSection_lcr_lane_roadMark_sway (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  ds_ (this),
  a_ (this),
  b_ (this),
  c_ (this),
  d_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_sway::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ds" && n.namespace_ ().empty ())
    {
      this->ds_.set (ds_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "a" && n.namespace_ ().empty ())
    {
      this->a_.set (a_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "c" && n.namespace_ ().empty ())
    {
      this->c_.set (c_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "d" && n.namespace_ ().empty ())
    {
      this->d_.set (d_traits::create (i, f, this));
      continue;
    }
  }

  if (!ds_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ds",
      "");
  }

  if (!a_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "a",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!c_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "c",
      "");
  }

  if (!d_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "d",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway* t_road_lanes_laneSection_lcr_lane_roadMark_sway::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_sway (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway& t_road_lanes_laneSection_lcr_lane_roadMark_sway::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_sway& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->ds_ = x.ds_;
    this->a_ = x.a_;
    this->b_ = x.b_;
    this->c_ = x.c_;
    this->d_ = x.d_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_sway::
~t_road_lanes_laneSection_lcr_lane_roadMark_sway ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_type
//

t_road_lanes_laneSection_lcr_lane_roadMark_type::
t_road_lanes_laneSection_lcr_lane_roadMark_type (const name_type& name,
                                                 const width_type& width)
: ::xml_schema::type (),
  line_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (name, this),
  width_ (width, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::
t_road_lanes_laneSection_lcr_lane_roadMark_type (const t_road_lanes_laneSection_lcr_lane_roadMark_type& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  line_ (x.line_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  width_ (x.width_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::
t_road_lanes_laneSection_lcr_lane_roadMark_type (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  width_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< line_type > r (
        line_traits::create (i, f, this));

      this->line_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_type* t_road_lanes_laneSection_lcr_lane_roadMark_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_type (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_type& t_road_lanes_laneSection_lcr_lane_roadMark_type::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->line_ = x.line_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->width_ = x.width_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type::
~t_road_lanes_laneSection_lcr_lane_roadMark_type ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_type_line
//

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const length_type& length,
                                                      const space_type& space,
                                                      const tOffset_type& tOffset,
                                                      const sOffset_type& sOffset,
                                                      const width_type& width)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  length_ (length, this),
  space_ (space, this),
  tOffset_ (tOffset, this),
  sOffset_ (sOffset, this),
  rule_ (this),
  width_ (width, this),
  color_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const t_road_lanes_laneSection_lcr_lane_roadMark_type_line& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  length_ (x.length_, f, this),
  space_ (x.space_, f, this),
  tOffset_ (x.tOffset_, f, this),
  sOffset_ (x.sOffset_, f, this),
  rule_ (x.rule_, f, this),
  width_ (x.width_, f, this),
  color_ (x.color_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  length_ (this),
  space_ (this),
  tOffset_ (this),
  sOffset_ (this),
  rule_ (this),
  width_ (this),
  color_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "space" && n.namespace_ ().empty ())
    {
      this->space_.set (space_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!space_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "space",
      "");
  }

  if (!tOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tOffset",
      "");
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line* t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_type_line (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line& t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_type_line& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->length_ = x.length_;
    this->space_ = x.space_;
    this->tOffset_ = x.tOffset_;
    this->sOffset_ = x.sOffset_;
    this->rule_ = x.rule_;
    this->width_ = x.width_;
    this->color_ = x.color_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_type_line::
~t_road_lanes_laneSection_lcr_lane_roadMark_type_line ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_explicit
//

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit ()
: ::xml_schema::type (),
  line_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  line_ (x.line_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  line_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // line
    //
    if (n.name () == "line" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< line_type > r (
        line_traits::create (i, f, this));

      this->line_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit* t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_explicit (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit& t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->line_ = x.line_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit::
~t_road_lanes_laneSection_lcr_lane_roadMark_explicit ()
{
}

// t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line
//

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const length_type& length,
                                                          const tOffset_type& tOffset,
                                                          const sOffset_type& sOffset,
                                                          const width_type& width)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  length_ (length, this),
  tOffset_ (tOffset, this),
  sOffset_ (sOffset, this),
  rule_ (this),
  width_ (width, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& x,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  length_ (x.length_, f, this),
  tOffset_ (x.tOffset_, f, this),
  sOffset_ (x.sOffset_, f, this),
  rule_ (x.rule_, f, this),
  width_ (x.width_, f, this)
{
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f,
                                                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  length_ (this),
  tOffset_ (this),
  sOffset_ (this),
  rule_ (this),
  width_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!tOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tOffset",
      "");
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line* t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (*this, f, c);
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->length_ = x.length_;
    this->tOffset_ = x.tOffset_;
    this->sOffset_ = x.sOffset_;
    this->rule_ = x.rule_;
    this->width_ = x.width_;
  }

  return *this;
}

t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::
~t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line ()
{
}

// t_road_lanes_laneSection_lr_lane_material
//

t_road_lanes_laneSection_lr_lane_material::
t_road_lanes_laneSection_lr_lane_material (const sOffset_type& sOffset,
                                           const friction_type& friction)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  surface_ (this),
  friction_ (friction, this),
  roughness_ (this)
{
}

t_road_lanes_laneSection_lr_lane_material::
t_road_lanes_laneSection_lr_lane_material (const t_road_lanes_laneSection_lr_lane_material& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  surface_ (x.surface_, f, this),
  friction_ (x.friction_, f, this),
  roughness_ (x.roughness_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_material::
t_road_lanes_laneSection_lr_lane_material (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      this->surface_.set (surface_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "friction" && n.namespace_ ().empty ())
    {
      this->friction_.set (friction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roughness" && n.namespace_ ().empty ())
    {
      this->roughness_.set (roughness_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!friction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "friction",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_material* t_road_lanes_laneSection_lr_lane_material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_material (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_material& t_road_lanes_laneSection_lr_lane_material::
operator= (const t_road_lanes_laneSection_lr_lane_material& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->surface_ = x.surface_;
    this->friction_ = x.friction_;
    this->roughness_ = x.roughness_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_material::
~t_road_lanes_laneSection_lr_lane_material ()
{
}

// t_road_lanes_laneSection_lr_lane_visibility
//

t_road_lanes_laneSection_lr_lane_visibility::
t_road_lanes_laneSection_lr_lane_visibility (const sOffset_type& sOffset,
                                             const forward_type& forward,
                                             const back_type& back,
                                             const left_type& left,
                                             const right_type& right)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  forward_ (forward, this),
  back_ (back, this),
  left_ (left, this),
  right_ (right, this)
{
}

t_road_lanes_laneSection_lr_lane_visibility::
t_road_lanes_laneSection_lr_lane_visibility (const t_road_lanes_laneSection_lr_lane_visibility& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  forward_ (x.forward_, f, this),
  back_ (x.back_, f, this),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_visibility::
t_road_lanes_laneSection_lr_lane_visibility (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  forward_ (this),
  back_ (this),
  left_ (this),
  right_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_visibility::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "forward" && n.namespace_ ().empty ())
    {
      this->forward_.set (forward_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      this->back_.set (back_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      this->left_.set (left_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      this->right_.set (right_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!forward_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "forward",
      "");
  }

  if (!back_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "back",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "left",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "right",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_visibility* t_road_lanes_laneSection_lr_lane_visibility::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_visibility (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_visibility& t_road_lanes_laneSection_lr_lane_visibility::
operator= (const t_road_lanes_laneSection_lr_lane_visibility& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->forward_ = x.forward_;
    this->back_ = x.back_;
    this->left_ = x.left_;
    this->right_ = x.right_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_visibility::
~t_road_lanes_laneSection_lr_lane_visibility ()
{
}

// t_road_lanes_laneSection_lr_lane_speed
//

t_road_lanes_laneSection_lr_lane_speed::
t_road_lanes_laneSection_lr_lane_speed (const sOffset_type& sOffset,
                                        const max_type& fmax)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  fmax_ (fmax, this),
  unit_ (this)
{
}

t_road_lanes_laneSection_lr_lane_speed::
t_road_lanes_laneSection_lr_lane_speed (const t_road_lanes_laneSection_lr_lane_speed& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  fmax_ (x.fmax_, f, this),
  unit_ (x.unit_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_speed::
t_road_lanes_laneSection_lr_lane_speed (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  fmax_ (this),
  unit_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->fmax_.set (max_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!fmax_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_speed* t_road_lanes_laneSection_lr_lane_speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_speed (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_speed& t_road_lanes_laneSection_lr_lane_speed::
operator= (const t_road_lanes_laneSection_lr_lane_speed& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->fmax_ = x.fmax_;
    this->unit_ = x.unit_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_speed::
~t_road_lanes_laneSection_lr_lane_speed ()
{
}

// t_road_lanes_laneSection_lr_lane_access
//

t_road_lanes_laneSection_lr_lane_access::
t_road_lanes_laneSection_lr_lane_access (const sOffset_type& sOffset,
                                         const rule_type& rule,
                                         const restriction_type& restriction)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  rule_ (rule, this),
  restriction_ (restriction, this)
{
}

t_road_lanes_laneSection_lr_lane_access::
t_road_lanes_laneSection_lr_lane_access (const t_road_lanes_laneSection_lr_lane_access& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  rule_ (x.rule_, f, this),
  restriction_ (x.restriction_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_access::
t_road_lanes_laneSection_lr_lane_access (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  rule_ (this),
  restriction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_access::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rule" && n.namespace_ ().empty ())
    {
      this->rule_.set (rule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "restriction" && n.namespace_ ().empty ())
    {
      this->restriction_.set (restriction_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!rule_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "rule",
      "");
  }

  if (!restriction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "restriction",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_access* t_road_lanes_laneSection_lr_lane_access::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_access (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_access& t_road_lanes_laneSection_lr_lane_access::
operator= (const t_road_lanes_laneSection_lr_lane_access& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->rule_ = x.rule_;
    this->restriction_ = x.restriction_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_access::
~t_road_lanes_laneSection_lr_lane_access ()
{
}

// e_road_lanes_laneSection_lr_lane_access_rule
//

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert ();
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert ();
}

e_road_lanes_laneSection_lr_lane_access_rule::
e_road_lanes_laneSection_lr_lane_access_rule (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert ();
}

e_road_lanes_laneSection_lr_lane_access_rule* e_road_lanes_laneSection_lr_lane_access_rule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_lanes_laneSection_lr_lane_access_rule (*this, f, c);
}

e_road_lanes_laneSection_lr_lane_access_rule::value e_road_lanes_laneSection_lr_lane_access_rule::
_xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_,
                    _xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_ + 2 || _xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_lanes_laneSection_lr_lane_access_rule::
_xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[2] =
{
  "allow",
  "deny"
};

const e_road_lanes_laneSection_lr_lane_access_rule::value e_road_lanes_laneSection_lr_lane_access_rule::
_xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_[2] =
{
  ::e_road_lanes_laneSection_lr_lane_access_rule::allow,
  ::e_road_lanes_laneSection_lr_lane_access_rule::deny
};

// t_road_lanes_laneSection_lr_lane_height
//

t_road_lanes_laneSection_lr_lane_height::
t_road_lanes_laneSection_lr_lane_height (const sOffset_type& sOffset,
                                         const inner_type& inner,
                                         const outer_type& outer)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  inner_ (inner, this),
  outer_ (outer, this)
{
}

t_road_lanes_laneSection_lr_lane_height::
t_road_lanes_laneSection_lr_lane_height (const t_road_lanes_laneSection_lr_lane_height& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  inner_ (x.inner_, f, this),
  outer_ (x.outer_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_height::
t_road_lanes_laneSection_lr_lane_height (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  inner_ (this),
  outer_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_height::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "inner" && n.namespace_ ().empty ())
    {
      this->inner_.set (inner_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outer" && n.namespace_ ().empty ())
    {
      this->outer_.set (outer_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!inner_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "inner",
      "");
  }

  if (!outer_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "outer",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_height* t_road_lanes_laneSection_lr_lane_height::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_height (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_height& t_road_lanes_laneSection_lr_lane_height::
operator= (const t_road_lanes_laneSection_lr_lane_height& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->inner_ = x.inner_;
    this->outer_ = x.outer_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_height::
~t_road_lanes_laneSection_lr_lane_height ()
{
}

// t_road_lanes_laneSection_lr_lane_rule
//

t_road_lanes_laneSection_lr_lane_rule::
t_road_lanes_laneSection_lr_lane_rule (const sOffset_type& sOffset,
                                       const value_type& value)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (sOffset, this),
  value_ (value, this)
{
}

t_road_lanes_laneSection_lr_lane_rule::
t_road_lanes_laneSection_lr_lane_rule (const t_road_lanes_laneSection_lr_lane_rule& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  sOffset_ (x.sOffset_, f, this),
  value_ (x.value_, f, this)
{
}

t_road_lanes_laneSection_lr_lane_rule::
t_road_lanes_laneSection_lr_lane_rule (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  sOffset_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_lanes_laneSection_lr_lane_rule::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }

  if (!sOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sOffset",
      "");
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }
}

t_road_lanes_laneSection_lr_lane_rule* t_road_lanes_laneSection_lr_lane_rule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_lanes_laneSection_lr_lane_rule (*this, f, c);
}

t_road_lanes_laneSection_lr_lane_rule& t_road_lanes_laneSection_lr_lane_rule::
operator= (const t_road_lanes_laneSection_lr_lane_rule& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->sOffset_ = x.sOffset_;
    this->value_ = x.value_;
  }

  return *this;
}

t_road_lanes_laneSection_lr_lane_rule::
~t_road_lanes_laneSection_lr_lane_rule ()
{
}

// t_road_objects
//

t_road_objects::
t_road_objects ()
: ::xml_schema::type (),
  object_ (this),
  objectReference_ (this),
  tunnel_ (this),
  bridge_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_objects::
t_road_objects (const t_road_objects& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  object_ (x.object_, f, this),
  objectReference_ (x.objectReference_, f, this),
  tunnel_ (x.tunnel_, f, this),
  bridge_ (x.bridge_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects::
t_road_objects (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  object_ (this),
  objectReference_ (this),
  tunnel_ (this),
  bridge_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // object
    //
    if (n.name () == "object" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< object_type > r (
        object_traits::create (i, f, this));

      this->object_.push_back (::std::move (r));
      continue;
    }

    // objectReference
    //
    if (n.name () == "objectReference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< objectReference_type > r (
        objectReference_traits::create (i, f, this));

      this->objectReference_.push_back (::std::move (r));
      continue;
    }

    // tunnel
    //
    if (n.name () == "tunnel" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< tunnel_type > r (
        tunnel_traits::create (i, f, this));

      this->tunnel_.push_back (::std::move (r));
      continue;
    }

    // bridge
    //
    if (n.name () == "bridge" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< bridge_type > r (
        bridge_traits::create (i, f, this));

      this->bridge_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_objects* t_road_objects::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects (*this, f, c);
}

t_road_objects& t_road_objects::
operator= (const t_road_objects& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->object_ = x.object_;
    this->objectReference_ = x.objectReference_;
    this->tunnel_ = x.tunnel_;
    this->bridge_ = x.bridge_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects::
~t_road_objects ()
{
}

// t_road_objects_object
//

t_road_objects_object::
t_road_objects_object (const dynamic_type& dynamic,
                       const id_type& id,
                       const s_type& s,
                       const t_type& t,
                       const zOffset_type& zOffset,
                       const validLength_type& validLength,
                       const orientation_type& orientation,
                       const hdg_type& hdg,
                       const pitch_type& pitch,
                       const roll_type& roll,
                       const height_type& height)
: ::xml_schema::type (),
  repeat_ (this),
  outline_ (this),
  outlines_ (this),
  material_ (this),
  validity_ (this),
  parkingSpace_ (this),
  markings_ (this),
  borders_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  type_ (this),
  subtype_ (this),
  dynamic_ (dynamic, this),
  name_ (this),
  id_ (id, this),
  s_ (s, this),
  t_ (t, this),
  zOffset_ (zOffset, this),
  validLength_ (validLength, this),
  orientation_ (orientation, this),
  hdg_ (hdg, this),
  pitch_ (pitch, this),
  roll_ (roll, this),
  height_ (height, this),
  length_ (this),
  width_ (this),
  radius_ (this)
{
}

t_road_objects_object::
t_road_objects_object (const t_road_objects_object& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  repeat_ (x.repeat_, f, this),
  outline_ (x.outline_, f, this),
  outlines_ (x.outlines_, f, this),
  material_ (x.material_, f, this),
  validity_ (x.validity_, f, this),
  parkingSpace_ (x.parkingSpace_, f, this),
  markings_ (x.markings_, f, this),
  borders_ (x.borders_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  type_ (x.type_, f, this),
  subtype_ (x.subtype_, f, this),
  dynamic_ (x.dynamic_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  zOffset_ (x.zOffset_, f, this),
  validLength_ (x.validLength_, f, this),
  orientation_ (x.orientation_, f, this),
  hdg_ (x.hdg_, f, this),
  pitch_ (x.pitch_, f, this),
  roll_ (x.roll_, f, this),
  height_ (x.height_, f, this),
  length_ (x.length_, f, this),
  width_ (x.width_, f, this),
  radius_ (x.radius_, f, this)
{
}

t_road_objects_object::
t_road_objects_object (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  repeat_ (this),
  outline_ (this),
  outlines_ (this),
  material_ (this),
  validity_ (this),
  parkingSpace_ (this),
  markings_ (this),
  borders_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  type_ (this),
  subtype_ (this),
  dynamic_ (this),
  name_ (this),
  id_ (this),
  s_ (this),
  t_ (this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (this),
  hdg_ (this),
  pitch_ (this),
  roll_ (this),
  height_ (this),
  length_ (this),
  width_ (this),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // repeat
    //
    if (n.name () == "repeat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< repeat_type > r (
        repeat_traits::create (i, f, this));

      if (!this->repeat_)
      {
        this->repeat_.set (::std::move (r));
        continue;
      }
    }

    // outline
    //
    if (n.name () == "outline" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outline_type > r (
        outline_traits::create (i, f, this));

      if (!this->outline_)
      {
        this->outline_.set (::std::move (r));
        continue;
      }
    }

    // outlines
    //
    if (n.name () == "outlines" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outlines_type > r (
        outlines_traits::create (i, f, this));

      if (!this->outlines_)
      {
        this->outlines_.set (::std::move (r));
        continue;
      }
    }

    // material
    //
    if (n.name () == "material" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< material_type > r (
        material_traits::create (i, f, this));

      this->material_.push_back (::std::move (r));
      continue;
    }

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (::std::move (r));
      continue;
    }

    // parkingSpace
    //
    if (n.name () == "parkingSpace" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< parkingSpace_type > r (
        parkingSpace_traits::create (i, f, this));

      if (!this->parkingSpace_)
      {
        this->parkingSpace_.set (::std::move (r));
        continue;
      }
    }

    // markings
    //
    if (n.name () == "markings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< markings_type > r (
        markings_traits::create (i, f, this));

      if (!this->markings_)
      {
        this->markings_.set (::std::move (r));
        continue;
      }
    }

    // borders
    //
    if (n.name () == "borders" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< borders_type > r (
        borders_traits::create (i, f, this));

      if (!this->borders_)
      {
        this->borders_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "subtype" && n.namespace_ ().empty ())
    {
      this->subtype_.set (subtype_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dynamic" && n.namespace_ ().empty ())
    {
      this->dynamic_.set (dynamic_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "validLength" && n.namespace_ ().empty ())
    {
      this->validLength_.set (validLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      this->pitch_.set (pitch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roll" && n.namespace_ ().empty ())
    {
      this->roll_.set (roll_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }
  }

  if (!dynamic_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dynamic",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!zOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffset",
      "");
  }

  if (!validLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "validLength",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "orientation",
      "");
  }

  if (!hdg_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hdg",
      "");
  }

  if (!pitch_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "pitch",
      "");
  }

  if (!roll_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "roll",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }
}

t_road_objects_object* t_road_objects_object::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object (*this, f, c);
}

t_road_objects_object& t_road_objects_object::
operator= (const t_road_objects_object& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->repeat_ = x.repeat_;
    this->outline_ = x.outline_;
    this->outlines_ = x.outlines_;
    this->material_ = x.material_;
    this->validity_ = x.validity_;
    this->parkingSpace_ = x.parkingSpace_;
    this->markings_ = x.markings_;
    this->borders_ = x.borders_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->type_ = x.type_;
    this->subtype_ = x.subtype_;
    this->dynamic_ = x.dynamic_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->zOffset_ = x.zOffset_;
    this->validLength_ = x.validLength_;
    this->orientation_ = x.orientation_;
    this->hdg_ = x.hdg_;
    this->pitch_ = x.pitch_;
    this->roll_ = x.roll_;
    this->height_ = x.height_;
    this->length_ = x.length_;
    this->width_ = x.width_;
    this->radius_ = x.radius_;
  }

  return *this;
}

t_road_objects_object::
~t_road_objects_object ()
{
}

// t_road_objects_object_repeat
//

t_road_objects_object_repeat::
t_road_objects_object_repeat (const s_type& s,
                              const length_type& length,
                              const distance_type& distance,
                              const tStart_type& tStart,
                              const tEnd_type& tEnd,
                              const heightStart_type& heightStart,
                              const heightEnd_type& heightEnd,
                              const zOffsetStart_type& zOffsetStart,
                              const zOffsetEnd_type& zOffsetEnd,
                              const widthStart_type& widthStart,
                              const widthEnd_type& widthEnd)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  length_ (length, this),
  distance_ (distance, this),
  tStart_ (tStart, this),
  tEnd_ (tEnd, this),
  heightStart_ (heightStart, this),
  heightEnd_ (heightEnd, this),
  zOffsetStart_ (zOffsetStart, this),
  zOffsetEnd_ (zOffsetEnd, this),
  widthStart_ (widthStart, this),
  widthEnd_ (widthEnd, this),
  lengthStart_ (this),
  lengthEnd_ (this),
  radiusStart_ (this),
  radiusEnd_ (this)
{
}

t_road_objects_object_repeat::
t_road_objects_object_repeat (const t_road_objects_object_repeat& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  distance_ (x.distance_, f, this),
  tStart_ (x.tStart_, f, this),
  tEnd_ (x.tEnd_, f, this),
  heightStart_ (x.heightStart_, f, this),
  heightEnd_ (x.heightEnd_, f, this),
  zOffsetStart_ (x.zOffsetStart_, f, this),
  zOffsetEnd_ (x.zOffsetEnd_, f, this),
  widthStart_ (x.widthStart_, f, this),
  widthEnd_ (x.widthEnd_, f, this),
  lengthStart_ (x.lengthStart_, f, this),
  lengthEnd_ (x.lengthEnd_, f, this),
  radiusStart_ (x.radiusStart_, f, this),
  radiusEnd_ (x.radiusEnd_, f, this)
{
}

t_road_objects_object_repeat::
t_road_objects_object_repeat (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  length_ (this),
  distance_ (this),
  tStart_ (this),
  tEnd_ (this),
  heightStart_ (this),
  heightEnd_ (this),
  zOffsetStart_ (this),
  zOffsetEnd_ (this),
  widthStart_ (this),
  widthEnd_ (this),
  lengthStart_ (this),
  lengthEnd_ (this),
  radiusStart_ (this),
  radiusEnd_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_repeat::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      this->distance_.set (distance_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tStart" && n.namespace_ ().empty ())
    {
      this->tStart_.set (tStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      this->tEnd_.set (tEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "heightStart" && n.namespace_ ().empty ())
    {
      this->heightStart_.set (heightStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "heightEnd" && n.namespace_ ().empty ())
    {
      this->heightEnd_.set (heightEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffsetStart" && n.namespace_ ().empty ())
    {
      this->zOffsetStart_.set (zOffsetStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffsetEnd" && n.namespace_ ().empty ())
    {
      this->zOffsetEnd_.set (zOffsetEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "widthStart" && n.namespace_ ().empty ())
    {
      this->widthStart_.set (widthStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "widthEnd" && n.namespace_ ().empty ())
    {
      this->widthEnd_.set (widthEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lengthStart" && n.namespace_ ().empty ())
    {
      this->lengthStart_.set (lengthStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lengthEnd" && n.namespace_ ().empty ())
    {
      this->lengthEnd_.set (lengthEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radiusStart" && n.namespace_ ().empty ())
    {
      this->radiusStart_.set (radiusStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radiusEnd" && n.namespace_ ().empty ())
    {
      this->radiusEnd_.set (radiusEnd_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "distance",
      "");
  }

  if (!tStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tStart",
      "");
  }

  if (!tEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tEnd",
      "");
  }

  if (!heightStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "heightStart",
      "");
  }

  if (!heightEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "heightEnd",
      "");
  }

  if (!zOffsetStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffsetStart",
      "");
  }

  if (!zOffsetEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffsetEnd",
      "");
  }

  if (!widthStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "widthStart",
      "");
  }

  if (!widthEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "widthEnd",
      "");
  }
}

t_road_objects_object_repeat* t_road_objects_object_repeat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_repeat (*this, f, c);
}

t_road_objects_object_repeat& t_road_objects_object_repeat::
operator= (const t_road_objects_object_repeat& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->distance_ = x.distance_;
    this->tStart_ = x.tStart_;
    this->tEnd_ = x.tEnd_;
    this->heightStart_ = x.heightStart_;
    this->heightEnd_ = x.heightEnd_;
    this->zOffsetStart_ = x.zOffsetStart_;
    this->zOffsetEnd_ = x.zOffsetEnd_;
    this->widthStart_ = x.widthStart_;
    this->widthEnd_ = x.widthEnd_;
    this->lengthStart_ = x.lengthStart_;
    this->lengthEnd_ = x.lengthEnd_;
    this->radiusStart_ = x.radiusStart_;
    this->radiusEnd_ = x.radiusEnd_;
  }

  return *this;
}

t_road_objects_object_repeat::
~t_road_objects_object_repeat ()
{
}

// t_road_objects_object_outlines
//

t_road_objects_object_outlines::
t_road_objects_object_outlines ()
: ::xml_schema::type (),
  outline_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_objects_object_outlines::
t_road_objects_object_outlines (const t_road_objects_object_outlines& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  outline_ (x.outline_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects_object_outlines::
t_road_objects_object_outlines (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  outline_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // outline
    //
    if (n.name () == "outline" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outline_type > r (
        outline_traits::create (i, f, this));

      this->outline_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_objects_object_outlines* t_road_objects_object_outlines::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines (*this, f, c);
}

t_road_objects_object_outlines& t_road_objects_object_outlines::
operator= (const t_road_objects_object_outlines& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->outline_ = x.outline_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects_object_outlines::
~t_road_objects_object_outlines ()
{
}

// t_road_objects_object_outlines_outline
//

t_road_objects_object_outlines_outline::
t_road_objects_object_outlines_outline (const id_type& id,
                                        const fillType_type& fillType,
                                        const outer_type& outer,
                                        const closed_type& closed,
                                        const laneType_type& laneType)
: ::xml_schema::type (),
  cornerRoad_ (this),
  cornerLocal_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this),
  fillType_ (fillType, this),
  outer_ (outer, this),
  closed_ (closed, this),
  laneType_ (laneType, this)
{
}

t_road_objects_object_outlines_outline::
t_road_objects_object_outlines_outline (const t_road_objects_object_outlines_outline& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cornerRoad_ (x.cornerRoad_, f, this),
  cornerLocal_ (x.cornerLocal_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  fillType_ (x.fillType_, f, this),
  outer_ (x.outer_, f, this),
  closed_ (x.closed_, f, this),
  laneType_ (x.laneType_, f, this)
{
}

t_road_objects_object_outlines_outline::
t_road_objects_object_outlines_outline (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cornerRoad_ (this),
  cornerLocal_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  fillType_ (this),
  outer_ (this),
  closed_ (this),
  laneType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines_outline::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cornerRoad
    //
    if (n.name () == "cornerRoad" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cornerRoad_type > r (
        cornerRoad_traits::create (i, f, this));

      this->cornerRoad_.push_back (::std::move (r));
      continue;
    }

    // cornerLocal
    //
    if (n.name () == "cornerLocal" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cornerLocal_type > r (
        cornerLocal_traits::create (i, f, this));

      this->cornerLocal_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "fillType" && n.namespace_ ().empty ())
    {
      this->fillType_.set (fillType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outer" && n.namespace_ ().empty ())
    {
      this->outer_.set (outer_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "closed" && n.namespace_ ().empty ())
    {
      this->closed_.set (closed_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "laneType" && n.namespace_ ().empty ())
    {
      this->laneType_.set (laneType_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!fillType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "fillType",
      "");
  }

  if (!outer_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "outer",
      "");
  }

  if (!closed_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "closed",
      "");
  }

  if (!laneType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "laneType",
      "");
  }
}

t_road_objects_object_outlines_outline* t_road_objects_object_outlines_outline::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines_outline (*this, f, c);
}

t_road_objects_object_outlines_outline& t_road_objects_object_outlines_outline::
operator= (const t_road_objects_object_outlines_outline& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cornerRoad_ = x.cornerRoad_;
    this->cornerLocal_ = x.cornerLocal_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->fillType_ = x.fillType_;
    this->outer_ = x.outer_;
    this->closed_ = x.closed_;
    this->laneType_ = x.laneType_;
  }

  return *this;
}

t_road_objects_object_outlines_outline::
~t_road_objects_object_outlines_outline ()
{
}

// t_road_objects_object_outlines_outline_cornerRoad
//

t_road_objects_object_outlines_outline_cornerRoad::
t_road_objects_object_outlines_outline_cornerRoad (const s_type& s,
                                                   const t_type& t,
                                                   const dz_type& dz,
                                                   const height_type& height,
                                                   const id_type& id)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  t_ (t, this),
  dz_ (dz, this),
  height_ (height, this),
  id_ (id, this)
{
}

t_road_objects_object_outlines_outline_cornerRoad::
t_road_objects_object_outlines_outline_cornerRoad (const t_road_objects_object_outlines_outline_cornerRoad& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  dz_ (x.dz_, f, this),
  height_ (x.height_, f, this),
  id_ (x.id_, f, this)
{
}

t_road_objects_object_outlines_outline_cornerRoad::
t_road_objects_object_outlines_outline_cornerRoad (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  t_ (this),
  dz_ (this),
  height_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines_outline_cornerRoad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dz" && n.namespace_ ().empty ())
    {
      this->dz_.set (dz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!dz_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dz",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_objects_object_outlines_outline_cornerRoad* t_road_objects_object_outlines_outline_cornerRoad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines_outline_cornerRoad (*this, f, c);
}

t_road_objects_object_outlines_outline_cornerRoad& t_road_objects_object_outlines_outline_cornerRoad::
operator= (const t_road_objects_object_outlines_outline_cornerRoad& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->dz_ = x.dz_;
    this->height_ = x.height_;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_objects_object_outlines_outline_cornerRoad::
~t_road_objects_object_outlines_outline_cornerRoad ()
{
}

// t_road_objects_object_outlines_outline_cornerLocal
//

t_road_objects_object_outlines_outline_cornerLocal::
t_road_objects_object_outlines_outline_cornerLocal (const u_type& u,
                                                    const v_type& v,
                                                    const z_type& z,
                                                    const height_type& height,
                                                    const id_type& id)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  u_ (u, this),
  v_ (v, this),
  z_ (z, this),
  height_ (height, this),
  id_ (id, this)
{
}

t_road_objects_object_outlines_outline_cornerLocal::
t_road_objects_object_outlines_outline_cornerLocal (const t_road_objects_object_outlines_outline_cornerLocal& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  u_ (x.u_, f, this),
  v_ (x.v_, f, this),
  z_ (x.z_, f, this),
  height_ (x.height_, f, this),
  id_ (x.id_, f, this)
{
}

t_road_objects_object_outlines_outline_cornerLocal::
t_road_objects_object_outlines_outline_cornerLocal (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  u_ (this),
  v_ (this),
  z_ (this),
  height_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_outlines_outline_cornerLocal::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "u" && n.namespace_ ().empty ())
    {
      this->u_.set (u_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "v" && n.namespace_ ().empty ())
    {
      this->v_.set (v_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!u_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "u",
      "");
  }

  if (!v_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "v",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_objects_object_outlines_outline_cornerLocal* t_road_objects_object_outlines_outline_cornerLocal::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_outlines_outline_cornerLocal (*this, f, c);
}

t_road_objects_object_outlines_outline_cornerLocal& t_road_objects_object_outlines_outline_cornerLocal::
operator= (const t_road_objects_object_outlines_outline_cornerLocal& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->u_ = x.u_;
    this->v_ = x.v_;
    this->z_ = x.z_;
    this->height_ = x.height_;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_objects_object_outlines_outline_cornerLocal::
~t_road_objects_object_outlines_outline_cornerLocal ()
{
}

// t_road_objects_object_material
//

t_road_objects_object_material::
t_road_objects_object_material ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
}

t_road_objects_object_material::
t_road_objects_object_material (const t_road_objects_object_material& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  surface_ (x.surface_, f, this),
  friction_ (x.friction_, f, this),
  roughness_ (x.roughness_, f, this)
{
}

t_road_objects_object_material::
t_road_objects_object_material (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  surface_ (this),
  friction_ (this),
  roughness_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      this->surface_.set (surface_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "friction" && n.namespace_ ().empty ())
    {
      this->friction_.set (friction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roughness" && n.namespace_ ().empty ())
    {
      this->roughness_.set (roughness_traits::create (i, f, this));
      continue;
    }
  }
}

t_road_objects_object_material* t_road_objects_object_material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_material (*this, f, c);
}

t_road_objects_object_material& t_road_objects_object_material::
operator= (const t_road_objects_object_material& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->surface_ = x.surface_;
    this->friction_ = x.friction_;
    this->roughness_ = x.roughness_;
  }

  return *this;
}

t_road_objects_object_material::
~t_road_objects_object_material ()
{
}

// t_road_objects_object_laneValidity
//

t_road_objects_object_laneValidity::
t_road_objects_object_laneValidity (const fromLane_type& fromLane,
                                    const toLane_type& toLane)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  fromLane_ (fromLane, this),
  toLane_ (toLane, this)
{
}

t_road_objects_object_laneValidity::
t_road_objects_object_laneValidity (const t_road_objects_object_laneValidity& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  fromLane_ (x.fromLane_, f, this),
  toLane_ (x.toLane_, f, this)
{
}

t_road_objects_object_laneValidity::
t_road_objects_object_laneValidity (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  fromLane_ (this),
  toLane_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_laneValidity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "fromLane" && n.namespace_ ().empty ())
    {
      this->fromLane_.set (fromLane_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "toLane" && n.namespace_ ().empty ())
    {
      this->toLane_.set (toLane_traits::create (i, f, this));
      continue;
    }
  }

  if (!fromLane_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "fromLane",
      "");
  }

  if (!toLane_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "toLane",
      "");
  }
}

t_road_objects_object_laneValidity* t_road_objects_object_laneValidity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_laneValidity (*this, f, c);
}

t_road_objects_object_laneValidity& t_road_objects_object_laneValidity::
operator= (const t_road_objects_object_laneValidity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->fromLane_ = x.fromLane_;
    this->toLane_ = x.toLane_;
  }

  return *this;
}

t_road_objects_object_laneValidity::
~t_road_objects_object_laneValidity ()
{
}

// t_road_objects_object_parkingSpace
//

t_road_objects_object_parkingSpace::
t_road_objects_object_parkingSpace (const access_type& access)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  access_ (access, this),
  restrictions_ (this)
{
}

t_road_objects_object_parkingSpace::
t_road_objects_object_parkingSpace (const t_road_objects_object_parkingSpace& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  access_ (x.access_, f, this),
  restrictions_ (x.restrictions_, f, this)
{
}

t_road_objects_object_parkingSpace::
t_road_objects_object_parkingSpace (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  access_ (this),
  restrictions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_parkingSpace::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "access" && n.namespace_ ().empty ())
    {
      this->access_.set (access_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "restrictions" && n.namespace_ ().empty ())
    {
      this->restrictions_.set (restrictions_traits::create (i, f, this));
      continue;
    }
  }

  if (!access_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "access",
      "");
  }
}

t_road_objects_object_parkingSpace* t_road_objects_object_parkingSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_parkingSpace (*this, f, c);
}

t_road_objects_object_parkingSpace& t_road_objects_object_parkingSpace::
operator= (const t_road_objects_object_parkingSpace& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->access_ = x.access_;
    this->restrictions_ = x.restrictions_;
  }

  return *this;
}

t_road_objects_object_parkingSpace::
~t_road_objects_object_parkingSpace ()
{
}

// e_road_objects_object_parkingSpace_access
//

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_objects_object_parkingSpace_access_convert ();
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_objects_object_parkingSpace_access_convert ();
}

e_road_objects_object_parkingSpace_access::
e_road_objects_object_parkingSpace_access (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_objects_object_parkingSpace_access_convert ();
}

e_road_objects_object_parkingSpace_access* e_road_objects_object_parkingSpace_access::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_objects_object_parkingSpace_access (*this, f, c);
}

e_road_objects_object_parkingSpace_access::value e_road_objects_object_parkingSpace_access::
_xsd_e_road_objects_object_parkingSpace_access_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_objects_object_parkingSpace_access_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_objects_object_parkingSpace_access_indexes_,
                    _xsd_e_road_objects_object_parkingSpace_access_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_e_road_objects_object_parkingSpace_access_indexes_ + 8 || _xsd_e_road_objects_object_parkingSpace_access_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_objects_object_parkingSpace_access::
_xsd_e_road_objects_object_parkingSpace_access_literals_[8] =
{
  "all",
  "car",
  "women",
  "handicapped",
  "bus",
  "truck",
  "electric",
  "residents"
};

const e_road_objects_object_parkingSpace_access::value e_road_objects_object_parkingSpace_access::
_xsd_e_road_objects_object_parkingSpace_access_indexes_[8] =
{
  ::e_road_objects_object_parkingSpace_access::all,
  ::e_road_objects_object_parkingSpace_access::bus,
  ::e_road_objects_object_parkingSpace_access::car,
  ::e_road_objects_object_parkingSpace_access::electric,
  ::e_road_objects_object_parkingSpace_access::handicapped,
  ::e_road_objects_object_parkingSpace_access::residents,
  ::e_road_objects_object_parkingSpace_access::truck,
  ::e_road_objects_object_parkingSpace_access::women
};

// t_road_objects_object_markings
//

t_road_objects_object_markings::
t_road_objects_object_markings ()
: ::xml_schema::type (),
  marking_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_objects_object_markings::
t_road_objects_object_markings (const t_road_objects_object_markings& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  marking_ (x.marking_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects_object_markings::
t_road_objects_object_markings (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  marking_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects_object_markings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // marking
    //
    if (n.name () == "marking" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< marking_type > r (
        marking_traits::create (i, f, this));

      this->marking_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_objects_object_markings* t_road_objects_object_markings::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_markings (*this, f, c);
}

t_road_objects_object_markings& t_road_objects_object_markings::
operator= (const t_road_objects_object_markings& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->marking_ = x.marking_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects_object_markings::
~t_road_objects_object_markings ()
{
}

// t_road_objects_object_markings_marking
//

t_road_objects_object_markings_marking::
t_road_objects_object_markings_marking (const side_type& side,
                                        const weight_type& weight,
                                        const color_type& color,
                                        const spaceLength_type& spaceLength,
                                        const lineLength_type& lineLength,
                                        const startOffset_type& startOffset,
                                        const stopOffset_type& stopOffset)
: ::xml_schema::type (),
  cornerReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  side_ (side, this),
  weight_ (weight, this),
  width_ (this),
  color_ (color, this),
  zOffset_ (this),
  spaceLength_ (spaceLength, this),
  lineLength_ (lineLength, this),
  startOffset_ (startOffset, this),
  stopOffset_ (stopOffset, this)
{
}

t_road_objects_object_markings_marking::
t_road_objects_object_markings_marking (const t_road_objects_object_markings_marking& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cornerReference_ (x.cornerReference_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  side_ (x.side_, f, this),
  weight_ (x.weight_, f, this),
  width_ (x.width_, f, this),
  color_ (x.color_, f, this),
  zOffset_ (x.zOffset_, f, this),
  spaceLength_ (x.spaceLength_, f, this),
  lineLength_ (x.lineLength_, f, this),
  startOffset_ (x.startOffset_, f, this),
  stopOffset_ (x.stopOffset_, f, this)
{
}

t_road_objects_object_markings_marking::
t_road_objects_object_markings_marking (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cornerReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  side_ (this),
  weight_ (this),
  width_ (this),
  color_ (this),
  zOffset_ (this),
  spaceLength_ (this),
  lineLength_ (this),
  startOffset_ (this),
  stopOffset_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_markings_marking::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cornerReference
    //
    if (n.name () == "cornerReference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cornerReference_type > r (
        cornerReference_traits::create (i, f, this));

      this->cornerReference_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      this->weight_.set (weight_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      this->color_.set (color_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "spaceLength" && n.namespace_ ().empty ())
    {
      this->spaceLength_.set (spaceLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lineLength" && n.namespace_ ().empty ())
    {
      this->lineLength_.set (lineLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startOffset" && n.namespace_ ().empty ())
    {
      this->startOffset_.set (startOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "stopOffset" && n.namespace_ ().empty ())
    {
      this->stopOffset_.set (stopOffset_traits::create (i, f, this));
      continue;
    }
  }

  if (!side_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "side",
      "");
  }

  if (!weight_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "weight",
      "");
  }

  if (!color_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "color",
      "");
  }

  if (!spaceLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "spaceLength",
      "");
  }

  if (!lineLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "lineLength",
      "");
  }

  if (!startOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "startOffset",
      "");
  }

  if (!stopOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "stopOffset",
      "");
  }
}

t_road_objects_object_markings_marking* t_road_objects_object_markings_marking::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_markings_marking (*this, f, c);
}

t_road_objects_object_markings_marking& t_road_objects_object_markings_marking::
operator= (const t_road_objects_object_markings_marking& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cornerReference_ = x.cornerReference_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->side_ = x.side_;
    this->weight_ = x.weight_;
    this->width_ = x.width_;
    this->color_ = x.color_;
    this->zOffset_ = x.zOffset_;
    this->spaceLength_ = x.spaceLength_;
    this->lineLength_ = x.lineLength_;
    this->startOffset_ = x.startOffset_;
    this->stopOffset_ = x.stopOffset_;
  }

  return *this;
}

t_road_objects_object_markings_marking::
~t_road_objects_object_markings_marking ()
{
}

// t_road_objects_object_markings_marking_cornerReference
//

t_road_objects_object_markings_marking_cornerReference::
t_road_objects_object_markings_marking_cornerReference (const id_type& id)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this)
{
}

t_road_objects_object_markings_marking_cornerReference::
t_road_objects_object_markings_marking_cornerReference (const t_road_objects_object_markings_marking_cornerReference& x,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this)
{
}

t_road_objects_object_markings_marking_cornerReference::
t_road_objects_object_markings_marking_cornerReference (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_markings_marking_cornerReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_objects_object_markings_marking_cornerReference* t_road_objects_object_markings_marking_cornerReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_markings_marking_cornerReference (*this, f, c);
}

t_road_objects_object_markings_marking_cornerReference& t_road_objects_object_markings_marking_cornerReference::
operator= (const t_road_objects_object_markings_marking_cornerReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_objects_object_markings_marking_cornerReference::
~t_road_objects_object_markings_marking_cornerReference ()
{
}

// t_road_objects_object_borders
//

t_road_objects_object_borders::
t_road_objects_object_borders ()
: ::xml_schema::type (),
  border_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_objects_object_borders::
t_road_objects_object_borders (const t_road_objects_object_borders& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  border_ (x.border_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_objects_object_borders::
t_road_objects_object_borders (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  border_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_objects_object_borders::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // border
    //
    if (n.name () == "border" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< border_type > r (
        border_traits::create (i, f, this));

      this->border_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_objects_object_borders* t_road_objects_object_borders::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_borders (*this, f, c);
}

t_road_objects_object_borders& t_road_objects_object_borders::
operator= (const t_road_objects_object_borders& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->border_ = x.border_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_objects_object_borders::
~t_road_objects_object_borders ()
{
}

// t_road_objects_object_borders_border
//

t_road_objects_object_borders_border::
t_road_objects_object_borders_border (const width_type& width,
                                      const type_type& type,
                                      const outlineId_type& outlineId)
: ::xml_schema::type (),
  cornerReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  width_ (width, this),
  type_ (type, this),
  outlineId_ (outlineId, this),
  useCompleteOutline_ (this)
{
}

t_road_objects_object_borders_border::
t_road_objects_object_borders_border (const t_road_objects_object_borders_border& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cornerReference_ (x.cornerReference_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  width_ (x.width_, f, this),
  type_ (x.type_, f, this),
  outlineId_ (x.outlineId_, f, this),
  useCompleteOutline_ (x.useCompleteOutline_, f, this)
{
}

t_road_objects_object_borders_border::
t_road_objects_object_borders_border (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cornerReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  width_ (this),
  type_ (this),
  outlineId_ (this),
  useCompleteOutline_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_object_borders_border::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cornerReference
    //
    if (n.name () == "cornerReference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cornerReference_type > r (
        cornerReference_traits::create (i, f, this));

      this->cornerReference_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outlineId" && n.namespace_ ().empty ())
    {
      this->outlineId_.set (outlineId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "useCompleteOutline" && n.namespace_ ().empty ())
    {
      this->useCompleteOutline_.set (useCompleteOutline_traits::create (i, f, this));
      continue;
    }
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!outlineId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "outlineId",
      "");
  }
}

t_road_objects_object_borders_border* t_road_objects_object_borders_border::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_object_borders_border (*this, f, c);
}

t_road_objects_object_borders_border& t_road_objects_object_borders_border::
operator= (const t_road_objects_object_borders_border& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cornerReference_ = x.cornerReference_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->width_ = x.width_;
    this->type_ = x.type_;
    this->outlineId_ = x.outlineId_;
    this->useCompleteOutline_ = x.useCompleteOutline_;
  }

  return *this;
}

t_road_objects_object_borders_border::
~t_road_objects_object_borders_border ()
{
}

// t_road_objects_objectReference
//

t_road_objects_objectReference::
t_road_objects_objectReference (const s_type& s,
                                const t_type& t,
                                const id_type& id,
                                const zOffset_type& zOffset,
                                const validLength_type& validLength,
                                const orientation_type& orientation)
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  t_ (t, this),
  id_ (id, this),
  zOffset_ (zOffset, this),
  validLength_ (validLength, this),
  orientation_ (orientation, this)
{
}

t_road_objects_objectReference::
t_road_objects_objectReference (const t_road_objects_objectReference& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  id_ (x.id_, f, this),
  zOffset_ (x.zOffset_, f, this),
  validLength_ (x.validLength_, f, this),
  orientation_ (x.orientation_, f, this)
{
}

t_road_objects_objectReference::
t_road_objects_objectReference (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  zOffset_ (this),
  validLength_ (this),
  orientation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_objectReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "validLength" && n.namespace_ ().empty ())
    {
      this->validLength_.set (validLength_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!zOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffset",
      "");
  }

  if (!validLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "validLength",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "orientation",
      "");
  }
}

t_road_objects_objectReference* t_road_objects_objectReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_objectReference (*this, f, c);
}

t_road_objects_objectReference& t_road_objects_objectReference::
operator= (const t_road_objects_objectReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->id_ = x.id_;
    this->zOffset_ = x.zOffset_;
    this->validLength_ = x.validLength_;
    this->orientation_ = x.orientation_;
  }

  return *this;
}

t_road_objects_objectReference::
~t_road_objects_objectReference ()
{
}

// t_road_objects_tunnel
//

t_road_objects_tunnel::
t_road_objects_tunnel (const s_type& s,
                       const length_type& length,
                       const id_type& id,
                       const type_type& type)
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  length_ (length, this),
  name_ (this),
  id_ (id, this),
  type_ (type, this),
  lighting_ (this),
  daylight_ (this)
{
}

t_road_objects_tunnel::
t_road_objects_tunnel (const t_road_objects_tunnel& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  lighting_ (x.lighting_, f, this),
  daylight_ (x.daylight_, f, this)
{
}

t_road_objects_tunnel::
t_road_objects_tunnel (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this),
  lighting_ (this),
  daylight_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_tunnel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lighting" && n.namespace_ ().empty ())
    {
      this->lighting_.set (lighting_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "daylight" && n.namespace_ ().empty ())
    {
      this->daylight_.set (daylight_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_objects_tunnel* t_road_objects_tunnel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_tunnel (*this, f, c);
}

t_road_objects_tunnel& t_road_objects_tunnel::
operator= (const t_road_objects_tunnel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->lighting_ = x.lighting_;
    this->daylight_ = x.daylight_;
  }

  return *this;
}

t_road_objects_tunnel::
~t_road_objects_tunnel ()
{
}

// t_road_objects_bridge
//

t_road_objects_bridge::
t_road_objects_bridge (const s_type& s,
                       const length_type& length,
                       const id_type& id,
                       const type_type& type)
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  length_ (length, this),
  name_ (this),
  id_ (id, this),
  type_ (type, this)
{
}

t_road_objects_bridge::
t_road_objects_bridge (const t_road_objects_bridge& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  length_ (x.length_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

t_road_objects_bridge::
t_road_objects_bridge (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  length_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_objects_bridge::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_road_objects_bridge* t_road_objects_bridge::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_objects_bridge (*this, f, c);
}

t_road_objects_bridge& t_road_objects_bridge::
operator= (const t_road_objects_bridge& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->length_ = x.length_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

t_road_objects_bridge::
~t_road_objects_bridge ()
{
}

// t_road_signals
//

t_road_signals::
t_road_signals ()
: ::xml_schema::type (),
  signal_ (this),
  signalReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_signals::
t_road_signals (const t_road_signals& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  signal_ (x.signal_, f, this),
  signalReference_ (x.signalReference_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_signals::
t_road_signals (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  signal_ (this),
  signalReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_signals::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // signal
    //
    if (n.name () == "signal" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< signal_type > r (
        signal_traits::create (i, f, this));

      this->signal_.push_back (::std::move (r));
      continue;
    }

    // signalReference
    //
    if (n.name () == "signalReference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< signalReference_type > r (
        signalReference_traits::create (i, f, this));

      this->signalReference_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_signals* t_road_signals::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_signals (*this, f, c);
}

t_road_signals& t_road_signals::
operator= (const t_road_signals& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->signal_ = x.signal_;
    this->signalReference_ = x.signalReference_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_signals::
~t_road_signals ()
{
}

// t_road_signals_signal
//

t_road_signals_signal::
t_road_signals_signal (const s_type& s,
                       const t_type& t,
                       const id_type& id,
                       const dynamic_type& dynamic,
                       const orientation_type& orientation,
                       const zOffset_type& zOffset,
                       const type_type& type,
                       const subtype_type& subtype,
                       const height_type& height,
                       const width_type& width)
: ::xml_schema::type (),
  validity_ (this),
  dependency_ (this),
  reference_ (this),
  positionRoad_ (this),
  positionInertial_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  t_ (t, this),
  id_ (id, this),
  name_ (this),
  dynamic_ (dynamic, this),
  orientation_ (orientation, this),
  zOffset_ (zOffset, this),
  country_ (this),
  countryRevision_ (this),
  type_ (type, this),
  subtype_ (subtype, this),
  value_ (this),
  unit_ (this),
  height_ (height, this),
  width_ (width, this),
  text_ (this),
  hOffset_ (this),
  pitch_ (this),
  roll_ (this)
{
}

t_road_signals_signal::
t_road_signals_signal (const t_road_signals_signal& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  dependency_ (x.dependency_, f, this),
  reference_ (x.reference_, f, this),
  positionRoad_ (x.positionRoad_, f, this),
  positionInertial_ (x.positionInertial_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this),
  dynamic_ (x.dynamic_, f, this),
  orientation_ (x.orientation_, f, this),
  zOffset_ (x.zOffset_, f, this),
  country_ (x.country_, f, this),
  countryRevision_ (x.countryRevision_, f, this),
  type_ (x.type_, f, this),
  subtype_ (x.subtype_, f, this),
  value_ (x.value_, f, this),
  unit_ (x.unit_, f, this),
  height_ (x.height_, f, this),
  width_ (x.width_, f, this),
  text_ (x.text_, f, this),
  hOffset_ (x.hOffset_, f, this),
  pitch_ (x.pitch_, f, this),
  roll_ (x.roll_, f, this)
{
}

t_road_signals_signal::
t_road_signals_signal (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  dependency_ (this),
  reference_ (this),
  positionRoad_ (this),
  positionInertial_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  name_ (this),
  dynamic_ (this),
  orientation_ (this),
  zOffset_ (this),
  country_ (this),
  countryRevision_ (this),
  type_ (this),
  subtype_ (this),
  value_ (this),
  unit_ (this),
  height_ (this),
  width_ (this),
  text_ (this),
  hOffset_ (this),
  pitch_ (this),
  roll_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_signals_signal::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (::std::move (r));
      continue;
    }

    // dependency
    //
    if (n.name () == "dependency" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dependency_type > r (
        dependency_traits::create (i, f, this));

      this->dependency_.push_back (::std::move (r));
      continue;
    }

    // reference
    //
    if (n.name () == "reference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< reference_type > r (
        reference_traits::create (i, f, this));

      this->reference_.push_back (::std::move (r));
      continue;
    }

    // positionRoad
    //
    if (n.name () == "positionRoad" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< positionRoad_type > r (
        positionRoad_traits::create (i, f, this));

      if (!this->positionRoad_)
      {
        this->positionRoad_.set (::std::move (r));
        continue;
      }
    }

    // positionInertial
    //
    if (n.name () == "positionInertial" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< positionInertial_type > r (
        positionInertial_traits::create (i, f, this));

      if (!this->positionInertial_)
      {
        this->positionInertial_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dynamic" && n.namespace_ ().empty ())
    {
      this->dynamic_.set (dynamic_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "country" && n.namespace_ ().empty ())
    {
      this->country_.set (country_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "countryRevision" && n.namespace_ ().empty ())
    {
      this->countryRevision_.set (countryRevision_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "subtype" && n.namespace_ ().empty ())
    {
      this->subtype_.set (subtype_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "unit" && n.namespace_ ().empty ())
    {
      this->unit_.set (unit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      this->height_.set (height_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      this->width_.set (width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "text" && n.namespace_ ().empty ())
    {
      this->text_.set (text_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hOffset" && n.namespace_ ().empty ())
    {
      this->hOffset_.set (hOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      this->pitch_.set (pitch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roll" && n.namespace_ ().empty ())
    {
      this->roll_.set (roll_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!dynamic_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dynamic",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "orientation",
      "");
  }

  if (!zOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffset",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!subtype_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "subtype",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "height",
      "");
  }

  if (!width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "width",
      "");
  }
}

t_road_signals_signal* t_road_signals_signal::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_signals_signal (*this, f, c);
}

t_road_signals_signal& t_road_signals_signal::
operator= (const t_road_signals_signal& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->dependency_ = x.dependency_;
    this->reference_ = x.reference_;
    this->positionRoad_ = x.positionRoad_;
    this->positionInertial_ = x.positionInertial_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->dynamic_ = x.dynamic_;
    this->orientation_ = x.orientation_;
    this->zOffset_ = x.zOffset_;
    this->country_ = x.country_;
    this->countryRevision_ = x.countryRevision_;
    this->type_ = x.type_;
    this->subtype_ = x.subtype_;
    this->value_ = x.value_;
    this->unit_ = x.unit_;
    this->height_ = x.height_;
    this->width_ = x.width_;
    this->text_ = x.text_;
    this->hOffset_ = x.hOffset_;
    this->pitch_ = x.pitch_;
    this->roll_ = x.roll_;
  }

  return *this;
}

t_road_signals_signal::
~t_road_signals_signal ()
{
}

// t_road_signals_signal_dependency
//

t_road_signals_signal_dependency::
t_road_signals_signal_dependency (const id_type& id)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this),
  type_ (this)
{
}

t_road_signals_signal_dependency::
t_road_signals_signal_dependency (const t_road_signals_signal_dependency& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

t_road_signals_signal_dependency::
t_road_signals_signal_dependency (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_signals_signal_dependency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_signals_signal_dependency* t_road_signals_signal_dependency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_signals_signal_dependency (*this, f, c);
}

t_road_signals_signal_dependency& t_road_signals_signal_dependency::
operator= (const t_road_signals_signal_dependency& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

t_road_signals_signal_dependency::
~t_road_signals_signal_dependency ()
{
}

// t_road_signals_signal_reference
//

t_road_signals_signal_reference::
t_road_signals_signal_reference (const elementType_type& elementType,
                                 const elementId_type& elementId)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  elementType_ (elementType, this),
  elementId_ (elementId, this),
  type_ (this)
{
}

t_road_signals_signal_reference::
t_road_signals_signal_reference (const t_road_signals_signal_reference& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  elementType_ (x.elementType_, f, this),
  elementId_ (x.elementId_, f, this),
  type_ (x.type_, f, this)
{
}

t_road_signals_signal_reference::
t_road_signals_signal_reference (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  elementType_ (this),
  elementId_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_signals_signal_reference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!elementType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementType",
      "");
  }

  if (!elementId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementId",
      "");
  }
}

t_road_signals_signal_reference* t_road_signals_signal_reference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_signals_signal_reference (*this, f, c);
}

t_road_signals_signal_reference& t_road_signals_signal_reference::
operator= (const t_road_signals_signal_reference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->elementType_ = x.elementType_;
    this->elementId_ = x.elementId_;
    this->type_ = x.type_;
  }

  return *this;
}

t_road_signals_signal_reference::
~t_road_signals_signal_reference ()
{
}

// e_road_signals_signal_reference_elementType
//

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_signals_signal_reference_elementType_convert ();
}

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_signals_signal_reference_elementType_convert ();
}

e_road_signals_signal_reference_elementType::
e_road_signals_signal_reference_elementType (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_signals_signal_reference_elementType_convert ();
}

e_road_signals_signal_reference_elementType* e_road_signals_signal_reference_elementType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_signals_signal_reference_elementType (*this, f, c);
}

e_road_signals_signal_reference_elementType::value e_road_signals_signal_reference_elementType::
_xsd_e_road_signals_signal_reference_elementType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_signals_signal_reference_elementType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_signals_signal_reference_elementType_indexes_,
                    _xsd_e_road_signals_signal_reference_elementType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_road_signals_signal_reference_elementType_indexes_ + 2 || _xsd_e_road_signals_signal_reference_elementType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_signals_signal_reference_elementType::
_xsd_e_road_signals_signal_reference_elementType_literals_[2] =
{
  "object",
  "signal"
};

const e_road_signals_signal_reference_elementType::value e_road_signals_signal_reference_elementType::
_xsd_e_road_signals_signal_reference_elementType_indexes_[2] =
{
  ::e_road_signals_signal_reference_elementType::object,
  ::e_road_signals_signal_reference_elementType::signal
};

// t_road_signals_signal_positionRoad
//

t_road_signals_signal_positionRoad::
t_road_signals_signal_positionRoad (const roadId_type& roadId,
                                    const s_type& s,
                                    const t_type& t,
                                    const zOffset_type& zOffset,
                                    const hOffset_type& hOffset)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  roadId_ (roadId, this),
  s_ (s, this),
  t_ (t, this),
  zOffset_ (zOffset, this),
  hOffset_ (hOffset, this),
  pitch_ (this),
  roll_ (this)
{
}

t_road_signals_signal_positionRoad::
t_road_signals_signal_positionRoad (const t_road_signals_signal_positionRoad& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  roadId_ (x.roadId_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  zOffset_ (x.zOffset_, f, this),
  hOffset_ (x.hOffset_, f, this),
  pitch_ (x.pitch_, f, this),
  roll_ (x.roll_, f, this)
{
}

t_road_signals_signal_positionRoad::
t_road_signals_signal_positionRoad (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  roadId_ (this),
  s_ (this),
  t_ (this),
  zOffset_ (this),
  hOffset_ (this),
  pitch_ (this),
  roll_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_signals_signal_positionRoad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "roadId" && n.namespace_ ().empty ())
    {
      this->roadId_.set (roadId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hOffset" && n.namespace_ ().empty ())
    {
      this->hOffset_.set (hOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      this->pitch_.set (pitch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roll" && n.namespace_ ().empty ())
    {
      this->roll_.set (roll_traits::create (i, f, this));
      continue;
    }
  }

  if (!roadId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "roadId",
      "");
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!zOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zOffset",
      "");
  }

  if (!hOffset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hOffset",
      "");
  }
}

t_road_signals_signal_positionRoad* t_road_signals_signal_positionRoad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_signals_signal_positionRoad (*this, f, c);
}

t_road_signals_signal_positionRoad& t_road_signals_signal_positionRoad::
operator= (const t_road_signals_signal_positionRoad& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->roadId_ = x.roadId_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->zOffset_ = x.zOffset_;
    this->hOffset_ = x.hOffset_;
    this->pitch_ = x.pitch_;
    this->roll_ = x.roll_;
  }

  return *this;
}

t_road_signals_signal_positionRoad::
~t_road_signals_signal_positionRoad ()
{
}

// t_road_signals_signal_positionInertial
//

t_road_signals_signal_positionInertial::
t_road_signals_signal_positionInertial (const x_type& x,
                                        const y_type& y,
                                        const z_type& z,
                                        const hdg_type& hdg)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  hdg_ (hdg, this),
  pitch_ (this),
  roll_ (this)
{
}

t_road_signals_signal_positionInertial::
t_road_signals_signal_positionInertial (const t_road_signals_signal_positionInertial& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  hdg_ (x.hdg_, f, this),
  pitch_ (x.pitch_, f, this),
  roll_ (x.roll_, f, this)
{
}

t_road_signals_signal_positionInertial::
t_road_signals_signal_positionInertial (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  x_ (this),
  y_ (this),
  z_ (this),
  hdg_ (this),
  pitch_ (this),
  roll_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_signals_signal_positionInertial::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hdg" && n.namespace_ ().empty ())
    {
      this->hdg_.set (hdg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      this->pitch_.set (pitch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "roll" && n.namespace_ ().empty ())
    {
      this->roll_.set (roll_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!hdg_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hdg",
      "");
  }
}

t_road_signals_signal_positionInertial* t_road_signals_signal_positionInertial::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_signals_signal_positionInertial (*this, f, c);
}

t_road_signals_signal_positionInertial& t_road_signals_signal_positionInertial::
operator= (const t_road_signals_signal_positionInertial& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->hdg_ = x.hdg_;
    this->pitch_ = x.pitch_;
    this->roll_ = x.roll_;
  }

  return *this;
}

t_road_signals_signal_positionInertial::
~t_road_signals_signal_positionInertial ()
{
}

// t_road_signals_signalReference
//

t_road_signals_signalReference::
t_road_signals_signalReference (const s_type& s,
                                const t_type& t,
                                const id_type& id,
                                const orientation_type& orientation)
: ::xml_schema::type (),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (s, this),
  t_ (t, this),
  id_ (id, this),
  orientation_ (orientation, this)
{
}

t_road_signals_signalReference::
t_road_signals_signalReference (const t_road_signals_signalReference& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  validity_ (x.validity_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  s_ (x.s_, f, this),
  t_ (x.t_, f, this),
  id_ (x.id_, f, this),
  orientation_ (x.orientation_, f, this)
{
}

t_road_signals_signalReference::
t_road_signals_signalReference (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  validity_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  s_ (this),
  t_ (this),
  id_ (this),
  orientation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_signals_signalReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // validity
    //
    if (n.name () == "validity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< validity_type > r (
        validity_traits::create (i, f, this));

      this->validity_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "orientation",
      "");
  }
}

t_road_signals_signalReference* t_road_signals_signalReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_signals_signalReference (*this, f, c);
}

t_road_signals_signalReference& t_road_signals_signalReference::
operator= (const t_road_signals_signalReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->validity_ = x.validity_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->s_ = x.s_;
    this->t_ = x.t_;
    this->id_ = x.id_;
    this->orientation_ = x.orientation_;
  }

  return *this;
}

t_road_signals_signalReference::
~t_road_signals_signalReference ()
{
}

// t_road_surface
//

t_road_surface::
t_road_surface ()
: ::xml_schema::type (),
  CRG_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_surface::
t_road_surface (const t_road_surface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  CRG_ (x.CRG_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_surface::
t_road_surface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  CRG_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_surface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CRG
    //
    if (n.name () == "CRG" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< CRG_type > r (
        CRG_traits::create (i, f, this));

      this->CRG_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_surface* t_road_surface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_surface (*this, f, c);
}

t_road_surface& t_road_surface::
operator= (const t_road_surface& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->CRG_ = x.CRG_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_surface::
~t_road_surface ()
{
}

// t_road_surface_CRG
//

t_road_surface_CRG::
t_road_surface_CRG (const file_type& file,
                    const sStart_type& sStart,
                    const sEnd_type& sEnd,
                    const orientation_type& orientation,
                    const mode_type& mode)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  file_ (file, this),
  sStart_ (sStart, this),
  sEnd_ (sEnd, this),
  orientation_ (orientation, this),
  mode_ (mode, this),
  purpose_ (this),
  sOffset_ (this),
  tOffset_ (this),
  zOffset_ (this),
  zScale_ (this),
  hOffset_ (this)
{
}

t_road_surface_CRG::
t_road_surface_CRG (const t_road_surface_CRG& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  file_ (x.file_, f, this),
  sStart_ (x.sStart_, f, this),
  sEnd_ (x.sEnd_, f, this),
  orientation_ (x.orientation_, f, this),
  mode_ (x.mode_, f, this),
  purpose_ (x.purpose_, f, this),
  sOffset_ (x.sOffset_, f, this),
  tOffset_ (x.tOffset_, f, this),
  zOffset_ (x.zOffset_, f, this),
  zScale_ (x.zScale_, f, this),
  hOffset_ (x.hOffset_, f, this)
{
}

t_road_surface_CRG::
t_road_surface_CRG (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  file_ (this),
  sStart_ (this),
  sEnd_ (this),
  orientation_ (this),
  mode_ (this),
  purpose_ (this),
  sOffset_ (this),
  tOffset_ (this),
  zOffset_ (this),
  zScale_ (this),
  hOffset_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_surface_CRG::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      this->file_.set (file_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sStart" && n.namespace_ ().empty ())
    {
      this->sStart_.set (sStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sEnd" && n.namespace_ ().empty ())
    {
      this->sEnd_.set (sEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      this->orientation_.set (orientation_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mode" && n.namespace_ ().empty ())
    {
      this->mode_.set (mode_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "purpose" && n.namespace_ ().empty ())
    {
      this->purpose_.set (purpose_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sOffset" && n.namespace_ ().empty ())
    {
      this->sOffset_.set (sOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tOffset" && n.namespace_ ().empty ())
    {
      this->tOffset_.set (tOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zScale" && n.namespace_ ().empty ())
    {
      this->zScale_.set (zScale_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hOffset" && n.namespace_ ().empty ())
    {
      this->hOffset_.set (hOffset_traits::create (i, f, this));
      continue;
    }
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }

  if (!sStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sStart",
      "");
  }

  if (!sEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sEnd",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "orientation",
      "");
  }

  if (!mode_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mode",
      "");
  }
}

t_road_surface_CRG* t_road_surface_CRG::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_surface_CRG (*this, f, c);
}

t_road_surface_CRG& t_road_surface_CRG::
operator= (const t_road_surface_CRG& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->file_ = x.file_;
    this->sStart_ = x.sStart_;
    this->sEnd_ = x.sEnd_;
    this->orientation_ = x.orientation_;
    this->mode_ = x.mode_;
    this->purpose_ = x.purpose_;
    this->sOffset_ = x.sOffset_;
    this->tOffset_ = x.tOffset_;
    this->zOffset_ = x.zOffset_;
    this->zScale_ = x.zScale_;
    this->hOffset_ = x.hOffset_;
  }

  return *this;
}

t_road_surface_CRG::
~t_road_surface_CRG ()
{
}

// e_road_surface_CRG_purpose
//

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_surface_CRG_purpose_convert ();
}

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_surface_CRG_purpose_convert ();
}

e_road_surface_CRG_purpose::
e_road_surface_CRG_purpose (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_surface_CRG_purpose_convert ();
}

e_road_surface_CRG_purpose* e_road_surface_CRG_purpose::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_surface_CRG_purpose (*this, f, c);
}

e_road_surface_CRG_purpose::value e_road_surface_CRG_purpose::
_xsd_e_road_surface_CRG_purpose_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_surface_CRG_purpose_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_surface_CRG_purpose_indexes_,
                    _xsd_e_road_surface_CRG_purpose_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_road_surface_CRG_purpose_indexes_ + 2 || _xsd_e_road_surface_CRG_purpose_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_surface_CRG_purpose::
_xsd_e_road_surface_CRG_purpose_literals_[2] =
{
  "elevation",
  "friction"
};

const e_road_surface_CRG_purpose::value e_road_surface_CRG_purpose::
_xsd_e_road_surface_CRG_purpose_indexes_[2] =
{
  ::e_road_surface_CRG_purpose::elevation,
  ::e_road_surface_CRG_purpose::friction
};

// e_road_surface_CRG_mode
//

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_surface_CRG_mode_convert ();
}

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_surface_CRG_mode_convert ();
}

e_road_surface_CRG_mode::
e_road_surface_CRG_mode (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_surface_CRG_mode_convert ();
}

e_road_surface_CRG_mode* e_road_surface_CRG_mode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_surface_CRG_mode (*this, f, c);
}

e_road_surface_CRG_mode::value e_road_surface_CRG_mode::
_xsd_e_road_surface_CRG_mode_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_surface_CRG_mode_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_surface_CRG_mode_indexes_,
                    _xsd_e_road_surface_CRG_mode_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_road_surface_CRG_mode_indexes_ + 4 || _xsd_e_road_surface_CRG_mode_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_surface_CRG_mode::
_xsd_e_road_surface_CRG_mode_literals_[4] =
{
  "attached",
  "attached0",
  "genuine",
  "global"
};

const e_road_surface_CRG_mode::value e_road_surface_CRG_mode::
_xsd_e_road_surface_CRG_mode_indexes_[4] =
{
  ::e_road_surface_CRG_mode::attached,
  ::e_road_surface_CRG_mode::attached0,
  ::e_road_surface_CRG_mode::genuine,
  ::e_road_surface_CRG_mode::global
};

// t_road_railroad
//

t_road_railroad::
t_road_railroad ()
: ::xml_schema::type (),
  switch__ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_road_railroad::
t_road_railroad (const t_road_railroad& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  switch__ (x.switch__, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_road_railroad::
t_road_railroad (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  switch__ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_road_railroad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // switch
    //
    if (n.name () == "switch" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< switch_type > r (
        switch_traits::create (i, f, this));

      this->switch__.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_road_railroad* t_road_railroad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_railroad (*this, f, c);
}

t_road_railroad& t_road_railroad::
operator= (const t_road_railroad& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->switch__ = x.switch__;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_road_railroad::
~t_road_railroad ()
{
}

// t_road_railroad_switch
//

t_road_railroad_switch::
t_road_railroad_switch (const mainTrack_type& mainTrack,
                        const sideTrack_type& sideTrack,
                        const name_type& name,
                        const id_type& id,
                        const position_type& position)
: ::xml_schema::type (),
  mainTrack_ (mainTrack, this),
  sideTrack_ (sideTrack, this),
  partner_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (name, this),
  id_ (id, this),
  position_ (position, this)
{
}

t_road_railroad_switch::
t_road_railroad_switch (::std::unique_ptr< mainTrack_type > mainTrack,
                        ::std::unique_ptr< sideTrack_type > sideTrack,
                        const name_type& name,
                        const id_type& id,
                        const position_type& position)
: ::xml_schema::type (),
  mainTrack_ (std::move (mainTrack), this),
  sideTrack_ (std::move (sideTrack), this),
  partner_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (name, this),
  id_ (id, this),
  position_ (position, this)
{
}

t_road_railroad_switch::
t_road_railroad_switch (const t_road_railroad_switch& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  mainTrack_ (x.mainTrack_, f, this),
  sideTrack_ (x.sideTrack_, f, this),
  partner_ (x.partner_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  position_ (x.position_, f, this)
{
}

t_road_railroad_switch::
t_road_railroad_switch (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  mainTrack_ (this),
  sideTrack_ (this),
  partner_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (this),
  position_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_railroad_switch::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // mainTrack
    //
    if (n.name () == "mainTrack" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mainTrack_type > r (
        mainTrack_traits::create (i, f, this));

      if (!mainTrack_.present ())
      {
        this->mainTrack_.set (::std::move (r));
        continue;
      }
    }

    // sideTrack
    //
    if (n.name () == "sideTrack" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sideTrack_type > r (
        sideTrack_traits::create (i, f, this));

      if (!sideTrack_.present ())
      {
        this->sideTrack_.set (::std::move (r));
        continue;
      }
    }

    // partner
    //
    if (n.name () == "partner" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< partner_type > r (
        partner_traits::create (i, f, this));

      if (!this->partner_)
      {
        this->partner_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!mainTrack_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mainTrack",
      "");
  }

  if (!sideTrack_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sideTrack",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      this->position_.set (position_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "position",
      "");
  }
}

t_road_railroad_switch* t_road_railroad_switch::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_railroad_switch (*this, f, c);
}

t_road_railroad_switch& t_road_railroad_switch::
operator= (const t_road_railroad_switch& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->mainTrack_ = x.mainTrack_;
    this->sideTrack_ = x.sideTrack_;
    this->partner_ = x.partner_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->position_ = x.position_;
  }

  return *this;
}

t_road_railroad_switch::
~t_road_railroad_switch ()
{
}

// e_road_railroad_switch_position
//

e_road_railroad_switch_position::
e_road_railroad_switch_position (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_road_railroad_switch_position_convert ();
}

e_road_railroad_switch_position::
e_road_railroad_switch_position (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_road_railroad_switch_position_convert ();
}

e_road_railroad_switch_position::
e_road_railroad_switch_position (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_road_railroad_switch_position_convert ();
}

e_road_railroad_switch_position* e_road_railroad_switch_position::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_road_railroad_switch_position (*this, f, c);
}

e_road_railroad_switch_position::value e_road_railroad_switch_position::
_xsd_e_road_railroad_switch_position_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_road_railroad_switch_position_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_road_railroad_switch_position_indexes_,
                    _xsd_e_road_railroad_switch_position_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_road_railroad_switch_position_indexes_ + 3 || _xsd_e_road_railroad_switch_position_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_road_railroad_switch_position::
_xsd_e_road_railroad_switch_position_literals_[3] =
{
  "dynamic",
  "straight",
  "turn"
};

const e_road_railroad_switch_position::value e_road_railroad_switch_position::
_xsd_e_road_railroad_switch_position_indexes_[3] =
{
  ::e_road_railroad_switch_position::dynamic,
  ::e_road_railroad_switch_position::straight,
  ::e_road_railroad_switch_position::turn
};

// t_road_railroad_switch_mainTrack
//

t_road_railroad_switch_mainTrack::
t_road_railroad_switch_mainTrack (const id_type& id,
                                  const s_type& s,
                                  const dir_type& dir)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this),
  s_ (s, this),
  dir_ (dir, this)
{
}

t_road_railroad_switch_mainTrack::
t_road_railroad_switch_mainTrack (const t_road_railroad_switch_mainTrack& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  s_ (x.s_, f, this),
  dir_ (x.dir_, f, this)
{
}

t_road_railroad_switch_mainTrack::
t_road_railroad_switch_mainTrack (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  s_ (this),
  dir_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_railroad_switch_mainTrack::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dir" && n.namespace_ ().empty ())
    {
      this->dir_.set (dir_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!dir_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dir",
      "");
  }
}

t_road_railroad_switch_mainTrack* t_road_railroad_switch_mainTrack::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_railroad_switch_mainTrack (*this, f, c);
}

t_road_railroad_switch_mainTrack& t_road_railroad_switch_mainTrack::
operator= (const t_road_railroad_switch_mainTrack& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->s_ = x.s_;
    this->dir_ = x.dir_;
  }

  return *this;
}

t_road_railroad_switch_mainTrack::
~t_road_railroad_switch_mainTrack ()
{
}

// t_road_railroad_switch_sideTrack
//

t_road_railroad_switch_sideTrack::
t_road_railroad_switch_sideTrack (const id_type& id,
                                  const s_type& s,
                                  const dir_type& dir)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this),
  s_ (s, this),
  dir_ (dir, this)
{
}

t_road_railroad_switch_sideTrack::
t_road_railroad_switch_sideTrack (const t_road_railroad_switch_sideTrack& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  s_ (x.s_, f, this),
  dir_ (x.dir_, f, this)
{
}

t_road_railroad_switch_sideTrack::
t_road_railroad_switch_sideTrack (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  s_ (this),
  dir_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_railroad_switch_sideTrack::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "s" && n.namespace_ ().empty ())
    {
      this->s_.set (s_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dir" && n.namespace_ ().empty ())
    {
      this->dir_.set (dir_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!s_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "s",
      "");
  }

  if (!dir_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dir",
      "");
  }
}

t_road_railroad_switch_sideTrack* t_road_railroad_switch_sideTrack::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_railroad_switch_sideTrack (*this, f, c);
}

t_road_railroad_switch_sideTrack& t_road_railroad_switch_sideTrack::
operator= (const t_road_railroad_switch_sideTrack& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->s_ = x.s_;
    this->dir_ = x.dir_;
  }

  return *this;
}

t_road_railroad_switch_sideTrack::
~t_road_railroad_switch_sideTrack ()
{
}

// t_road_railroad_switch_partner
//

t_road_railroad_switch_partner::
t_road_railroad_switch_partner (const id_type& id)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (id, this)
{
}

t_road_railroad_switch_partner::
t_road_railroad_switch_partner (const t_road_railroad_switch_partner& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this)
{
}

t_road_railroad_switch_partner::
t_road_railroad_switch_partner (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_road_railroad_switch_partner::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_road_railroad_switch_partner* t_road_railroad_switch_partner::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_road_railroad_switch_partner (*this, f, c);
}

t_road_railroad_switch_partner& t_road_railroad_switch_partner::
operator= (const t_road_railroad_switch_partner& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->id_ = x.id_;
  }

  return *this;
}

t_road_railroad_switch_partner::
~t_road_railroad_switch_partner ()
{
}

// t_controller
//

t_controller::
t_controller (const id_type& id)
: ::xml_schema::type (),
  control_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this),
  name_ (this),
  sequence_ (this)
{
}

t_controller::
t_controller (const t_controller& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  control_ (x.control_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  name_ (x.name_, f, this),
  sequence_ (x.sequence_, f, this)
{
}

t_controller::
t_controller (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  control_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  name_ (this),
  sequence_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_controller::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // control
    //
    if (n.name () == "control" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< control_type > r (
        control_traits::create (i, f, this));

      this->control_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sequence" && n.namespace_ ().empty ())
    {
      this->sequence_.set (sequence_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_controller* t_controller::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_controller (*this, f, c);
}

t_controller& t_controller::
operator= (const t_controller& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->control_ = x.control_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->name_ = x.name_;
    this->sequence_ = x.sequence_;
  }

  return *this;
}

t_controller::
~t_controller ()
{
}

// t_controller_control
//

t_controller_control::
t_controller_control (const signalId_type& signalId)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  signalId_ (signalId, this),
  type_ (this)
{
}

t_controller_control::
t_controller_control (const t_controller_control& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  signalId_ (x.signalId_, f, this),
  type_ (x.type_, f, this)
{
}

t_controller_control::
t_controller_control (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  signalId_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_controller_control::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "signalId" && n.namespace_ ().empty ())
    {
      this->signalId_.set (signalId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!signalId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "signalId",
      "");
  }
}

t_controller_control* t_controller_control::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_controller_control (*this, f, c);
}

t_controller_control& t_controller_control::
operator= (const t_controller_control& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->signalId_ = x.signalId_;
    this->type_ = x.type_;
  }

  return *this;
}

t_controller_control::
~t_controller_control ()
{
}

// t_junction
//

t_junction::
t_junction (const id_type& id)
: ::xml_schema::type (),
  connection_ (this),
  priority_ (this),
  controller_ (this),
  surface_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (id, this),
  type_ (this)
{
}

t_junction::
t_junction (const t_junction& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  connection_ (x.connection_, f, this),
  priority_ (x.priority_, f, this),
  controller_ (x.controller_, f, this),
  surface_ (x.surface_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

t_junction::
t_junction (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  connection_ (this),
  priority_ (this),
  controller_ (this),
  surface_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // connection
    //
    if (n.name () == "connection" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< connection_type > r (
        connection_traits::create (i, f, this));

      this->connection_.push_back (::std::move (r));
      continue;
    }

    // priority
    //
    if (n.name () == "priority" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< priority_type > r (
        priority_traits::create (i, f, this));

      this->priority_.push_back (::std::move (r));
      continue;
    }

    // controller
    //
    if (n.name () == "controller" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< controller_type > r (
        controller_traits::create (i, f, this));

      this->controller_.push_back (::std::move (r));
      continue;
    }

    // surface
    //
    if (n.name () == "surface" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< surface_type > r (
        surface_traits::create (i, f, this));

      if (!this->surface_)
      {
        this->surface_.set (::std::move (r));
        continue;
      }
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_junction* t_junction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction (*this, f, c);
}

t_junction& t_junction::
operator= (const t_junction& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->connection_ = x.connection_;
    this->priority_ = x.priority_;
    this->controller_ = x.controller_;
    this->surface_ = x.surface_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

t_junction::
~t_junction ()
{
}

// e_junction_type
//

e_junction_type::
e_junction_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_junction_type_convert ();
}

e_junction_type::
e_junction_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_junction_type_convert ();
}

e_junction_type::
e_junction_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_junction_type_convert ();
}

e_junction_type* e_junction_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_junction_type (*this, f, c);
}

e_junction_type::value e_junction_type::
_xsd_e_junction_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_junction_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_junction_type_indexes_,
                    _xsd_e_junction_type_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_junction_type_indexes_ + 2 || _xsd_e_junction_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_junction_type::
_xsd_e_junction_type_literals_[2] =
{
  "default",
  "virtual"
};

const e_junction_type::value e_junction_type::
_xsd_e_junction_type_indexes_[2] =
{
  ::e_junction_type::default_,
  ::e_junction_type::virtual_
};

// t_junction_connection
//

t_junction_connection::
t_junction_connection (const id_type& id,
                       const incomingRoad_type& incomingRoad,
                       const connectingRoad_type& connectingRoad,
                       const contactPoint_type& contactPoint)
: ::xml_schema::type (),
  predecessor_ (this),
  successor_ (this),
  laneLink_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this),
  incomingRoad_ (incomingRoad, this),
  connectingRoad_ (connectingRoad, this),
  contactPoint_ (contactPoint, this),
  connectionMaster_ (this),
  type_ (this)
{
}

t_junction_connection::
t_junction_connection (const t_junction_connection& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this),
  laneLink_ (x.laneLink_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  incomingRoad_ (x.incomingRoad_, f, this),
  connectingRoad_ (x.connectingRoad_, f, this),
  contactPoint_ (x.contactPoint_, f, this),
  connectionMaster_ (x.connectionMaster_, f, this),
  type_ (x.type_, f, this)
{
}

t_junction_connection::
t_junction_connection (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this),
  laneLink_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  incomingRoad_ (this),
  connectingRoad_ (this),
  contactPoint_ (this),
  connectionMaster_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junction_connection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      if (!this->predecessor_)
      {
        this->predecessor_.set (::std::move (r));
        continue;
      }
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      if (!this->successor_)
      {
        this->successor_.set (::std::move (r));
        continue;
      }
    }

    // laneLink
    //
    if (n.name () == "laneLink" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< laneLink_type > r (
        laneLink_traits::create (i, f, this));

      this->laneLink_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "incomingRoad" && n.namespace_ ().empty ())
    {
      this->incomingRoad_.set (incomingRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "connectingRoad" && n.namespace_ ().empty ())
    {
      this->connectingRoad_.set (connectingRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "connectionMaster" && n.namespace_ ().empty ())
    {
      this->connectionMaster_.set (connectionMaster_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!incomingRoad_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "incomingRoad",
      "");
  }

  if (!connectingRoad_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "connectingRoad",
      "");
  }

  if (!contactPoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "contactPoint",
      "");
  }
}

t_junction_connection* t_junction_connection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_connection (*this, f, c);
}

t_junction_connection& t_junction_connection::
operator= (const t_junction_connection& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
    this->laneLink_ = x.laneLink_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->incomingRoad_ = x.incomingRoad_;
    this->connectingRoad_ = x.connectingRoad_;
    this->contactPoint_ = x.contactPoint_;
    this->connectionMaster_ = x.connectionMaster_;
    this->type_ = x.type_;
  }

  return *this;
}

t_junction_connection::
~t_junction_connection ()
{
}

// t_junction_predecessorSuccessor
//

const t_junction_predecessorSuccessor::elementType_type t_junction_predecessorSuccessor::elementType_default_value_ (
  "road");

t_junction_predecessorSuccessor::
t_junction_predecessorSuccessor (const elementId_type& elementId,
                                 const elementS_type& elementS,
                                 const elementDir_type& elementDir)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  elementType_ (elementType_default_value (), this),
  elementId_ (elementId, this),
  elementS_ (elementS, this),
  elementDir_ (elementDir, this)
{
}

t_junction_predecessorSuccessor::
t_junction_predecessorSuccessor (const t_junction_predecessorSuccessor& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  elementType_ (x.elementType_, f, this),
  elementId_ (x.elementId_, f, this),
  elementS_ (x.elementS_, f, this),
  elementDir_ (x.elementDir_, f, this)
{
}

t_junction_predecessorSuccessor::
t_junction_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  elementType_ (this),
  elementId_ (this),
  elementS_ (this),
  elementDir_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junction_predecessorSuccessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementS" && n.namespace_ ().empty ())
    {
      this->elementS_.set (elementS_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementDir" && n.namespace_ ().empty ())
    {
      this->elementDir_.set (elementDir_traits::create (i, f, this));
      continue;
    }
  }

  if (!elementType_.present ())
  {
    this->elementType_.set (elementType_default_value ());
  }

  if (!elementId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementId",
      "");
  }

  if (!elementS_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementS",
      "");
  }

  if (!elementDir_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "elementDir",
      "");
  }
}

t_junction_predecessorSuccessor* t_junction_predecessorSuccessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_predecessorSuccessor (*this, f, c);
}

t_junction_predecessorSuccessor& t_junction_predecessorSuccessor::
operator= (const t_junction_predecessorSuccessor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->elementType_ = x.elementType_;
    this->elementId_ = x.elementId_;
    this->elementS_ = x.elementS_;
    this->elementDir_ = x.elementDir_;
  }

  return *this;
}

t_junction_predecessorSuccessor::
~t_junction_predecessorSuccessor ()
{
}

// t_junction_connection_laneLink
//

t_junction_connection_laneLink::
t_junction_connection_laneLink (const from_type& from,
                                const to_type& to)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  from_ (from, this),
  to_ (to, this)
{
}

t_junction_connection_laneLink::
t_junction_connection_laneLink (const t_junction_connection_laneLink& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  from_ (x.from_, f, this),
  to_ (x.to_, f, this)
{
}

t_junction_connection_laneLink::
t_junction_connection_laneLink (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  from_ (this),
  to_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junction_connection_laneLink::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "from" && n.namespace_ ().empty ())
    {
      this->from_.set (from_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "to" && n.namespace_ ().empty ())
    {
      this->to_.set (to_traits::create (i, f, this));
      continue;
    }
  }

  if (!from_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "from",
      "");
  }

  if (!to_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "to",
      "");
  }
}

t_junction_connection_laneLink* t_junction_connection_laneLink::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_connection_laneLink (*this, f, c);
}

t_junction_connection_laneLink& t_junction_connection_laneLink::
operator= (const t_junction_connection_laneLink& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->from_ = x.from_;
    this->to_ = x.to_;
  }

  return *this;
}

t_junction_connection_laneLink::
~t_junction_connection_laneLink ()
{
}

// t_junction_priority
//

t_junction_priority::
t_junction_priority ()
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  high_ (this),
  low_ (this)
{
}

t_junction_priority::
t_junction_priority (const t_junction_priority& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  high_ (x.high_, f, this),
  low_ (x.low_, f, this)
{
}

t_junction_priority::
t_junction_priority (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  high_ (this),
  low_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junction_priority::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "high" && n.namespace_ ().empty ())
    {
      this->high_.set (high_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "low" && n.namespace_ ().empty ())
    {
      this->low_.set (low_traits::create (i, f, this));
      continue;
    }
  }
}

t_junction_priority* t_junction_priority::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_priority (*this, f, c);
}

t_junction_priority& t_junction_priority::
operator= (const t_junction_priority& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->high_ = x.high_;
    this->low_ = x.low_;
  }

  return *this;
}

t_junction_priority::
~t_junction_priority ()
{
}

// t_junction_controller
//

t_junction_controller::
t_junction_controller (const id_type& id)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (id, this),
  type_ (this),
  sequence_ (this)
{
}

t_junction_controller::
t_junction_controller (const t_junction_controller& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  sequence_ (x.sequence_, f, this)
{
}

t_junction_controller::
t_junction_controller (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  id_ (this),
  type_ (this),
  sequence_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junction_controller::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sequence" && n.namespace_ ().empty ())
    {
      this->sequence_.set (sequence_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_junction_controller* t_junction_controller::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_controller (*this, f, c);
}

t_junction_controller& t_junction_controller::
operator= (const t_junction_controller& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->sequence_ = x.sequence_;
  }

  return *this;
}

t_junction_controller::
~t_junction_controller ()
{
}

// t_junction_surface
//

t_junction_surface::
t_junction_surface ()
: ::xml_schema::type (),
  CRG_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

t_junction_surface::
t_junction_surface (const t_junction_surface& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  CRG_ (x.CRG_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

t_junction_surface::
t_junction_surface (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  CRG_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_junction_surface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CRG
    //
    if (n.name () == "CRG" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< CRG_type > r (
        CRG_traits::create (i, f, this));

      this->CRG_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_junction_surface* t_junction_surface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_surface (*this, f, c);
}

t_junction_surface& t_junction_surface::
operator= (const t_junction_surface& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->CRG_ = x.CRG_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

t_junction_surface::
~t_junction_surface ()
{
}

// t_junction_surface_CRG
//

const t_junction_surface_CRG::mode_type t_junction_surface_CRG::mode_default_value_ (
  "global");

t_junction_surface_CRG::
t_junction_surface_CRG (const file_type& file)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  file_ (file, this),
  mode_ (mode_default_value (), this),
  purpose_ (this),
  zOffset_ (this),
  zScale_ (this)
{
}

t_junction_surface_CRG::
t_junction_surface_CRG (const t_junction_surface_CRG& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  file_ (x.file_, f, this),
  mode_ (x.mode_, f, this),
  purpose_ (x.purpose_, f, this),
  zOffset_ (x.zOffset_, f, this),
  zScale_ (x.zScale_, f, this)
{
}

t_junction_surface_CRG::
t_junction_surface_CRG (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  file_ (this),
  mode_ (this),
  purpose_ (this),
  zOffset_ (this),
  zScale_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junction_surface_CRG::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      this->file_.set (file_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mode" && n.namespace_ ().empty ())
    {
      this->mode_.set (mode_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "purpose" && n.namespace_ ().empty ())
    {
      this->purpose_.set (purpose_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zOffset" && n.namespace_ ().empty ())
    {
      this->zOffset_.set (zOffset_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zScale" && n.namespace_ ().empty ())
    {
      this->zScale_.set (zScale_traits::create (i, f, this));
      continue;
    }
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }

  if (!mode_.present ())
  {
    this->mode_.set (mode_default_value ());
  }
}

t_junction_surface_CRG* t_junction_surface_CRG::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junction_surface_CRG (*this, f, c);
}

t_junction_surface_CRG& t_junction_surface_CRG::
operator= (const t_junction_surface_CRG& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->file_ = x.file_;
    this->mode_ = x.mode_;
    this->purpose_ = x.purpose_;
    this->zOffset_ = x.zOffset_;
    this->zScale_ = x.zScale_;
  }

  return *this;
}

t_junction_surface_CRG::
~t_junction_surface_CRG ()
{
}

// t_junctionGroup
//

t_junctionGroup::
t_junctionGroup (const id_type& id,
                 const type_type& type)
: ::xml_schema::type (),
  junctionReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (id, this),
  type_ (type, this)
{
}

t_junctionGroup::
t_junctionGroup (const t_junctionGroup& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  junctionReference_ (x.junctionReference_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

t_junctionGroup::
t_junctionGroup (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  junctionReference_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junctionGroup::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // junctionReference
    //
    if (n.name () == "junctionReference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< junctionReference_type > r (
        junctionReference_traits::create (i, f, this));

      this->junctionReference_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

t_junctionGroup* t_junctionGroup::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junctionGroup (*this, f, c);
}

t_junctionGroup& t_junctionGroup::
operator= (const t_junctionGroup& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->junctionReference_ = x.junctionReference_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

t_junctionGroup::
~t_junctionGroup ()
{
}

// e_junctionGroup_type
//

e_junctionGroup_type::
e_junctionGroup_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_junctionGroup_type_convert ();
}

e_junctionGroup_type::
e_junctionGroup_type (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_junctionGroup_type_convert ();
}

e_junctionGroup_type::
e_junctionGroup_type (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_junctionGroup_type_convert ();
}

e_junctionGroup_type* e_junctionGroup_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_junctionGroup_type (*this, f, c);
}

e_junctionGroup_type::value e_junctionGroup_type::
_xsd_e_junctionGroup_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_junctionGroup_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_junctionGroup_type_indexes_,
                    _xsd_e_junctionGroup_type_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_junctionGroup_type_indexes_ + 2 || _xsd_e_junctionGroup_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_junctionGroup_type::
_xsd_e_junctionGroup_type_literals_[2] =
{
  "roundabout",
  "unknown"
};

const e_junctionGroup_type::value e_junctionGroup_type::
_xsd_e_junctionGroup_type_indexes_[2] =
{
  ::e_junctionGroup_type::roundabout,
  ::e_junctionGroup_type::unknown
};

// t_junctionGroup_junctionReference
//

t_junctionGroup_junctionReference::
t_junctionGroup_junctionReference (const junction_type& junction)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  junction_ (junction, this)
{
}

t_junctionGroup_junctionReference::
t_junctionGroup_junctionReference (const t_junctionGroup_junctionReference& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  junction_ (x.junction_, f, this)
{
}

t_junctionGroup_junctionReference::
t_junctionGroup_junctionReference (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  junction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_junctionGroup_junctionReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      this->junction_.set (junction_traits::create (i, f, this));
      continue;
    }
  }

  if (!junction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "junction",
      "");
  }
}

t_junctionGroup_junctionReference* t_junctionGroup_junctionReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_junctionGroup_junctionReference (*this, f, c);
}

t_junctionGroup_junctionReference& t_junctionGroup_junctionReference::
operator= (const t_junctionGroup_junctionReference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->junction_ = x.junction_;
  }

  return *this;
}

t_junctionGroup_junctionReference::
~t_junctionGroup_junctionReference ()
{
}

// t_station
//

t_station::
t_station (const name_type& name,
           const id_type& id)
: ::xml_schema::type (),
  platform_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (name, this),
  id_ (id, this),
  type_ (this)
{
}

t_station::
t_station (const t_station& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  platform_ (x.platform_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

t_station::
t_station (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  platform_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_station::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // platform
    //
    if (n.name () == "platform" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< platform_type > r (
        platform_traits::create (i, f, this));

      this->platform_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_station* t_station::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_station (*this, f, c);
}

t_station& t_station::
operator= (const t_station& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->platform_ = x.platform_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

t_station::
~t_station ()
{
}

// e_station_type
//

e_station_type::
e_station_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_station_type_convert ();
}

e_station_type::
e_station_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_station_type_convert ();
}

e_station_type::
e_station_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_station_type_convert ();
}

e_station_type* e_station_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_station_type (*this, f, c);
}

e_station_type::value e_station_type::
_xsd_e_station_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_station_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_station_type_indexes_,
                    _xsd_e_station_type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_station_type_indexes_ + 3 || _xsd_e_station_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_station_type::
_xsd_e_station_type_literals_[3] =
{
  "small",
  "medium",
  "large"
};

const e_station_type::value e_station_type::
_xsd_e_station_type_indexes_[3] =
{
  ::e_station_type::large,
  ::e_station_type::medium,
  ::e_station_type::smaller
};

// t_station_platform
//

t_station_platform::
t_station_platform (const id_type& id)
: ::xml_schema::type (),
  segment_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (id, this)
{
}

t_station_platform::
t_station_platform (const t_station_platform& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  segment_ (x.segment_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this)
{
}

t_station_platform::
t_station_platform (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  segment_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  name_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_station_platform::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // segment
    //
    if (n.name () == "segment" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< segment_type > r (
        segment_traits::create (i, f, this));

      this->segment_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

t_station_platform* t_station_platform::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_station_platform (*this, f, c);
}

t_station_platform& t_station_platform::
operator= (const t_station_platform& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->segment_ = x.segment_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->name_ = x.name_;
    this->id_ = x.id_;
  }

  return *this;
}

t_station_platform::
~t_station_platform ()
{
}

// t_station_platform_segment
//

t_station_platform_segment::
t_station_platform_segment (const roadId_type& roadId,
                            const sStart_type& sStart,
                            const sEnd_type& sEnd,
                            const side_type& side)
: ::xml_schema::type (),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  roadId_ (roadId, this),
  sStart_ (sStart, this),
  sEnd_ (sEnd, this),
  side_ (side, this)
{
}

t_station_platform_segment::
t_station_platform_segment (const t_station_platform_segment& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this),
  roadId_ (x.roadId_, f, this),
  sStart_ (x.sStart_, f, this),
  sEnd_ (x.sEnd_, f, this),
  side_ (x.side_, f, this)
{
}

t_station_platform_segment::
t_station_platform_segment (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  userData_ (this),
  include_ (this),
  dataQuality_ (this),
  roadId_ (this),
  sStart_ (this),
  sEnd_ (this),
  side_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_station_platform_segment::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "roadId" && n.namespace_ ().empty ())
    {
      this->roadId_.set (roadId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sStart" && n.namespace_ ().empty ())
    {
      this->sStart_.set (sStart_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sEnd" && n.namespace_ ().empty ())
    {
      this->sEnd_.set (sEnd_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      this->side_.set (side_traits::create (i, f, this));
      continue;
    }
  }

  if (!roadId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "roadId",
      "");
  }

  if (!sStart_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sStart",
      "");
  }

  if (!sEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sEnd",
      "");
  }

  if (!side_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "side",
      "");
  }
}

t_station_platform_segment* t_station_platform_segment::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_station_platform_segment (*this, f, c);
}

t_station_platform_segment& t_station_platform_segment::
operator= (const t_station_platform_segment& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
    this->roadId_ = x.roadId_;
    this->sStart_ = x.sStart_;
    this->sEnd_ = x.sEnd_;
    this->side_ = x.side_;
  }

  return *this;
}

t_station_platform_segment::
~t_station_platform_segment ()
{
}

// e_station_platform_segment_side
//

e_station_platform_segment_side::
e_station_platform_segment_side (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_station_platform_segment_side_convert ();
}

e_station_platform_segment_side::
e_station_platform_segment_side (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_station_platform_segment_side_convert ();
}

e_station_platform_segment_side::
e_station_platform_segment_side (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_station_platform_segment_side_convert ();
}

e_station_platform_segment_side* e_station_platform_segment_side::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_station_platform_segment_side (*this, f, c);
}

e_station_platform_segment_side::value e_station_platform_segment_side::
_xsd_e_station_platform_segment_side_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_station_platform_segment_side_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_station_platform_segment_side_indexes_,
                    _xsd_e_station_platform_segment_side_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_station_platform_segment_side_indexes_ + 2 || _xsd_e_station_platform_segment_side_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_station_platform_segment_side::
_xsd_e_station_platform_segment_side_literals_[2] =
{
  "left",
  "right"
};

const e_station_platform_segment_side::value e_station_platform_segment_side::
_xsd_e_station_platform_segment_side_indexes_[2] =
{
  ::e_station_platform_segment_side::left,
  ::e_station_platform_segment_side::right
};

// t_userData
//

t_userData::
t_userData (const code_type& code,
            const value_type& value)
: ::xml_schema::type (),
  code_ (code, this),
  value_ (value, this)
{
}

t_userData::
t_userData (const t_userData& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  code_ (x.code_, f, this),
  value_ (x.value_, f, this)
{
}

t_userData::
t_userData (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  code_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void t_userData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "code" && n.namespace_ ().empty ())
    {
      this->code_.set (code_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }
  }

  if (!code_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "code",
      "");
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }
}

t_userData* t_userData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_userData (*this, f, c);
}

t_userData& t_userData::
operator= (const t_userData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->code_ = x.code_;
    this->value_ = x.value_;
  }

  return *this;
}

t_userData::
~t_userData ()
{
}

// t_include
//

t_include::
t_include (const file_type& file)
: ::xml_schema::type (),
  file_ (file, this)
{
}

t_include::
t_include (const t_include& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  file_ (x.file_, f, this)
{
}

t_include::
t_include (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  file_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_include::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      this->file_.set (file_traits::create (i, f, this));
      continue;
    }
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }
}

t_include* t_include::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_include (*this, f, c);
}

t_include& t_include::
operator= (const t_include& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->file_ = x.file_;
  }

  return *this;
}

t_include::
~t_include ()
{
}

// t_dataQuality
//

t_dataQuality::
t_dataQuality ()
: ::xml_schema::type (),
  error_ (this),
  rawData_ (this)
{
}

t_dataQuality::
t_dataQuality (const t_dataQuality& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  error_ (x.error_, f, this),
  rawData_ (x.rawData_, f, this)
{
}

t_dataQuality::
t_dataQuality (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  error_ (this),
  rawData_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void t_dataQuality::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // error
    //
    if (n.name () == "error" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< error_type > r (
        error_traits::create (i, f, this));

      if (!this->error_)
      {
        this->error_.set (::std::move (r));
        continue;
      }
    }

    // rawData
    //
    if (n.name () == "rawData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< rawData_type > r (
        rawData_traits::create (i, f, this));

      if (!this->rawData_)
      {
        this->rawData_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

t_dataQuality* t_dataQuality::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_dataQuality (*this, f, c);
}

t_dataQuality& t_dataQuality::
operator= (const t_dataQuality& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->error_ = x.error_;
    this->rawData_ = x.rawData_;
  }

  return *this;
}

t_dataQuality::
~t_dataQuality ()
{
}

// t_dataQuality_Error
//

t_dataQuality_Error::
t_dataQuality_Error (const xyAbsolute_type& xyAbsolute,
                     const zAbsolute_type& zAbsolute,
                     const xyRelative_type& xyRelative,
                     const zRelative_type& zRelative)
: ::xml_schema::type (),
  xyAbsolute_ (xyAbsolute, this),
  zAbsolute_ (zAbsolute, this),
  xyRelative_ (xyRelative, this),
  zRelative_ (zRelative, this)
{
}

t_dataQuality_Error::
t_dataQuality_Error (const t_dataQuality_Error& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  xyAbsolute_ (x.xyAbsolute_, f, this),
  zAbsolute_ (x.zAbsolute_, f, this),
  xyRelative_ (x.xyRelative_, f, this),
  zRelative_ (x.zRelative_, f, this)
{
}

t_dataQuality_Error::
t_dataQuality_Error (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  xyAbsolute_ (this),
  zAbsolute_ (this),
  xyRelative_ (this),
  zRelative_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_dataQuality_Error::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "xyAbsolute" && n.namespace_ ().empty ())
    {
      this->xyAbsolute_.set (xyAbsolute_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zAbsolute" && n.namespace_ ().empty ())
    {
      this->zAbsolute_.set (zAbsolute_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xyRelative" && n.namespace_ ().empty ())
    {
      this->xyRelative_.set (xyRelative_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zRelative" && n.namespace_ ().empty ())
    {
      this->zRelative_.set (zRelative_traits::create (i, f, this));
      continue;
    }
  }

  if (!xyAbsolute_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xyAbsolute",
      "");
  }

  if (!zAbsolute_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zAbsolute",
      "");
  }

  if (!xyRelative_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xyRelative",
      "");
  }

  if (!zRelative_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zRelative",
      "");
  }
}

t_dataQuality_Error* t_dataQuality_Error::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_dataQuality_Error (*this, f, c);
}

t_dataQuality_Error& t_dataQuality_Error::
operator= (const t_dataQuality_Error& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->xyAbsolute_ = x.xyAbsolute_;
    this->zAbsolute_ = x.zAbsolute_;
    this->xyRelative_ = x.xyRelative_;
    this->zRelative_ = x.zRelative_;
  }

  return *this;
}

t_dataQuality_Error::
~t_dataQuality_Error ()
{
}

// t_dataQuality_RawData
//

t_dataQuality_RawData::
t_dataQuality_RawData (const date_type& date,
                       const source_type& source,
                       const postProcessing_type& postProcessing)
: ::xml_schema::type (),
  date_ (date, this),
  source_ (source, this),
  sourceComment_ (this),
  postProcessing_ (postProcessing, this),
  postProcessingComment_ (this)
{
}

t_dataQuality_RawData::
t_dataQuality_RawData (const t_dataQuality_RawData& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  date_ (x.date_, f, this),
  source_ (x.source_, f, this),
  sourceComment_ (x.sourceComment_, f, this),
  postProcessing_ (x.postProcessing_, f, this),
  postProcessingComment_ (x.postProcessingComment_, f, this)
{
}

t_dataQuality_RawData::
t_dataQuality_RawData (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  date_ (this),
  source_ (this),
  sourceComment_ (this),
  postProcessing_ (this),
  postProcessingComment_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void t_dataQuality_RawData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "date" && n.namespace_ ().empty ())
    {
      this->date_.set (date_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      this->source_.set (source_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sourceComment" && n.namespace_ ().empty ())
    {
      this->sourceComment_.set (sourceComment_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "postProcessing" && n.namespace_ ().empty ())
    {
      this->postProcessing_.set (postProcessing_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "postProcessingComment" && n.namespace_ ().empty ())
    {
      this->postProcessingComment_.set (postProcessingComment_traits::create (i, f, this));
      continue;
    }
  }

  if (!date_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "date",
      "");
  }

  if (!source_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "source",
      "");
  }

  if (!postProcessing_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "postProcessing",
      "");
  }
}

t_dataQuality_RawData* t_dataQuality_RawData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class t_dataQuality_RawData (*this, f, c);
}

t_dataQuality_RawData& t_dataQuality_RawData::
operator= (const t_dataQuality_RawData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->date_ = x.date_;
    this->source_ = x.source_;
    this->sourceComment_ = x.sourceComment_;
    this->postProcessing_ = x.postProcessing_;
    this->postProcessingComment_ = x.postProcessingComment_;
  }

  return *this;
}

t_dataQuality_RawData::
~t_dataQuality_RawData ()
{
}

// e_dataQuality_RawData_Source
//

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_dataQuality_RawData_Source_convert ();
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_dataQuality_RawData_Source_convert ();
}

e_dataQuality_RawData_Source::
e_dataQuality_RawData_Source (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_dataQuality_RawData_Source_convert ();
}

e_dataQuality_RawData_Source* e_dataQuality_RawData_Source::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_dataQuality_RawData_Source (*this, f, c);
}

e_dataQuality_RawData_Source::value e_dataQuality_RawData_Source::
_xsd_e_dataQuality_RawData_Source_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_dataQuality_RawData_Source_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_dataQuality_RawData_Source_indexes_,
                    _xsd_e_dataQuality_RawData_Source_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_dataQuality_RawData_Source_indexes_ + 3 || _xsd_e_dataQuality_RawData_Source_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_dataQuality_RawData_Source::
_xsd_e_dataQuality_RawData_Source_literals_[3] =
{
  "sensor",
  "cadaster",
  "custom"
};

const e_dataQuality_RawData_Source::value e_dataQuality_RawData_Source::
_xsd_e_dataQuality_RawData_Source_indexes_[3] =
{
  ::e_dataQuality_RawData_Source::cadaster,
  ::e_dataQuality_RawData_Source::custom,
  ::e_dataQuality_RawData_Source::sensor
};

// e_dataQuality_RawData_PostProcessing
//

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_dataQuality_RawData_PostProcessing_convert ();
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_dataQuality_RawData_PostProcessing_convert ();
}

e_dataQuality_RawData_PostProcessing::
e_dataQuality_RawData_PostProcessing (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_dataQuality_RawData_PostProcessing_convert ();
}

e_dataQuality_RawData_PostProcessing* e_dataQuality_RawData_PostProcessing::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_dataQuality_RawData_PostProcessing (*this, f, c);
}

e_dataQuality_RawData_PostProcessing::value e_dataQuality_RawData_PostProcessing::
_xsd_e_dataQuality_RawData_PostProcessing_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_dataQuality_RawData_PostProcessing_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_dataQuality_RawData_PostProcessing_indexes_,
                    _xsd_e_dataQuality_RawData_PostProcessing_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_dataQuality_RawData_PostProcessing_indexes_ + 4 || _xsd_e_dataQuality_RawData_PostProcessing_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_dataQuality_RawData_PostProcessing::
_xsd_e_dataQuality_RawData_PostProcessing_literals_[4] =
{
  "raw",
  "cleaned",
  "processed",
  "fused"
};

const e_dataQuality_RawData_PostProcessing::value e_dataQuality_RawData_PostProcessing::
_xsd_e_dataQuality_RawData_PostProcessing_indexes_[4] =
{
  ::e_dataQuality_RawData_PostProcessing::cleaned,
  ::e_dataQuality_RawData_PostProcessing::fused,
  ::e_dataQuality_RawData_PostProcessing::processed,
  ::e_dataQuality_RawData_PostProcessing::raw
};

// e_unitDistance
//

e_unitDistance::
e_unitDistance (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitDistance_convert ();
}

e_unitDistance::
e_unitDistance (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitDistance_convert ();
}

e_unitDistance::
e_unitDistance (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitDistance_convert ();
}

e_unitDistance* e_unitDistance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitDistance (*this, f, c);
}

e_unitDistance::value e_unitDistance::
_xsd_e_unitDistance_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitDistance_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitDistance_indexes_,
                    _xsd_e_unitDistance_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_unitDistance_indexes_ + 4 || _xsd_e_unitDistance_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitDistance::
_xsd_e_unitDistance_literals_[4] =
{
  "m",
  "km",
  "ft",
  "mile"
};

const e_unitDistance::value e_unitDistance::
_xsd_e_unitDistance_indexes_[4] =
{
  ::e_unitDistance::ft,
  ::e_unitDistance::km,
  ::e_unitDistance::m,
  ::e_unitDistance::mile
};

// e_unitSpeed
//

e_unitSpeed::
e_unitSpeed (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitSpeed_convert ();
}

e_unitSpeed::
e_unitSpeed (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitSpeed_convert ();
}

e_unitSpeed::
e_unitSpeed (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitSpeed_convert ();
}

e_unitSpeed* e_unitSpeed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitSpeed (*this, f, c);
}

e_unitSpeed::value e_unitSpeed::
_xsd_e_unitSpeed_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitSpeed_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitSpeed_indexes_,
                    _xsd_e_unitSpeed_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_unitSpeed_indexes_ + 3 || _xsd_e_unitSpeed_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitSpeed::
_xsd_e_unitSpeed_literals_[3] =
{
  "m/s",
  "mph",
  "km/h"
};

const e_unitSpeed::value e_unitSpeed::
_xsd_e_unitSpeed_indexes_[3] =
{
  ::e_unitSpeed::km_h,
  ::e_unitSpeed::m_s,
  ::e_unitSpeed::mph
};

// e_unitMass
//

e_unitMass::
e_unitMass (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitMass_convert ();
}

e_unitMass::
e_unitMass (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitMass_convert ();
}

e_unitMass::
e_unitMass (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitMass_convert ();
}

e_unitMass* e_unitMass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitMass (*this, f, c);
}

e_unitMass::value e_unitMass::
_xsd_e_unitMass_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitMass_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitMass_indexes_,
                    _xsd_e_unitMass_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_unitMass_indexes_ + 2 || _xsd_e_unitMass_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitMass::
_xsd_e_unitMass_literals_[2] =
{
  "kg",
  "t"
};

const e_unitMass::value e_unitMass::
_xsd_e_unitMass_indexes_[2] =
{
  ::e_unitMass::kg,
  ::e_unitMass::t
};

// e_unitSlope
//

e_unitSlope::
e_unitSlope (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unitSlope_convert ();
}

e_unitSlope::
e_unitSlope (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unitSlope_convert ();
}

e_unitSlope::
e_unitSlope (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unitSlope_convert ();
}

e_unitSlope* e_unitSlope::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unitSlope (*this, f, c);
}

e_unitSlope::value e_unitSlope::
_xsd_e_unitSlope_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unitSlope_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unitSlope_indexes_,
                    _xsd_e_unitSlope_indexes_ + 1,
                    *this,
                    c));

  if (i == _xsd_e_unitSlope_indexes_ + 1 || _xsd_e_unitSlope_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unitSlope::
_xsd_e_unitSlope_literals_[1] =
{
  "%"
};

const e_unitSlope::value e_unitSlope::
_xsd_e_unitSlope_indexes_[1] =
{
  ::e_unitSlope::cxx_
};

// e_unit
//

e_unit::
e_unit (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_unit_convert ();
}

e_unit::
e_unit (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_unit_convert ();
}

e_unit::
e_unit (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_unit_convert ();
}

e_unit* e_unit::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_unit (*this, f, c);
}

e_unit::value e_unit::
_xsd_e_unit_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_unit_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_unit_indexes_,
                    _xsd_e_unit_indexes_ + 10,
                    *this,
                    c));

  if (i == _xsd_e_unit_indexes_ + 10 || _xsd_e_unit_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_unit::
_xsd_e_unit_literals_[10] =
{
  "m",
  "km",
  "ft",
  "mile",
  "m/s",
  "mph",
  "km/h",
  "kg",
  "t",
  "%"
};

const e_unit::value e_unit::
_xsd_e_unit_indexes_[10] =
{
  ::e_unit::cxx_,
  ::e_unit::ft,
  ::e_unit::kg,
  ::e_unit::km,
  ::e_unit::km_h,
  ::e_unit::m,
  ::e_unit::m_s,
  ::e_unit::mile,
  ::e_unit::mph,
  ::e_unit::t
};

// e_roadType
//

e_roadType::
e_roadType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadType_convert ();
}

e_roadType::
e_roadType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadType_convert ();
}

e_roadType::
e_roadType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadType_convert ();
}

e_roadType* e_roadType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadType (*this, f, c);
}

e_roadType::value e_roadType::
_xsd_e_roadType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadType_indexes_,
                    _xsd_e_roadType_indexes_ + 13,
                    *this,
                    c));

  if (i == _xsd_e_roadType_indexes_ + 13 || _xsd_e_roadType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadType::
_xsd_e_roadType_literals_[13] =
{
  "unknown",
  "rural",
  "motorway",
  "town",
  "lowSpeed",
  "pedestrian",
  "bicycle",
  "townExpressway",
  "townCollector",
  "townArterial",
  "townPrivate",
  "townLocal",
  "townPlayStreet"
};

const e_roadType::value e_roadType::
_xsd_e_roadType_indexes_[13] =
{
  ::e_roadType::bicycle,
  ::e_roadType::lowSpeed,
  ::e_roadType::motorway,
  ::e_roadType::pedestrian,
  ::e_roadType::rural,
  ::e_roadType::town,
  ::e_roadType::townArterial,
  ::e_roadType::townCollector,
  ::e_roadType::townExpressway,
  ::e_roadType::townLocal,
  ::e_roadType::townPlayStreet,
  ::e_roadType::townPrivate,
  ::e_roadType::unknown
};

// e_roadMarkType
//

e_roadMarkType::
e_roadMarkType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkType_convert ();
}

e_roadMarkType::
e_roadMarkType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkType_convert ();
}

e_roadMarkType::
e_roadMarkType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkType_convert ();
}

e_roadMarkType* e_roadMarkType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkType (*this, f, c);
}

e_roadMarkType::value e_roadMarkType::
_xsd_e_roadMarkType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkType_indexes_,
                    _xsd_e_roadMarkType_indexes_ + 12,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkType_indexes_ + 12 || _xsd_e_roadMarkType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkType::
_xsd_e_roadMarkType_literals_[12] =
{
  "none",
  "solid",
  "broken",
  "solid solid",
  "solid broken",
  "broken solid",
  "broken broken",
  "botts dots",
  "grass",
  "curb",
  "custom",
  "edge"
};

const e_roadMarkType::value e_roadMarkType::
_xsd_e_roadMarkType_indexes_[12] =
{
  ::e_roadMarkType::botts_dots,
  ::e_roadMarkType::broken,
  ::e_roadMarkType::broken_broken,
  ::e_roadMarkType::broken_solid,
  ::e_roadMarkType::curb,
  ::e_roadMarkType::custom,
  ::e_roadMarkType::edge,
  ::e_roadMarkType::grass,
  ::e_roadMarkType::none,
  ::e_roadMarkType::solid,
  ::e_roadMarkType::solid_broken,
  ::e_roadMarkType::solid_solid
};

// e_roadMarkWeight
//

e_roadMarkWeight::
e_roadMarkWeight (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkWeight_convert ();
}

e_roadMarkWeight::
e_roadMarkWeight (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkWeight_convert ();
}

e_roadMarkWeight::
e_roadMarkWeight (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkWeight_convert ();
}

e_roadMarkWeight* e_roadMarkWeight::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkWeight (*this, f, c);
}

e_roadMarkWeight::value e_roadMarkWeight::
_xsd_e_roadMarkWeight_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkWeight_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkWeight_indexes_,
                    _xsd_e_roadMarkWeight_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkWeight_indexes_ + 2 || _xsd_e_roadMarkWeight_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkWeight::
_xsd_e_roadMarkWeight_literals_[2] =
{
  "standard",
  "bold"
};

const e_roadMarkWeight::value e_roadMarkWeight::
_xsd_e_roadMarkWeight_indexes_[2] =
{
  ::e_roadMarkWeight::bold,
  ::e_roadMarkWeight::standard
};

// e_roadMarkColor
//

e_roadMarkColor::
e_roadMarkColor (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkColor_convert ();
}

e_roadMarkColor::
e_roadMarkColor (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkColor_convert ();
}

e_roadMarkColor::
e_roadMarkColor (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkColor_convert ();
}

e_roadMarkColor* e_roadMarkColor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkColor (*this, f, c);
}

e_roadMarkColor::value e_roadMarkColor::
_xsd_e_roadMarkColor_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkColor_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkColor_indexes_,
                    _xsd_e_roadMarkColor_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkColor_indexes_ + 7 || _xsd_e_roadMarkColor_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkColor::
_xsd_e_roadMarkColor_literals_[7] =
{
  "standard",
  "blue",
  "green",
  "red",
  "white",
  "yellow",
  "orange"
};

const e_roadMarkColor::value e_roadMarkColor::
_xsd_e_roadMarkColor_indexes_[7] =
{
  ::e_roadMarkColor::blue,
  ::e_roadMarkColor::green,
  ::e_roadMarkColor::orange,
  ::e_roadMarkColor::red,
  ::e_roadMarkColor::standard,
  ::e_roadMarkColor::white,
  ::e_roadMarkColor::yellow
};

// e_laneType
//

e_laneType::
e_laneType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_laneType_convert ();
}

e_laneType::
e_laneType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_laneType_convert ();
}

e_laneType::
e_laneType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_laneType_convert ();
}

e_laneType* e_laneType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_laneType (*this, f, c);
}

e_laneType::value e_laneType::
_xsd_e_laneType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_laneType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_laneType_indexes_,
                    _xsd_e_laneType_indexes_ + 27,
                    *this,
                    c));

  if (i == _xsd_e_laneType_indexes_ + 27 || _xsd_e_laneType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_laneType::
_xsd_e_laneType_literals_[27] =
{
  "none",
  "driving",
  "stop",
  "shoulder",
  "biking",
  "sidewalk",
  "border",
  "restricted",
  "parking",
  "bidirectional",
  "median",
  "special1",
  "special2",
  "special3",
  "roadWorks",
  "tram",
  "rail",
  "entry",
  "exit",
  "offRamp",
  "onRamp",
  "connectingRamp",
  "bus",
  "taxi",
  "HOV",
  "mwyEntry",
  "mwyExit"
};

const e_laneType::value e_laneType::
_xsd_e_laneType_indexes_[27] =
{
  ::e_laneType::HOV,
  ::e_laneType::bidirectional,
  ::e_laneType::biking,
  ::e_laneType::border,
  ::e_laneType::bus,
  ::e_laneType::connectingRamp,
  ::e_laneType::driving,
  ::e_laneType::entry,
  ::e_laneType::exit,
  ::e_laneType::median,
  ::e_laneType::mwyEntry,
  ::e_laneType::mwyExit,
  ::e_laneType::none,
  ::e_laneType::offRamp,
  ::e_laneType::onRamp,
  ::e_laneType::parking,
  ::e_laneType::rail,
  ::e_laneType::restricted,
  ::e_laneType::roadWorks,
  ::e_laneType::shoulder,
  ::e_laneType::sidewalk,
  ::e_laneType::special1,
  ::e_laneType::special2,
  ::e_laneType::special3,
  ::e_laneType::stop,
  ::e_laneType::taxi,
  ::e_laneType::tram
};

// e_objectType
//

e_objectType::
e_objectType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_objectType_convert ();
}

e_objectType::
e_objectType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_objectType_convert ();
}

e_objectType::
e_objectType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_objectType_convert ();
}

e_objectType* e_objectType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_objectType (*this, f, c);
}

e_objectType::value e_objectType::
_xsd_e_objectType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_objectType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_objectType_indexes_,
                    _xsd_e_objectType_indexes_ + 26,
                    *this,
                    c));

  if (i == _xsd_e_objectType_indexes_ + 26 || _xsd_e_objectType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_objectType::
_xsd_e_objectType_literals_[26] =
{
  "none",
  "obstacle",
  "car",
  "pole",
  "tree",
  "vegetation",
  "barrier",
  "building",
  "parkingSpace",
  "patch",
  "railing",
  "trafficIsland",
  "crosswalk",
  "streetLamp",
  "gantry",
  "soundBarrier",
  "truck",
  "van",
  "bus",
  "trailer",
  "bike",
  "motorbike",
  "tram",
  "train",
  "pedestrian",
  "wind"
};

const e_objectType::value e_objectType::
_xsd_e_objectType_indexes_[26] =
{
  ::e_objectType::barrier,
  ::e_objectType::bike,
  ::e_objectType::building,
  ::e_objectType::bus,
  ::e_objectType::car,
  ::e_objectType::crosswalk,
  ::e_objectType::gantry,
  ::e_objectType::motorbike,
  ::e_objectType::none,
  ::e_objectType::obstacle,
  ::e_objectType::parkingSpace,
  ::e_objectType::patch,
  ::e_objectType::pedestrian,
  ::e_objectType::pole,
  ::e_objectType::railing,
  ::e_objectType::soundBarrier,
  ::e_objectType::streetLamp,
  ::e_objectType::trafficIsland,
  ::e_objectType::trailer,
  ::e_objectType::train,
  ::e_objectType::tram,
  ::e_objectType::tree,
  ::e_objectType::truck,
  ::e_objectType::van,
  ::e_objectType::vegetation,
  ::e_objectType::wind
};

// e_tunnelType
//

e_tunnelType::
e_tunnelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_tunnelType_convert ();
}

e_tunnelType::
e_tunnelType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_tunnelType_convert ();
}

e_tunnelType::
e_tunnelType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_tunnelType_convert ();
}

e_tunnelType* e_tunnelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_tunnelType (*this, f, c);
}

e_tunnelType::value e_tunnelType::
_xsd_e_tunnelType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_tunnelType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_tunnelType_indexes_,
                    _xsd_e_tunnelType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_tunnelType_indexes_ + 2 || _xsd_e_tunnelType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_tunnelType::
_xsd_e_tunnelType_literals_[2] =
{
  "standard",
  "underpass"
};

const e_tunnelType::value e_tunnelType::
_xsd_e_tunnelType_indexes_[2] =
{
  ::e_tunnelType::standard,
  ::e_tunnelType::underpass
};

// e_bridgeType
//

e_bridgeType::
e_bridgeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_bridgeType_convert ();
}

e_bridgeType::
e_bridgeType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_bridgeType_convert ();
}

e_bridgeType::
e_bridgeType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_bridgeType_convert ();
}

e_bridgeType* e_bridgeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_bridgeType (*this, f, c);
}

e_bridgeType::value e_bridgeType::
_xsd_e_bridgeType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_bridgeType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_bridgeType_indexes_,
                    _xsd_e_bridgeType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_bridgeType_indexes_ + 4 || _xsd_e_bridgeType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_bridgeType::
_xsd_e_bridgeType_literals_[4] =
{
  "concrete",
  "steel",
  "brick",
  "wood"
};

const e_bridgeType::value e_bridgeType::
_xsd_e_bridgeType_indexes_[4] =
{
  ::e_bridgeType::brick,
  ::e_bridgeType::concrete,
  ::e_bridgeType::steel,
  ::e_bridgeType::wood
};

// e_accessRestrictionType
//

e_accessRestrictionType::
e_accessRestrictionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_accessRestrictionType_convert ();
}

e_accessRestrictionType::
e_accessRestrictionType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_accessRestrictionType_convert ();
}

e_accessRestrictionType::
e_accessRestrictionType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_accessRestrictionType_convert ();
}

e_accessRestrictionType* e_accessRestrictionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_accessRestrictionType (*this, f, c);
}

e_accessRestrictionType::value e_accessRestrictionType::
_xsd_e_accessRestrictionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_accessRestrictionType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_accessRestrictionType_indexes_,
                    _xsd_e_accessRestrictionType_indexes_ + 14,
                    *this,
                    c));

  if (i == _xsd_e_accessRestrictionType_indexes_ + 14 || _xsd_e_accessRestrictionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_accessRestrictionType::
_xsd_e_accessRestrictionType_literals_[14] =
{
  "simulator",
  "autonomousTraffic",
  "pedestrian",
  "passengerCar",
  "bus",
  "delivery",
  "emergency",
  "taxi",
  "throughTraffic",
  "truck",
  "bicycle",
  "motorcycle",
  "none",
  "trucks"
};

const e_accessRestrictionType::value e_accessRestrictionType::
_xsd_e_accessRestrictionType_indexes_[14] =
{
  ::e_accessRestrictionType::autonomousTraffic,
  ::e_accessRestrictionType::bicycle,
  ::e_accessRestrictionType::bus,
  ::e_accessRestrictionType::delivery,
  ::e_accessRestrictionType::emergency,
  ::e_accessRestrictionType::motorcycle,
  ::e_accessRestrictionType::none,
  ::e_accessRestrictionType::passengerCar,
  ::e_accessRestrictionType::pedestrian,
  ::e_accessRestrictionType::simulator,
  ::e_accessRestrictionType::taxi,
  ::e_accessRestrictionType::throughTraffic,
  ::e_accessRestrictionType::truck,
  ::e_accessRestrictionType::trucks
};

// e_countryCode
//

e_countryCode::
e_countryCode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

e_countryCode::
e_countryCode (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

e_countryCode::
e_countryCode (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

e_countryCode* e_countryCode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_countryCode (*this, f, c);
}

// e_countryCode_deprecated
//

e_countryCode_deprecated::
e_countryCode_deprecated (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_countryCode_deprecated_convert ();
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_countryCode_deprecated_convert ();
}

e_countryCode_deprecated::
e_countryCode_deprecated (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_countryCode_deprecated_convert ();
}

e_countryCode_deprecated* e_countryCode_deprecated::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_countryCode_deprecated (*this, f, c);
}

e_countryCode_deprecated::value e_countryCode_deprecated::
_xsd_e_countryCode_deprecated_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_countryCode_deprecated_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_countryCode_deprecated_indexes_,
                    _xsd_e_countryCode_deprecated_indexes_ + 9,
                    *this,
                    c));

  if (i == _xsd_e_countryCode_deprecated_indexes_ + 9 || _xsd_e_countryCode_deprecated_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_countryCode_deprecated::
_xsd_e_countryCode_deprecated_literals_[9] =
{
  "OpenDRIVE",
  "Austria",
  "Brazil",
  "China",
  "France",
  "Germany",
  "Italy",
  "Switzerland",
  "USA"
};

const e_countryCode_deprecated::value e_countryCode_deprecated::
_xsd_e_countryCode_deprecated_indexes_[9] =
{
  ::e_countryCode_deprecated::Austria,
  ::e_countryCode_deprecated::Brazil,
  ::e_countryCode_deprecated::China,
  ::e_countryCode_deprecated::France,
  ::e_countryCode_deprecated::Germany,
  ::e_countryCode_deprecated::Italy,
  ::e_countryCode_deprecated::OpenDRIVE,
  ::e_countryCode_deprecated::Switzerland,
  ::e_countryCode_deprecated::USA
};

// e_countryCode_iso3166alpha3
//

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 ()
: ::xml_schema::string ()
{
}

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 (const e_countryCode_iso3166alpha3& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

e_countryCode_iso3166alpha3::
e_countryCode_iso3166alpha3 (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

e_countryCode_iso3166alpha3* e_countryCode_iso3166alpha3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_countryCode_iso3166alpha3 (*this, f, c);
}

e_countryCode_iso3166alpha3::
~e_countryCode_iso3166alpha3 ()
{
}

// e_sideType
//

e_sideType::
e_sideType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_sideType_convert ();
}

e_sideType::
e_sideType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_sideType_convert ();
}

e_sideType::
e_sideType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_sideType_convert ();
}

e_sideType* e_sideType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_sideType (*this, f, c);
}

e_sideType::value e_sideType::
_xsd_e_sideType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_sideType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_sideType_indexes_,
                    _xsd_e_sideType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_e_sideType_indexes_ + 4 || _xsd_e_sideType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_sideType::
_xsd_e_sideType_literals_[4] =
{
  "left",
  "right",
  "front",
  "rear"
};

const e_sideType::value e_sideType::
_xsd_e_sideType_indexes_[4] =
{
  ::e_sideType::front,
  ::e_sideType::left,
  ::e_sideType::rear,
  ::e_sideType::right
};

// e_outlineFillType
//

e_outlineFillType::
e_outlineFillType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_outlineFillType_convert ();
}

e_outlineFillType::
e_outlineFillType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_outlineFillType_convert ();
}

e_outlineFillType::
e_outlineFillType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_outlineFillType_convert ();
}

e_outlineFillType* e_outlineFillType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_outlineFillType (*this, f, c);
}

e_outlineFillType::value e_outlineFillType::
_xsd_e_outlineFillType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_outlineFillType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_outlineFillType_indexes_,
                    _xsd_e_outlineFillType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_e_outlineFillType_indexes_ + 7 || _xsd_e_outlineFillType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_outlineFillType::
_xsd_e_outlineFillType_literals_[7] =
{
  "grass",
  "concrete",
  "cobble",
  "asphalt",
  "pavement",
  "gravel",
  "soil"
};

const e_outlineFillType::value e_outlineFillType::
_xsd_e_outlineFillType_indexes_[7] =
{
  ::e_outlineFillType::asphalt,
  ::e_outlineFillType::cobble,
  ::e_outlineFillType::concrete,
  ::e_outlineFillType::grass,
  ::e_outlineFillType::gravel,
  ::e_outlineFillType::pavement,
  ::e_outlineFillType::soil
};

// e_borderType
//

e_borderType::
e_borderType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_borderType_convert ();
}

e_borderType::
e_borderType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_borderType_convert ();
}

e_borderType::
e_borderType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_borderType_convert ();
}

e_borderType* e_borderType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_borderType (*this, f, c);
}

e_borderType::value e_borderType::
_xsd_e_borderType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_borderType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_borderType_indexes_,
                    _xsd_e_borderType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_borderType_indexes_ + 2 || _xsd_e_borderType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_borderType::
_xsd_e_borderType_literals_[2] =
{
  "concrete",
  "curb"
};

const e_borderType::value e_borderType::
_xsd_e_borderType_indexes_[2] =
{
  ::e_borderType::concrete,
  ::e_borderType::curb
};

// e_contactPoint
//

e_contactPoint::
e_contactPoint (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_contactPoint_convert ();
}

e_contactPoint::
e_contactPoint (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_contactPoint_convert ();
}

e_contactPoint::
e_contactPoint (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_contactPoint_convert ();
}

e_contactPoint* e_contactPoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_contactPoint (*this, f, c);
}

e_contactPoint::value e_contactPoint::
_xsd_e_contactPoint_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_contactPoint_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_contactPoint_indexes_,
                    _xsd_e_contactPoint_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_contactPoint_indexes_ + 2 || _xsd_e_contactPoint_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_contactPoint::
_xsd_e_contactPoint_literals_[2] =
{
  "start",
  "end"
};

const e_contactPoint::value e_contactPoint::
_xsd_e_contactPoint_indexes_[2] =
{
  ::e_contactPoint::end,
  ::e_contactPoint::start
};

// e_elementDir
//

e_elementDir::
e_elementDir (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_elementDir_convert ();
}

e_elementDir::
e_elementDir (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_elementDir_convert ();
}

e_elementDir::
e_elementDir (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_elementDir_convert ();
}

e_elementDir* e_elementDir::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_elementDir (*this, f, c);
}

e_elementDir::value e_elementDir::
_xsd_e_elementDir_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_elementDir_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_elementDir_indexes_,
                    _xsd_e_elementDir_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_elementDir_indexes_ + 2 || _xsd_e_elementDir_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_elementDir::
_xsd_e_elementDir_literals_[2] =
{
  "+",
  "-"
};

const e_elementDir::value e_elementDir::
_xsd_e_elementDir_indexes_[2] =
{
  ::e_elementDir::cxx_,
  ::e_elementDir::cxx_1
};

// e_direction
//

e_direction::
e_direction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_direction_convert ();
}

e_direction::
e_direction (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_direction_convert ();
}

e_direction::
e_direction (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_direction_convert ();
}

e_direction* e_direction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_direction (*this, f, c);
}

e_direction::value e_direction::
_xsd_e_direction_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_direction_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_direction_indexes_,
                    _xsd_e_direction_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_e_direction_indexes_ + 2 || _xsd_e_direction_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_direction::
_xsd_e_direction_literals_[2] =
{
  "same",
  "opposite"
};

const e_direction::value e_direction::
_xsd_e_direction_indexes_[2] =
{
  ::e_direction::opposite,
  ::e_direction::same
};

// e_roadMarkRule
//

e_roadMarkRule::
e_roadMarkRule (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_roadMarkRule_convert ();
}

e_roadMarkRule::
e_roadMarkRule (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_roadMarkRule_convert ();
}

e_roadMarkRule::
e_roadMarkRule (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_roadMarkRule_convert ();
}

e_roadMarkRule* e_roadMarkRule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_roadMarkRule (*this, f, c);
}

e_roadMarkRule::value e_roadMarkRule::
_xsd_e_roadMarkRule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_roadMarkRule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_roadMarkRule_indexes_,
                    _xsd_e_roadMarkRule_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_roadMarkRule_indexes_ + 3 || _xsd_e_roadMarkRule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_roadMarkRule::
_xsd_e_roadMarkRule_literals_[3] =
{
  "no passing",
  "caution",
  "none"
};

const e_roadMarkRule::value e_roadMarkRule::
_xsd_e_roadMarkRule_indexes_[3] =
{
  ::e_roadMarkRule::caution,
  ::e_roadMarkRule::no_passing,
  ::e_roadMarkRule::none
};

// e_orientation
//

e_orientation::
e_orientation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_e_orientation_convert ();
}

e_orientation::
e_orientation (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_e_orientation_convert ();
}

e_orientation::
e_orientation (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_e_orientation_convert ();
}

e_orientation* e_orientation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class e_orientation (*this, f, c);
}

e_orientation::value e_orientation::
_xsd_e_orientation_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_e_orientation_literals_);
  const value* i (::std::lower_bound (
                    _xsd_e_orientation_indexes_,
                    _xsd_e_orientation_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_e_orientation_indexes_ + 3 || _xsd_e_orientation_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const e_orientation::
_xsd_e_orientation_literals_[3] =
{
  "+",
  "-",
  "none"
};

const e_orientation::value e_orientation::
_xsd_e_orientation_indexes_[3] =
{
  ::e_orientation::cxx_,
  ::e_orientation::cxx_1,
  ::e_orientation::none
};

// OpenDRIVE
//

OpenDRIVE::
OpenDRIVE (const header_type& header)
: ::xml_schema::type (),
  header_ (header, this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

OpenDRIVE::
OpenDRIVE (::std::unique_ptr< header_type > header)
: ::xml_schema::type (),
  header_ (std::move (header), this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
}

OpenDRIVE::
OpenDRIVE (const OpenDRIVE& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  road_ (x.road_, f, this),
  controller_ (x.controller_, f, this),
  junction_ (x.junction_, f, this),
  junctionGroup_ (x.junctionGroup_, f, this),
  station_ (x.station_, f, this),
  userData_ (x.userData_, f, this),
  include_ (x.include_, f, this),
  dataQuality_ (x.dataQuality_, f, this)
{
}

OpenDRIVE::
OpenDRIVE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  road_ (this),
  controller_ (this),
  junction_ (this),
  junctionGroup_ (this),
  station_ (this),
  userData_ (this),
  include_ (this),
  dataQuality_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OpenDRIVE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (::std::move (r));
        continue;
      }
    }

    // road
    //
    if (n.name () == "road" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< road_type > r (
        road_traits::create (i, f, this));

      this->road_.push_back (::std::move (r));
      continue;
    }

    // controller
    //
    if (n.name () == "controller" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< controller_type > r (
        controller_traits::create (i, f, this));

      this->controller_.push_back (::std::move (r));
      continue;
    }

    // junction
    //
    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< junction_type > r (
        junction_traits::create (i, f, this));

      this->junction_.push_back (::std::move (r));
      continue;
    }

    // junctionGroup
    //
    if (n.name () == "junctionGroup" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< junctionGroup_type > r (
        junctionGroup_traits::create (i, f, this));

      this->junctionGroup_.push_back (::std::move (r));
      continue;
    }

    // station
    //
    if (n.name () == "station" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< station_type > r (
        station_traits::create (i, f, this));

      this->station_.push_back (::std::move (r));
      continue;
    }

    // userData
    //
    if (n.name () == "userData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< userData_type > r (
        userData_traits::create (i, f, this));

      this->userData_.push_back (::std::move (r));
      continue;
    }

    // include
    //
    if (n.name () == "include" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< include_type > r (
        include_traits::create (i, f, this));

      this->include_.push_back (::std::move (r));
      continue;
    }

    // dataQuality
    //
    if (n.name () == "dataQuality" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dataQuality_type > r (
        dataQuality_traits::create (i, f, this));

      if (!this->dataQuality_)
      {
        this->dataQuality_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }
}

OpenDRIVE* OpenDRIVE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OpenDRIVE (*this, f, c);
}

OpenDRIVE& OpenDRIVE::
operator= (const OpenDRIVE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->road_ = x.road_;
    this->controller_ = x.controller_;
    this->junction_ = x.junction_;
    this->junctionGroup_ = x.junctionGroup_;
    this->station_ = x.station_;
    this->userData_ = x.userData_;
    this->include_ = x.include_;
    this->dataQuality_ = x.dataQuality_;
  }

  return *this;
}

OpenDRIVE::
~OpenDRIVE ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::OpenDRIVE > (
      ::OpenDRIVE_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const t_grEqZero& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_grEqZero& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_grEqZero& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_grZero& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_grZero& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_grZero& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_zeroOne& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_zeroOne& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_zeroOne& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_bool& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_bool& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_bool& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_yesNo& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_yesNo& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_yesNo& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_header_Version& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_header_Version& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_header_Version& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_maxSpeed& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_maxSpeed& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_maxSpeed& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_maxSpeedString& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_maxSpeedString& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_maxSpeedString& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_id& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const t_junction_id& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const t_junction_id& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
OpenDRIVE_ (::std::ostream& o,
            const ::OpenDRIVE& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::OpenDRIVE_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
OpenDRIVE_ (::std::ostream& o,
            const ::OpenDRIVE& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::OpenDRIVE_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
OpenDRIVE_ (::std::ostream& o,
            const ::OpenDRIVE& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::OpenDRIVE_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
OpenDRIVE_ (::xercesc::XMLFormatTarget& t,
            const ::OpenDRIVE& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::OpenDRIVE_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
OpenDRIVE_ (::xercesc::XMLFormatTarget& t,
            const ::OpenDRIVE& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::OpenDRIVE_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
OpenDRIVE_ (::xercesc::XMLFormatTarget& t,
            const ::OpenDRIVE& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::OpenDRIVE_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
OpenDRIVE_ (::xercesc::DOMDocument& d,
            const ::OpenDRIVE& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OpenDRIVE",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
OpenDRIVE_ (const ::OpenDRIVE& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "OpenDRIVE",
      "",
      m, f));

  ::OpenDRIVE_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const t_header& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // geoReference
  //
  if (i.geoReference ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "geoReference",
        e));

    s << *i.geoReference ();
  }

  // offset
  //
  if (i.offset ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "offset",
        e));

    s << *i.offset ();
  }

  // userData
  //
  for (t_header::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_header::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // revMajor
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "revMajor",
        e));

    a << i.revMajor ();
  }

  // revMinor
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "revMinor",
        e));

    a << i.revMinor ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // version
  //
  if (i.version ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "version",
        e));

    a << *i.version ();
  }

  // date
  //
  if (i.date ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "date",
        e));

    a << *i.date ();
  }

  // north
  //
  if (i.north ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "north",
        e));

    a << ::xml_schema::as_double(*i.north ());
  }

  // south
  //
  if (i.south ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "south",
        e));

    a << ::xml_schema::as_double(*i.south ());
  }

  // east
  //
  if (i.east ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "east",
        e));

    a << ::xml_schema::as_double(*i.east ());
  }

  // west
  //
  if (i.west ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "west",
        e));

    a << ::xml_schema::as_double(*i.west ());
  }

  // vendor
  //
  if (i.vendor ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "vendor",
        e));

    a << *i.vendor ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_header_GeoReference& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_header_GeoReference::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_header_GeoReference::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_header_Offset& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_header_Offset::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_header_Offset::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(i.z ());
  }

  // hdg
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hdg",
        e));

    a << i.hdg ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // link
  //
  if (i.link ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "link",
        e));

    s << *i.link ();
  }

  // type
  //
  for (t_road::type_const_iterator
       b (i.type ().begin ()), n (i.type ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << *b;
  }

  // planView
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "planView",
        e));

    s << i.planView ();
  }

  // elevationProfile
  //
  if (i.elevationProfile ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "elevationProfile",
        e));

    s << *i.elevationProfile ();
  }

  // lateralProfile
  //
  if (i.lateralProfile ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lateralProfile",
        e));

    s << *i.lateralProfile ();
  }

  // lanes
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lanes",
        e));

    s << i.lanes ();
  }

  // objects
  //
  if (i.objects ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "objects",
        e));

    s << *i.objects ();
  }

  // signals
  //
  if (i.signals ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "signals",
        e));

    s << *i.signals ();
  }

  // surface
  //
  if (i.surface ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "surface",
        e));

    s << *i.surface ();
  }

  // railroad
  //
  if (i.railroad ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "railroad",
        e));

    s << *i.railroad ();
  }

  // userData
  //
  for (t_road::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // junction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "junction",
        e));

    a << i.junction ();
  }

  // rule
  //
  if (i.rule ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rule",
        e));

    a << *i.rule ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_trafficRule& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_trafficRule& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_trafficRule& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_link& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // predecessor
  //
  if (i.predecessor ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "predecessor",
        e));

    s << *i.predecessor ();
  }

  // successor
  //
  if (i.successor ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "successor",
        e));

    s << *i.successor ();
  }

  // neighbor
  //
  for (t_road_link::neighbor_const_iterator
       b (i.neighbor ().begin ()), n (i.neighbor ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "neighbor",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_link::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_link::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_link_predecessorSuccessor& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_link_predecessorSuccessor::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_link_predecessorSuccessor::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // elementType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementType",
        e));

    a << i.elementType ();
  }

  // elementId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementId",
        e));

    a << i.elementId ();
  }

  // contactPoint
  //
  if (i.contactPoint ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "contactPoint",
        e));

    a << *i.contactPoint ();
  }

  // elementS
  //
  if (i.elementS ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementS",
        e));

    a << *i.elementS ();
  }

  // elementDir
  //
  if (i.elementDir ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementDir",
        e));

    a << *i.elementDir ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_link_elementType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_link_elementType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_link_elementType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_link_neighbor& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_link_neighbor::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_link_neighbor::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // side
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "side",
        e));

    a << i.side ();
  }

  // elementId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementId",
        e));

    a << i.elementId ();
  }

  // direction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "direction",
        e));

    a << i.direction ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_link_neighbor_side& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_link_neighbor_side& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_link_neighbor_side& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // speed
  //
  if (i.speed ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "speed",
        e));

    s << *i.speed ();
  }

  // userData
  //
  for (t_road_type::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_type::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // country
  //
  if (i.country ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "country",
        e));

    a << *i.country ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_type_speed& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_type_speed::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_type_speed::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // max
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << i.fmax ();
  }

  // unit
  //
  if (i.unit ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "unit",
        e));

    a << *i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_planView& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // geometry
  //
  for (t_road_planView::geometry_const_iterator
       b (i.geometry ().begin ()), n (i.geometry ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "geometry",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_planView::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_planView::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_planView_geometry& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // line
  //
  if (i.line ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "line",
        e));

    s << *i.line ();
  }

  // spiral
  //
  if (i.spiral ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spiral",
        e));

    s << *i.spiral ();
  }

  // arc
  //
  if (i.arc ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "arc",
        e));

    s << *i.arc ();
  }

  // poly3
  //
  if (i.poly3 ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "poly3",
        e));

    s << *i.poly3 ();
  }

  // paramPoly3
  //
  if (i.paramPoly3 ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "paramPoly3",
        e));

    s << *i.paramPoly3 ();
  }

  // userData
  //
  for (t_road_planView_geometry::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_planView_geometry::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // hdg
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hdg",
        e));

    a << ::xml_schema::as_double(i.hdg ());
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_planView_geometry_line& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_planView_geometry_line::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_planView_geometry_line::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_planView_geometry_spiral& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_planView_geometry_spiral::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_planView_geometry_spiral::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // curvStart
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "curvStart",
        e));

    a << ::xml_schema::as_double(i.curvStart ());
  }

  // curvEnd
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "curvEnd",
        e));

    a << ::xml_schema::as_double(i.curvEnd ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_planView_geometry_arc& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_planView_geometry_arc::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_planView_geometry_arc::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // curvature
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "curvature",
        e));

    a << ::xml_schema::as_double(i.curvature ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_planView_geometry_poly3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_planView_geometry_poly3::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_planView_geometry_poly3::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_planView_geometry_paramPoly3& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_planView_geometry_paramPoly3::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_planView_geometry_paramPoly3::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // aU
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "aU",
        e));

    a << ::xml_schema::as_double(i.aU ());
  }

  // bU
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "bU",
        e));

    a << ::xml_schema::as_double(i.bU ());
  }

  // cU
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "cU",
        e));

    a << ::xml_schema::as_double(i.cU ());
  }

  // dU
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dU",
        e));

    a << ::xml_schema::as_double(i.dU ());
  }

  // aV
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "aV",
        e));

    a << ::xml_schema::as_double(i.aV ());
  }

  // bV
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "bV",
        e));

    a << ::xml_schema::as_double(i.bV ());
  }

  // cV
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "cV",
        e));

    a << ::xml_schema::as_double(i.cV ());
  }

  // dV
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dV",
        e));

    a << ::xml_schema::as_double(i.dV ());
  }

  // pRange
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "pRange",
        e));

    a << i.pRange ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_paramPoly3_pRange& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_paramPoly3_pRange& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_paramPoly3_pRange& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_elevationProfile& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // elevation
  //
  for (t_road_elevationProfile::elevation_const_iterator
       b (i.elevation ().begin ()), n (i.elevation ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "elevation",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_elevationProfile::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_elevationProfile::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_elevationProfile_elevation& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_elevationProfile_elevation::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_elevationProfile_elevation::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lateralProfile& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // superelevation
  //
  for (t_road_lateralProfile::superelevation_const_iterator
       b (i.superelevation ().begin ()), n (i.superelevation ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "superelevation",
        e));

    s << *b;
  }

  // crossfall
  //
  for (t_road_lateralProfile::crossfall_const_iterator
       b (i.crossfall ().begin ()), n (i.crossfall ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "crossfall",
        e));

    s << *b;
  }

  // shape
  //
  for (t_road_lateralProfile::shape_const_iterator
       b (i.shape ().begin ()), n (i.shape ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shape",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lateralProfile::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lateralProfile::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lateralProfile_superelevation& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lateralProfile_superelevation::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lateralProfile_superelevation::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lateralProfile_crossfall& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lateralProfile_crossfall::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lateralProfile_crossfall::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // side
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "side",
        e));

    a << i.side ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_lateralProfile_crossfall_side& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_lateralProfile_crossfall_side& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_lateralProfile_crossfall_side& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lateralProfile_shape& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lateralProfile_shape::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lateralProfile_shape::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t",
        e));

    a << ::xml_schema::as_double(i.t ());
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // laneOffset
  //
  for (t_road_lanes::laneOffset_const_iterator
       b (i.laneOffset ().begin ()), n (i.laneOffset ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "laneOffset",
        e));

    s << *b;
  }

  // laneSection
  //
  for (t_road_lanes::laneSection_const_iterator
       b (i.laneSection ().begin ()), n (i.laneSection ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "laneSection",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneOffset& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneOffset::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneOffset::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // left
  //
  if (i.left ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "left",
        e));

    s << *i.left ();
  }

  // center
  //
  if (i.center ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "center",
        e));

    s << *i.center ();
  }

  // right
  //
  if (i.right ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "right",
        e));

    s << *i.right ();
  }

  // userData
  //
  for (t_road_lanes_laneSection::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // singleSide
  //
  if (i.singleSide ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "singleSide",
        e));

    a << *i.singleSide ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_left& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // lane
  //
  for (t_road_lanes_laneSection_left::lane_const_iterator
       b (i.lane ().begin ()), n (i.lane ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lane",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_left::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_left::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_center& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // lane
  //
  for (t_road_lanes_laneSection_center::lane_const_iterator
       b (i.lane ().begin ()), n (i.lane ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lane",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_center::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_center::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_right& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // lane
  //
  for (t_road_lanes_laneSection_right::lane_const_iterator
       b (i.lane ().begin ()), n (i.lane ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lane",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_right::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_right::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_center_lane& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // link
  //
  if (i.link ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "link",
        e));

    s << *i.link ();
  }

  // roadMark
  //
  for (t_road_lanes_laneSection_center_lane::roadMark_const_iterator
       b (i.roadMark ().begin ()), n (i.roadMark ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "roadMark",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_center_lane::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_center_lane::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // level
  //
  if (i.level ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "level",
        e));

    a << *i.level ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // link
  //
  if (i.link ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "link",
        e));

    s << *i.link ();
  }

  // width
  //
  for (t_road_lanes_laneSection_lr_lane::width_const_iterator
       b (i.width ().begin ()), n (i.width ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "width",
        e));

    s << *b;
  }

  // border
  //
  for (t_road_lanes_laneSection_lr_lane::border_const_iterator
       b (i.border ().begin ()), n (i.border ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "border",
        e));

    s << *b;
  }

  // roadMark
  //
  for (t_road_lanes_laneSection_lr_lane::roadMark_const_iterator
       b (i.roadMark ().begin ()), n (i.roadMark ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "roadMark",
        e));

    s << *b;
  }

  // material
  //
  for (t_road_lanes_laneSection_lr_lane::material_const_iterator
       b (i.material ().begin ()), n (i.material ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "material",
        e));

    s << *b;
  }

  // visibility
  //
  for (t_road_lanes_laneSection_lr_lane::visibility_const_iterator
       b (i.visibility ().begin ()), n (i.visibility ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "visibility",
        e));

    s << *b;
  }

  // speed
  //
  for (t_road_lanes_laneSection_lr_lane::speed_const_iterator
       b (i.speed ().begin ()), n (i.speed ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "speed",
        e));

    s << *b;
  }

  // access
  //
  for (t_road_lanes_laneSection_lr_lane::access_const_iterator
       b (i.access ().begin ()), n (i.access ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "access",
        e));

    s << *b;
  }

  // height
  //
  for (t_road_lanes_laneSection_lr_lane::height_const_iterator
       b (i.height ().begin ()), n (i.height ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "height",
        e));

    s << *b;
  }

  // rule
  //
  for (t_road_lanes_laneSection_lr_lane::rule_const_iterator
       b (i.rule ().begin ()), n (i.rule ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "rule",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // level
  //
  if (i.level ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "level",
        e));

    a << *i.level ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_left_lane& i)
{
  e << static_cast< const ::t_road_lanes_laneSection_lr_lane& > (i);

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_right_lane& i)
{
  e << static_cast< const ::t_road_lanes_laneSection_lr_lane& > (i);

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_link& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // predecessor
  //
  for (t_road_lanes_laneSection_lcr_lane_link::predecessor_const_iterator
       b (i.predecessor ().begin ()), n (i.predecessor ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "predecessor",
        e));

    s << *b;
  }

  // successor
  //
  for (t_road_lanes_laneSection_lcr_lane_link::successor_const_iterator
       b (i.successor ().begin ()), n (i.successor ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "successor",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_link::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_link::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_width& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_width::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_width::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_border& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_border::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_border::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_roadMark& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // sway
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark::sway_const_iterator
       b (i.sway ().begin ()), n (i.sway ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sway",
        e));

    s << *b;
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << *i.type ();
  }

  // explicit
  //
  if (i.explicit_ ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "explicit",
        e));

    s << *i.explicit_ ();
  }

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type1 ();
  }

  // weight
  //
  if (i.weight ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "weight",
        e));

    a << *i.weight ();
  }

  // color
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "color",
        e));

    a << i.color ();
  }

  // material
  //
  if (i.material ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "material",
        e));

    a << *i.material ();
  }

  // width
  //
  if (i.width ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << *i.width ();
  }

  // laneChange
  //
  if (i.laneChange ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "laneChange",
        e));

    a << *i.laneChange ();
  }

  // height
  //
  if (i.height ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "height",
        e));

    a << ::xml_schema::as_double(*i.height ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_roadMark_sway& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_sway::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_sway::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // ds
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ds",
        e));

    a << i.ds ();
  }

  // a
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "a",
        e));

    a << ::xml_schema::as_double(i.a ());
  }

  // b
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "b",
        e));

    a << ::xml_schema::as_double(i.b ());
  }

  // c
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "c",
        e));

    a << ::xml_schema::as_double(i.c ());
  }

  // d
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "d",
        e));

    a << ::xml_schema::as_double(i.d ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_roadMark_type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // line
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_type::line_const_iterator
       b (i.line ().begin ()), n (i.line ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "line",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_type::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_type::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // width
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << i.width ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_roadMark_type_line& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_type_line::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_type_line::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }

  // space
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "space",
        e));

    a << i.space ();
  }

  // tOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "tOffset",
        e));

    a << ::xml_schema::as_double(i.tOffset ());
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // rule
  //
  if (i.rule ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rule",
        e));

    a << *i.rule ();
  }

  // width
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << i.width ();
  }

  // color
  //
  if (i.color ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "color",
        e));

    a << *i.color ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_roadMark_explicit& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // line
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_explicit::line_const_iterator
       b (i.line ().begin ()), n (i.line ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "line",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_explicit::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_explicit::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }

  // tOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "tOffset",
        e));

    a << ::xml_schema::as_double(i.tOffset ());
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // rule
  //
  if (i.rule ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rule",
        e));

    a << *i.rule ();
  }

  // width
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << i.width ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_material& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_material::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_material::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // surface
  //
  if (i.surface ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "surface",
        e));

    a << *i.surface ();
  }

  // friction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "friction",
        e));

    a << i.friction ();
  }

  // roughness
  //
  if (i.roughness ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roughness",
        e));

    a << *i.roughness ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_visibility& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_visibility::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_visibility::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // forward
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "forward",
        e));

    a << i.forward ();
  }

  // back
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "back",
        e));

    a << i.back ();
  }

  // left
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "left",
        e));

    a << i.left ();
  }

  // right
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "right",
        e));

    a << i.right ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_speed& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_speed::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_speed::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // max
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << i.fmax ();
  }

  // unit
  //
  if (i.unit ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "unit",
        e));

    a << *i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_access& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_access::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_access::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // rule
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rule",
        e));

    a << i.rule ();
  }

  // restriction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "restriction",
        e));

    a << i.restriction ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_lanes_laneSection_lr_lane_access_rule& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_lanes_laneSection_lr_lane_access_rule& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_lanes_laneSection_lr_lane_access_rule& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_height& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_height::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_height::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // inner
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "inner",
        e));

    a << ::xml_schema::as_double(i.inner ());
  }

  // outer
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "outer",
        e));

    a << ::xml_schema::as_double(i.outer ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_lanes_laneSection_lr_lane_rule& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_lanes_laneSection_lr_lane_rule::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_lanes_laneSection_lr_lane_rule::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // sOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << i.sOffset ();
  }

  // value
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << i.value ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // object
  //
  for (t_road_objects::object_const_iterator
       b (i.object ().begin ()), n (i.object ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "object",
        e));

    s << *b;
  }

  // objectReference
  //
  for (t_road_objects::objectReference_const_iterator
       b (i.objectReference ().begin ()), n (i.objectReference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "objectReference",
        e));

    s << *b;
  }

  // tunnel
  //
  for (t_road_objects::tunnel_const_iterator
       b (i.tunnel ().begin ()), n (i.tunnel ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tunnel",
        e));

    s << *b;
  }

  // bridge
  //
  for (t_road_objects::bridge_const_iterator
       b (i.bridge ().begin ()), n (i.bridge ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "bridge",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // repeat
  //
  if (i.repeat ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "repeat",
        e));

    s << *i.repeat ();
  }

  // outline
  //
  if (i.outline ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "outline",
        e));

    s << *i.outline ();
  }

  // outlines
  //
  if (i.outlines ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "outlines",
        e));

    s << *i.outlines ();
  }

  // material
  //
  for (t_road_objects_object::material_const_iterator
       b (i.material ().begin ()), n (i.material ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "material",
        e));

    s << *b;
  }

  // validity
  //
  for (t_road_objects_object::validity_const_iterator
       b (i.validity ().begin ()), n (i.validity ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "validity",
        e));

    s << *b;
  }

  // parkingSpace
  //
  if (i.parkingSpace ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "parkingSpace",
        e));

    s << *i.parkingSpace ();
  }

  // markings
  //
  if (i.markings ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "markings",
        e));

    s << *i.markings ();
  }

  // borders
  //
  if (i.borders ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "borders",
        e));

    s << *i.borders ();
  }

  // userData
  //
  for (t_road_objects_object::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }

  // subtype
  //
  if (i.subtype ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "subtype",
        e));

    a << *i.subtype ();
  }

  // dynamic
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dynamic",
        e));

    a << i.dynamic ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t",
        e));

    a << ::xml_schema::as_double(i.t ());
  }

  // zOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffset",
        e));

    a << ::xml_schema::as_double(i.zOffset ());
  }

  // validLength
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "validLength",
        e));

    a << i.validLength ();
  }

  // orientation
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "orientation",
        e));

    a << i.orientation ();
  }

  // hdg
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hdg",
        e));

    a << ::xml_schema::as_double(i.hdg ());
  }

  // pitch
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "pitch",
        e));

    a << ::xml_schema::as_double(i.pitch ());
  }

  // roll
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roll",
        e));

    a << ::xml_schema::as_double(i.roll ());
  }

  // height
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "height",
        e));

    a << ::xml_schema::as_double(i.height ());
  }

  // length
  //
  if (i.length ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << ::xml_schema::as_double(*i.length ());
  }

  // width
  //
  if (i.width ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << ::xml_schema::as_double(*i.width ());
  }

  // radius
  //
  if (i.radius ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "radius",
        e));

    a << ::xml_schema::as_double(*i.radius ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_repeat& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_objects_object_repeat::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_repeat::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }

  // distance
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "distance",
        e));

    a << i.distance ();
  }

  // tStart
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "tStart",
        e));

    a << ::xml_schema::as_double(i.tStart ());
  }

  // tEnd
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "tEnd",
        e));

    a << ::xml_schema::as_double(i.tEnd ());
  }

  // heightStart
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "heightStart",
        e));

    a << ::xml_schema::as_double(i.heightStart ());
  }

  // heightEnd
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "heightEnd",
        e));

    a << ::xml_schema::as_double(i.heightEnd ());
  }

  // zOffsetStart
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffsetStart",
        e));

    a << ::xml_schema::as_double(i.zOffsetStart ());
  }

  // zOffsetEnd
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffsetEnd",
        e));

    a << ::xml_schema::as_double(i.zOffsetEnd ());
  }

  // widthStart
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "widthStart",
        e));

    a << i.widthStart ();
  }

  // widthEnd
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "widthEnd",
        e));

    a << i.widthEnd ();
  }

  // lengthStart
  //
  if (i.lengthStart ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "lengthStart",
        e));

    a << *i.lengthStart ();
  }

  // lengthEnd
  //
  if (i.lengthEnd ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "lengthEnd",
        e));

    a << *i.lengthEnd ();
  }

  // radiusStart
  //
  if (i.radiusStart ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "radiusStart",
        e));

    a << *i.radiusStart ();
  }

  // radiusEnd
  //
  if (i.radiusEnd ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "radiusEnd",
        e));

    a << *i.radiusEnd ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_outlines& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // outline
  //
  for (t_road_objects_object_outlines::outline_const_iterator
       b (i.outline ().begin ()), n (i.outline ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "outline",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_object_outlines::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_outlines::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_outlines_outline& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // cornerRoad
  //
  for (t_road_objects_object_outlines_outline::cornerRoad_const_iterator
       b (i.cornerRoad ().begin ()), n (i.cornerRoad ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cornerRoad",
        e));

    s << *b;
  }

  // cornerLocal
  //
  for (t_road_objects_object_outlines_outline::cornerLocal_const_iterator
       b (i.cornerLocal ().begin ()), n (i.cornerLocal ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cornerLocal",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_object_outlines_outline::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_outlines_outline::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // fillType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "fillType",
        e));

    a << i.fillType ();
  }

  // outer
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "outer",
        e));

    a << i.outer ();
  }

  // closed
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "closed",
        e));

    a << i.closed ();
  }

  // laneType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "laneType",
        e));

    a << i.laneType ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_outlines_outline_cornerRoad& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_objects_object_outlines_outline_cornerRoad::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_outlines_outline_cornerRoad::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t",
        e));

    a << ::xml_schema::as_double(i.t ());
  }

  // dz
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dz",
        e));

    a << ::xml_schema::as_double(i.dz ());
  }

  // height
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "height",
        e));

    a << ::xml_schema::as_double(i.height ());
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_outlines_outline_cornerLocal& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_objects_object_outlines_outline_cornerLocal::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_outlines_outline_cornerLocal::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // u
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "u",
        e));

    a << ::xml_schema::as_double(i.u ());
  }

  // v
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "v",
        e));

    a << ::xml_schema::as_double(i.v ());
  }

  // z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(i.z ());
  }

  // height
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "height",
        e));

    a << ::xml_schema::as_double(i.height ());
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_material& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_objects_object_material::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_material::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // surface
  //
  if (i.surface ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "surface",
        e));

    a << *i.surface ();
  }

  // friction
  //
  if (i.friction ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "friction",
        e));

    a << *i.friction ();
  }

  // roughness
  //
  if (i.roughness ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roughness",
        e));

    a << *i.roughness ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_laneValidity& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_objects_object_laneValidity::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_laneValidity::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // fromLane
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "fromLane",
        e));

    a << i.fromLane ();
  }

  // toLane
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "toLane",
        e));

    a << i.toLane ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_parkingSpace& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_objects_object_parkingSpace::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_parkingSpace::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // access
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "access",
        e));

    a << i.access ();
  }

  // restrictions
  //
  if (i.restrictions ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "restrictions",
        e));

    a << *i.restrictions ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_objects_object_parkingSpace_access& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_objects_object_parkingSpace_access& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_objects_object_parkingSpace_access& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_markings& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // marking
  //
  for (t_road_objects_object_markings::marking_const_iterator
       b (i.marking ().begin ()), n (i.marking ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "marking",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_object_markings::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_markings::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_markings_marking& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // cornerReference
  //
  for (t_road_objects_object_markings_marking::cornerReference_const_iterator
       b (i.cornerReference ().begin ()), n (i.cornerReference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cornerReference",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_object_markings_marking::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_markings_marking::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // side
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "side",
        e));

    a << i.side ();
  }

  // weight
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "weight",
        e));

    a << i.weight ();
  }

  // width
  //
  if (i.width ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << *i.width ();
  }

  // color
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "color",
        e));

    a << i.color ();
  }

  // zOffset
  //
  if (i.zOffset ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffset",
        e));

    a << *i.zOffset ();
  }

  // spaceLength
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "spaceLength",
        e));

    a << i.spaceLength ();
  }

  // lineLength
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "lineLength",
        e));

    a << i.lineLength ();
  }

  // startOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "startOffset",
        e));

    a << ::xml_schema::as_double(i.startOffset ());
  }

  // stopOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "stopOffset",
        e));

    a << ::xml_schema::as_double(i.stopOffset ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_markings_marking_cornerReference& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_objects_object_markings_marking_cornerReference::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_markings_marking_cornerReference::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_borders& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // border
  //
  for (t_road_objects_object_borders::border_const_iterator
       b (i.border ().begin ()), n (i.border ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "border",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_object_borders::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_borders::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_object_borders_border& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // cornerReference
  //
  for (t_road_objects_object_borders_border::cornerReference_const_iterator
       b (i.cornerReference ().begin ()), n (i.cornerReference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cornerReference",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_object_borders_border::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_object_borders_border::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // width
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << i.width ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // outlineId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "outlineId",
        e));

    a << i.outlineId ();
  }

  // useCompleteOutline
  //
  if (i.useCompleteOutline ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "useCompleteOutline",
        e));

    a << *i.useCompleteOutline ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_objectReference& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // validity
  //
  for (t_road_objects_objectReference::validity_const_iterator
       b (i.validity ().begin ()), n (i.validity ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "validity",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_objectReference::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_objectReference::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t",
        e));

    a << ::xml_schema::as_double(i.t ());
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // zOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffset",
        e));

    a << ::xml_schema::as_double(i.zOffset ());
  }

  // validLength
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "validLength",
        e));

    a << i.validLength ();
  }

  // orientation
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "orientation",
        e));

    a << i.orientation ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_tunnel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // validity
  //
  for (t_road_objects_tunnel::validity_const_iterator
       b (i.validity ().begin ()), n (i.validity ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "validity",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_tunnel::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_tunnel::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // lighting
  //
  if (i.lighting ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "lighting",
        e));

    a << *i.lighting ();
  }

  // daylight
  //
  if (i.daylight ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "daylight",
        e));

    a << *i.daylight ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_objects_bridge& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // validity
  //
  for (t_road_objects_bridge::validity_const_iterator
       b (i.validity ().begin ()), n (i.validity ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "validity",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_objects_bridge::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_objects_bridge::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_signals& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // signal
  //
  for (t_road_signals::signal_const_iterator
       b (i.signal ().begin ()), n (i.signal ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "signal",
        e));

    s << *b;
  }

  // signalReference
  //
  for (t_road_signals::signalReference_const_iterator
       b (i.signalReference ().begin ()), n (i.signalReference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "signalReference",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_signals::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_signals::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_signals_signal& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // validity
  //
  for (t_road_signals_signal::validity_const_iterator
       b (i.validity ().begin ()), n (i.validity ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "validity",
        e));

    s << *b;
  }

  // dependency
  //
  for (t_road_signals_signal::dependency_const_iterator
       b (i.dependency ().begin ()), n (i.dependency ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dependency",
        e));

    s << *b;
  }

  // reference
  //
  for (t_road_signals_signal::reference_const_iterator
       b (i.reference ().begin ()), n (i.reference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "reference",
        e));

    s << *b;
  }

  // positionRoad
  //
  if (i.positionRoad ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "positionRoad",
        e));

    s << *i.positionRoad ();
  }

  // positionInertial
  //
  if (i.positionInertial ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "positionInertial",
        e));

    s << *i.positionInertial ();
  }

  // userData
  //
  for (t_road_signals_signal::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_signals_signal::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t",
        e));

    a << ::xml_schema::as_double(i.t ());
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // dynamic
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dynamic",
        e));

    a << i.dynamic ();
  }

  // orientation
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "orientation",
        e));

    a << i.orientation ();
  }

  // zOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffset",
        e));

    a << ::xml_schema::as_double(i.zOffset ());
  }

  // country
  //
  if (i.country ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "country",
        e));

    a << *i.country ();
  }

  // countryRevision
  //
  if (i.countryRevision ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "countryRevision",
        e));

    a << *i.countryRevision ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // subtype
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "subtype",
        e));

    a << i.subtype ();
  }

  // value
  //
  if (i.value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << ::xml_schema::as_double(*i.value ());
  }

  // unit
  //
  if (i.unit ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "unit",
        e));

    a << *i.unit ();
  }

  // height
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "height",
        e));

    a << i.height ();
  }

  // width
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "width",
        e));

    a << i.width ();
  }

  // text
  //
  if (i.text ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "text",
        e));

    a << *i.text ();
  }

  // hOffset
  //
  if (i.hOffset ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hOffset",
        e));

    a << ::xml_schema::as_double(*i.hOffset ());
  }

  // pitch
  //
  if (i.pitch ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "pitch",
        e));

    a << ::xml_schema::as_double(*i.pitch ());
  }

  // roll
  //
  if (i.roll ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roll",
        e));

    a << ::xml_schema::as_double(*i.roll ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_signals_signal_dependency& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_signals_signal_dependency::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_signals_signal_dependency::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_signals_signal_reference& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_signals_signal_reference::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_signals_signal_reference::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // elementType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementType",
        e));

    a << i.elementType ();
  }

  // elementId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementId",
        e));

    a << i.elementId ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_signals_signal_reference_elementType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_signals_signal_reference_elementType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_signals_signal_reference_elementType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_signals_signal_positionRoad& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_signals_signal_positionRoad::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_signals_signal_positionRoad::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // roadId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roadId",
        e));

    a << i.roadId ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t",
        e));

    a << ::xml_schema::as_double(i.t ());
  }

  // zOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffset",
        e));

    a << ::xml_schema::as_double(i.zOffset ());
  }

  // hOffset
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hOffset",
        e));

    a << ::xml_schema::as_double(i.hOffset ());
  }

  // pitch
  //
  if (i.pitch ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "pitch",
        e));

    a << ::xml_schema::as_double(*i.pitch ());
  }

  // roll
  //
  if (i.roll ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roll",
        e));

    a << ::xml_schema::as_double(*i.roll ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_signals_signal_positionInertial& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_signals_signal_positionInertial::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_signals_signal_positionInertial::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(i.z ());
  }

  // hdg
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hdg",
        e));

    a << ::xml_schema::as_double(i.hdg ());
  }

  // pitch
  //
  if (i.pitch ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "pitch",
        e));

    a << ::xml_schema::as_double(*i.pitch ());
  }

  // roll
  //
  if (i.roll ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roll",
        e));

    a << ::xml_schema::as_double(*i.roll ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_signals_signalReference& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // validity
  //
  for (t_road_signals_signalReference::validity_const_iterator
       b (i.validity ().begin ()), n (i.validity ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "validity",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_signals_signalReference::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_signals_signalReference::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t",
        e));

    a << ::xml_schema::as_double(i.t ());
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // orientation
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "orientation",
        e));

    a << i.orientation ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_surface& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // CRG
  //
  for (t_road_surface::CRG_const_iterator
       b (i.CRG ().begin ()), n (i.CRG ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CRG",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_surface::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_surface::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_surface_CRG& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_surface_CRG::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_surface_CRG::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // file
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "file",
        e));

    a << i.file ();
  }

  // sStart
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sStart",
        e));

    a << i.sStart ();
  }

  // sEnd
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sEnd",
        e));

    a << i.sEnd ();
  }

  // orientation
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "orientation",
        e));

    a << i.orientation ();
  }

  // mode
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mode",
        e));

    a << i.mode ();
  }

  // purpose
  //
  if (i.purpose ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "purpose",
        e));

    a << *i.purpose ();
  }

  // sOffset
  //
  if (i.sOffset ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sOffset",
        e));

    a << ::xml_schema::as_double(*i.sOffset ());
  }

  // tOffset
  //
  if (i.tOffset ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "tOffset",
        e));

    a << ::xml_schema::as_double(*i.tOffset ());
  }

  // zOffset
  //
  if (i.zOffset ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffset",
        e));

    a << ::xml_schema::as_double(*i.zOffset ());
  }

  // zScale
  //
  if (i.zScale ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zScale",
        e));

    a << ::xml_schema::as_double(*i.zScale ());
  }

  // hOffset
  //
  if (i.hOffset ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "hOffset",
        e));

    a << ::xml_schema::as_double(*i.hOffset ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_surface_CRG_purpose& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_surface_CRG_purpose& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_surface_CRG_purpose& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_road_surface_CRG_mode& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_surface_CRG_mode& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_surface_CRG_mode& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_railroad& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // switch
  //
  for (t_road_railroad::switch_const_iterator
       b (i.switch_ ().begin ()), n (i.switch_ ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "switch",
        e));

    s << *b;
  }

  // userData
  //
  for (t_road_railroad::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_railroad::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_railroad_switch& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // mainTrack
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mainTrack",
        e));

    s << i.mainTrack ();
  }

  // sideTrack
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sideTrack",
        e));

    s << i.sideTrack ();
  }

  // partner
  //
  if (i.partner ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "partner",
        e));

    s << *i.partner ();
  }

  // userData
  //
  for (t_road_railroad_switch::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_railroad_switch::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // position
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "position",
        e));

    a << i.position ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_road_railroad_switch_position& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_road_railroad_switch_position& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_road_railroad_switch_position& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_road_railroad_switch_mainTrack& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_railroad_switch_mainTrack::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_railroad_switch_mainTrack::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // dir
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dir",
        e));

    a << i.dir ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_railroad_switch_sideTrack& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_railroad_switch_sideTrack::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_railroad_switch_sideTrack::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // s
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "s",
        e));

    a << i.s ();
  }

  // dir
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dir",
        e));

    a << i.dir ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_road_railroad_switch_partner& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_road_railroad_switch_partner::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_road_railroad_switch_partner::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_controller& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // control
  //
  for (t_controller::control_const_iterator
       b (i.control ().begin ()), n (i.control ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "control",
        e));

    s << *b;
  }

  // userData
  //
  for (t_controller::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_controller::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // sequence
  //
  if (i.sequence ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sequence",
        e));

    a << *i.sequence ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_controller_control& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_controller_control::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_controller_control::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // signalId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "signalId",
        e));

    a << i.signalId ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junction& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // connection
  //
  for (t_junction::connection_const_iterator
       b (i.connection ().begin ()), n (i.connection ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "connection",
        e));

    s << *b;
  }

  // priority
  //
  for (t_junction::priority_const_iterator
       b (i.priority ().begin ()), n (i.priority ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "priority",
        e));

    s << *b;
  }

  // controller
  //
  for (t_junction::controller_const_iterator
       b (i.controller ().begin ()), n (i.controller ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "controller",
        e));

    s << *b;
  }

  // surface
  //
  if (i.surface ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "surface",
        e));

    s << *i.surface ();
  }

  // userData
  //
  for (t_junction::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_junction_type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_junction_type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_junction_type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_connection& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // predecessor
  //
  if (i.predecessor ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "predecessor",
        e));

    s << *i.predecessor ();
  }

  // successor
  //
  if (i.successor ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "successor",
        e));

    s << *i.successor ();
  }

  // laneLink
  //
  for (t_junction_connection::laneLink_const_iterator
       b (i.laneLink ().begin ()), n (i.laneLink ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "laneLink",
        e));

    s << *b;
  }

  // userData
  //
  for (t_junction_connection::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction_connection::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // incomingRoad
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "incomingRoad",
        e));

    a << i.incomingRoad ();
  }

  // connectingRoad
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "connectingRoad",
        e));

    a << i.connectingRoad ();
  }

  // contactPoint
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "contactPoint",
        e));

    a << i.contactPoint ();
  }

  // connectionMaster
  //
  if (i.connectionMaster ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "connectionMaster",
        e));

    a << *i.connectionMaster ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_predecessorSuccessor& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_junction_predecessorSuccessor::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction_predecessorSuccessor::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // elementType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementType",
        e));

    a << i.elementType ();
  }

  // elementId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementId",
        e));

    a << i.elementId ();
  }

  // elementS
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementS",
        e));

    a << i.elementS ();
  }

  // elementDir
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "elementDir",
        e));

    a << i.elementDir ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_connection_laneLink& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_junction_connection_laneLink::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction_connection_laneLink::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // from
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "from",
        e));

    a << i.from ();
  }

  // to
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "to",
        e));

    a << i.to ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_priority& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_junction_priority::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction_priority::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // high
  //
  if (i.high ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "high",
        e));

    a << *i.high ();
  }

  // low
  //
  if (i.low ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "low",
        e));

    a << *i.low ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_controller& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_junction_controller::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction_controller::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }

  // sequence
  //
  if (i.sequence ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sequence",
        e));

    a << *i.sequence ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_surface& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // CRG
  //
  for (t_junction_surface::CRG_const_iterator
       b (i.CRG ().begin ()), n (i.CRG ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CRG",
        e));

    s << *b;
  }

  // userData
  //
  for (t_junction_surface::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction_surface::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junction_surface_CRG& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_junction_surface_CRG::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junction_surface_CRG::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // file
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "file",
        e));

    a << i.file ();
  }

  // mode
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mode",
        e));

    a << i.mode ();
  }

  // purpose
  //
  if (i.purpose ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "purpose",
        e));

    a << *i.purpose ();
  }

  // zOffset
  //
  if (i.zOffset ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zOffset",
        e));

    a << ::xml_schema::as_double(*i.zOffset ());
  }

  // zScale
  //
  if (i.zScale ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zScale",
        e));

    a << ::xml_schema::as_double(*i.zScale ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_junctionGroup& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // junctionReference
  //
  for (t_junctionGroup::junctionReference_const_iterator
       b (i.junctionReference ().begin ()), n (i.junctionReference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "junctionReference",
        e));

    s << *b;
  }

  // userData
  //
  for (t_junctionGroup::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junctionGroup::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_junctionGroup_type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_junctionGroup_type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_junctionGroup_type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_junctionGroup_junctionReference& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_junctionGroup_junctionReference::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_junctionGroup_junctionReference::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // junction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "junction",
        e));

    a << i.junction ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_station& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // platform
  //
  for (t_station::platform_const_iterator
       b (i.platform ().begin ()), n (i.platform ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "platform",
        e));

    s << *b;
  }

  // userData
  //
  for (t_station::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_station::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << *i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_station_type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_station_type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_station_type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_station_platform& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // segment
  //
  for (t_station_platform::segment_const_iterator
       b (i.segment ().begin ()), n (i.segment ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "segment",
        e));

    s << *b;
  }

  // userData
  //
  for (t_station_platform::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_station_platform::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // name
  //
  if (i.name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << *i.name ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_station_platform_segment& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // userData
  //
  for (t_station_platform_segment::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (t_station_platform_segment::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }

  // roadId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "roadId",
        e));

    a << i.roadId ();
  }

  // sStart
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sStart",
        e));

    a << i.sStart ();
  }

  // sEnd
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sEnd",
        e));

    a << i.sEnd ();
  }

  // side
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "side",
        e));

    a << i.side ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_station_platform_segment_side& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_station_platform_segment_side& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_station_platform_segment_side& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const t_userData& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // code
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "code",
        e));

    a << i.code ();
  }

  // value
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << i.value ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_include& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // file
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "file",
        e));

    a << i.file ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_dataQuality& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // error
  //
  if (i.error ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "error",
        e));

    s << *i.error ();
  }

  // rawData
  //
  if (i.rawData ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "rawData",
        e));

    s << *i.rawData ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_dataQuality_Error& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // xyAbsolute
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xyAbsolute",
        e));

    a << ::xml_schema::as_double(i.xyAbsolute ());
  }

  // zAbsolute
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zAbsolute",
        e));

    a << ::xml_schema::as_double(i.zAbsolute ());
  }

  // xyRelative
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xyRelative",
        e));

    a << ::xml_schema::as_double(i.xyRelative ());
  }

  // zRelative
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zRelative",
        e));

    a << ::xml_schema::as_double(i.zRelative ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const t_dataQuality_RawData& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // date
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "date",
        e));

    a << i.date ();
  }

  // source
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "source",
        e));

    a << i.source ();
  }

  // sourceComment
  //
  if (i.sourceComment ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sourceComment",
        e));

    a << *i.sourceComment ();
  }

  // postProcessing
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "postProcessing",
        e));

    a << i.postProcessing ();
  }

  // postProcessingComment
  //
  if (i.postProcessingComment ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "postProcessingComment",
        e));

    a << *i.postProcessingComment ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const e_dataQuality_RawData_Source& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_dataQuality_RawData_Source& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_dataQuality_RawData_Source& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_dataQuality_RawData_PostProcessing& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_dataQuality_RawData_PostProcessing& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_dataQuality_RawData_PostProcessing& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_unitDistance& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_unitDistance& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_unitDistance& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_unitSpeed& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_unitSpeed& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_unitSpeed& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_unitMass& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_unitMass& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_unitMass& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_unitSlope& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_unitSlope& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_unitSlope& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_unit& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_unit& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_unit& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_roadType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_roadType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_roadType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_roadMarkType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_roadMarkType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_roadMarkType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_roadMarkWeight& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_roadMarkWeight& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_roadMarkWeight& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_roadMarkColor& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_roadMarkColor& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_roadMarkColor& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_laneType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_laneType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_laneType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_objectType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_objectType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_objectType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_tunnelType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_tunnelType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_tunnelType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_bridgeType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_bridgeType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_bridgeType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_accessRestrictionType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_accessRestrictionType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_accessRestrictionType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_countryCode& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_countryCode& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_countryCode& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_countryCode_deprecated& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_countryCode_deprecated& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_countryCode_deprecated& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_countryCode_iso3166alpha3& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_countryCode_iso3166alpha3& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_countryCode_iso3166alpha3& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_sideType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_sideType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_sideType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_outlineFillType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_outlineFillType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_outlineFillType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_borderType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_borderType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_borderType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_contactPoint& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_contactPoint& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_contactPoint& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_elementDir& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_elementDir& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_elementDir& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_direction& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_direction& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_direction& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_roadMarkRule& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_roadMarkRule& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_roadMarkRule& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const e_orientation& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const e_orientation& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const e_orientation& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const OpenDRIVE& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // header
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "header",
        e));

    s << i.header ();
  }

  // road
  //
  for (OpenDRIVE::road_const_iterator
       b (i.road ().begin ()), n (i.road ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "road",
        e));

    s << *b;
  }

  // controller
  //
  for (OpenDRIVE::controller_const_iterator
       b (i.controller ().begin ()), n (i.controller ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "controller",
        e));

    s << *b;
  }

  // junction
  //
  for (OpenDRIVE::junction_const_iterator
       b (i.junction ().begin ()), n (i.junction ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "junction",
        e));

    s << *b;
  }

  // junctionGroup
  //
  for (OpenDRIVE::junctionGroup_const_iterator
       b (i.junctionGroup ().begin ()), n (i.junctionGroup ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "junctionGroup",
        e));

    s << *b;
  }

  // station
  //
  for (OpenDRIVE::station_const_iterator
       b (i.station ().begin ()), n (i.station ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "station",
        e));

    s << *b;
  }

  // userData
  //
  for (OpenDRIVE::userData_const_iterator
       b (i.userData ().begin ()), n (i.userData ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "userData",
        e));

    s << *b;
  }

  // include
  //
  for (OpenDRIVE::include_const_iterator
       b (i.include ().begin ()), n (i.include ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "include",
        e));

    s << *b;
  }

  // dataQuality
  //
  if (i.dataQuality ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dataQuality",
        e));

    s << *i.dataQuality ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

