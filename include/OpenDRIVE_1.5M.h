// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef OPEN_DRIVE_1_5M_H
#define OPEN_DRIVE_1_5M_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class t_grEqZero;
class t_grZero;
class t_zeroOne;
class t_bool;
class t_yesNo;
class t_header_Version;
class t_maxSpeed;
class e_maxSpeedString;
class t_junction_id;
class t_header;
class t_header_GeoReference;
class t_header_Offset;
class t_road;
class e_trafficRule;
class t_road_link;
class t_road_link_predecessorSuccessor;
class e_road_link_elementType;
class t_road_link_neighbor;
class e_road_link_neighbor_side;
class t_road_type;
class t_road_type_speed;
class t_road_planView;
class t_road_planView_geometry;
class t_road_planView_geometry_line;
class t_road_planView_geometry_spiral;
class t_road_planView_geometry_arc;
class t_road_planView_geometry_poly3;
class t_road_planView_geometry_paramPoly3;
class e_paramPoly3_pRange;
class t_road_elevationProfile;
class t_road_elevationProfile_elevation;
class t_road_lateralProfile;
class t_road_lateralProfile_superelevation;
class t_road_lateralProfile_crossfall;
class e_road_lateralProfile_crossfall_side;
class t_road_lateralProfile_shape;
class t_road_lanes;
class t_road_lanes_laneOffset;
class t_road_lanes_laneSection;
class t_road_lanes_laneSection_left;
class t_road_lanes_laneSection_center;
class t_road_lanes_laneSection_right;
class t_road_lanes_laneSection_center_lane;
class t_road_lanes_laneSection_lr_lane;
class t_road_lanes_laneSection_left_lane;
class t_road_lanes_laneSection_right_lane;
class t_road_lanes_laneSection_lcr_lane_link;
class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor;
class t_road_lanes_laneSection_lr_lane_width;
class t_road_lanes_laneSection_lr_lane_border;
class t_road_lanes_laneSection_lcr_lane_roadMark;
class e_road_lanes_laneSection_lcr_lane_roadMark_laneChange;
class t_road_lanes_laneSection_lcr_lane_roadMark_sway;
class t_road_lanes_laneSection_lcr_lane_roadMark_type;
class t_road_lanes_laneSection_lcr_lane_roadMark_type_line;
class t_road_lanes_laneSection_lcr_lane_roadMark_explicit;
class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line;
class t_road_lanes_laneSection_lr_lane_material;
class t_road_lanes_laneSection_lr_lane_visibility;
class t_road_lanes_laneSection_lr_lane_speed;
class t_road_lanes_laneSection_lr_lane_access;
class e_road_lanes_laneSection_lr_lane_access_rule;
class t_road_lanes_laneSection_lr_lane_height;
class t_road_lanes_laneSection_lr_lane_rule;
class t_road_objects;
class t_road_objects_object;
class t_road_objects_object_repeat;
class t_road_objects_object_outlines;
class t_road_objects_object_outlines_outline;
class t_road_objects_object_outlines_outline_cornerRoad;
class t_road_objects_object_outlines_outline_cornerLocal;
class t_road_objects_object_material;
class t_road_objects_object_laneValidity;
class t_road_objects_object_parkingSpace;
class e_road_objects_object_parkingSpace_access;
class t_road_objects_object_markings;
class t_road_objects_object_markings_marking;
class t_road_objects_object_markings_marking_cornerReference;
class t_road_objects_object_borders;
class t_road_objects_object_borders_border;
class t_road_objects_objectReference;
class t_road_objects_tunnel;
class t_road_objects_bridge;
class t_road_signals;
class t_road_signals_signal;
class t_road_signals_signal_dependency;
class t_road_signals_signal_reference;
class e_road_signals_signal_reference_elementType;
class t_road_signals_signal_positionRoad;
class t_road_signals_signal_positionInertial;
class t_road_signals_signalReference;
class t_road_surface;
class t_road_surface_CRG;
class e_road_surface_CRG_purpose;
class e_road_surface_CRG_mode;
class t_road_railroad;
class t_road_railroad_switch;
class e_road_railroad_switch_position;
class t_road_railroad_switch_mainTrack;
class t_road_railroad_switch_sideTrack;
class t_road_railroad_switch_partner;
class t_controller;
class t_controller_control;
class t_junction;
class e_junction_type;
class t_junction_connection;
class t_junction_predecessorSuccessor;
class t_junction_connection_laneLink;
class t_junction_priority;
class t_junction_controller;
class t_junction_surface;
class t_junction_surface_CRG;
class t_junctionGroup;
class e_junctionGroup_type;
class t_junctionGroup_junctionReference;
class t_station;
class e_station_type;
class t_station_platform;
class t_station_platform_segment;
class e_station_platform_segment_side;
class t_userData;
class t_include;
class t_dataQuality;
class t_dataQuality_Error;
class t_dataQuality_RawData;
class e_dataQuality_RawData_Source;
class e_dataQuality_RawData_PostProcessing;
class e_unitDistance;
class e_unitSpeed;
class e_unitMass;
class e_unitSlope;
class e_unit;
class e_roadType;
class e_roadMarkType;
class e_roadMarkWeight;
class e_roadMarkColor;
class e_laneType;
class e_objectType;
class e_tunnelType;
class e_bridgeType;
class e_accessRestrictionType;
class e_countryCode;
class e_countryCode_deprecated;
class e_countryCode_iso3166alpha3;
class e_sideType;
class e_outlineFillType;
class e_borderType;
class e_contactPoint;
class e_elementDir;
class e_direction;
class e_roadMarkRule;
class e_orientation;
class OpenDRIVE;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class t_grEqZero: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  t_grEqZero (const ::xml_schema::double_&);

  t_grEqZero (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_grEqZero (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_grEqZero (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_grEqZero (const t_grEqZero& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual t_grEqZero*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_grEqZero ();
};

class t_grZero: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  t_grZero (const ::xml_schema::double_&);

  t_grZero (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_grZero (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_grZero (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_grZero (const t_grZero& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual t_grZero*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_grZero ();
};

class t_zeroOne: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
{
  public:
  // Constructors.
  //
  t_zeroOne (const ::xml_schema::double_&);

  t_zeroOne (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_zeroOne (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_zeroOne (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_zeroOne (const t_zeroOne& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual t_zeroOne*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_zeroOne ();
};

class t_bool: public ::xml_schema::string
{
  public:
  enum value
  {
    true_,
    false_
  };

  t_bool (value v);

  t_bool (const char* v);

  t_bool (const ::std::string& v);

  t_bool (const ::xml_schema::string& v);

  t_bool (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  t_bool (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  t_bool (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  t_bool (const t_bool& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual t_bool*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_bool&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_t_bool_convert ();
  }

  protected:
  value
  _xsd_t_bool_convert () const;

  public:
  static const char* const _xsd_t_bool_literals_[2];
  static const value _xsd_t_bool_indexes_[2];
};

class t_yesNo: public ::xml_schema::string
{
  public:
  enum value
  {
    yes,
    no
  };

  t_yesNo (value v);

  t_yesNo (const char* v);

  t_yesNo (const ::std::string& v);

  t_yesNo (const ::xml_schema::string& v);

  t_yesNo (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  t_yesNo (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  t_yesNo (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  t_yesNo (const t_yesNo& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual t_yesNo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_yesNo&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_t_yesNo_convert ();
  }

  protected:
  value
  _xsd_t_yesNo_convert () const;

  public:
  static const char* const _xsd_t_yesNo_literals_[2];
  static const value _xsd_t_yesNo_indexes_[2];
};

class t_header_Version: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type >
{
  public:
  // Constructors.
  //
  t_header_Version (const ::xml_schema::float_&);

  t_header_Version (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  t_header_Version (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  t_header_Version (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  t_header_Version (const t_header_Version& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual t_header_Version*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_header_Version ();
};

class t_maxSpeed: public ::xml_schema::string
{
  public:

  t_maxSpeed (const char* v);

  t_maxSpeed (const ::std::string& v);

  t_maxSpeed (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_maxSpeed (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_maxSpeed (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_maxSpeed (const t_maxSpeed& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual t_maxSpeed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class e_maxSpeedString: public ::xml_schema::string
{
  public:
  enum value
  {
    no_limit,
    undefined
  };

  e_maxSpeedString (value v);

  e_maxSpeedString (const char* v);

  e_maxSpeedString (const ::std::string& v);

  e_maxSpeedString (const ::xml_schema::string& v);

  e_maxSpeedString (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_maxSpeedString (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_maxSpeedString (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_maxSpeedString (const e_maxSpeedString& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual e_maxSpeedString*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_maxSpeedString&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_maxSpeedString_convert ();
  }

  protected:
  value
  _xsd_e_maxSpeedString_convert () const;

  public:
  static const char* const _xsd_e_maxSpeedString_literals_[2];
  static const value _xsd_e_maxSpeedString_indexes_[2];
};

class t_junction_id: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  t_junction_id ();

  t_junction_id (const char*);

  t_junction_id (const ::std::string&);

  t_junction_id (const ::xml_schema::string&);

  t_junction_id (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  t_junction_id (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  t_junction_id (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  t_junction_id (const t_junction_id& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual t_junction_id*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~t_junction_id ();
};

class t_header: public ::xml_schema::type
{
  public:
  // geoReference
  //
  typedef ::t_header_GeoReference geoReference_type;
  typedef ::xsd::cxx::tree::optional< geoReference_type > geoReference_optional;
  typedef ::xsd::cxx::tree::traits< geoReference_type, char > geoReference_traits;

  const geoReference_optional&
  geoReference () const;

  geoReference_optional&
  geoReference ();

  void
  geoReference (const geoReference_type& x);

  void
  geoReference (const geoReference_optional& x);

  void
  geoReference (::std::unique_ptr< geoReference_type > p);

  // offset
  //
  typedef ::t_header_Offset offset_type;
  typedef ::xsd::cxx::tree::optional< offset_type > offset_optional;
  typedef ::xsd::cxx::tree::traits< offset_type, char > offset_traits;

  const offset_optional&
  offset () const;

  offset_optional&
  offset ();

  void
  offset (const offset_type& x);

  void
  offset (const offset_optional& x);

  void
  offset (::std::unique_ptr< offset_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // revMajor
  //
  typedef ::xml_schema::integer revMajor_type;
  typedef ::xsd::cxx::tree::traits< revMajor_type, char > revMajor_traits;

  const revMajor_type&
  revMajor () const;

  static revMajor_type
  revMajor_default_value ();

  // revMinor
  //
  typedef ::xml_schema::integer revMinor_type;
  typedef ::xsd::cxx::tree::traits< revMinor_type, char > revMinor_traits;

  const revMinor_type&
  revMinor () const;

  static revMinor_type
  revMinor_default_value ();

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // version
  //
  typedef ::t_header_Version version_type;
  typedef ::xsd::cxx::tree::optional< version_type > version_optional;
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  const version_optional&
  version () const;

  version_optional&
  version ();

  void
  version (const version_type& x);

  void
  version (const version_optional& x);

  void
  version (::std::unique_ptr< version_type > p);

  // date
  //
  typedef ::xml_schema::string date_type;
  typedef ::xsd::cxx::tree::optional< date_type > date_optional;
  typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

  const date_optional&
  date () const;

  date_optional&
  date ();

  void
  date (const date_type& x);

  void
  date (const date_optional& x);

  void
  date (::std::unique_ptr< date_type > p);

  // north
  //
  typedef ::xml_schema::double_ north_type;
  typedef ::xsd::cxx::tree::optional< north_type > north_optional;
  typedef ::xsd::cxx::tree::traits< north_type, char, ::xsd::cxx::tree::schema_type::double_ > north_traits;

  const north_optional&
  north () const;

  north_optional&
  north ();

  void
  north (const north_type& x);

  void
  north (const north_optional& x);

  // south
  //
  typedef ::xml_schema::double_ south_type;
  typedef ::xsd::cxx::tree::optional< south_type > south_optional;
  typedef ::xsd::cxx::tree::traits< south_type, char, ::xsd::cxx::tree::schema_type::double_ > south_traits;

  const south_optional&
  south () const;

  south_optional&
  south ();

  void
  south (const south_type& x);

  void
  south (const south_optional& x);

  // east
  //
  typedef ::xml_schema::double_ east_type;
  typedef ::xsd::cxx::tree::optional< east_type > east_optional;
  typedef ::xsd::cxx::tree::traits< east_type, char, ::xsd::cxx::tree::schema_type::double_ > east_traits;

  const east_optional&
  east () const;

  east_optional&
  east ();

  void
  east (const east_type& x);

  void
  east (const east_optional& x);

  // west
  //
  typedef ::xml_schema::double_ west_type;
  typedef ::xsd::cxx::tree::optional< west_type > west_optional;
  typedef ::xsd::cxx::tree::traits< west_type, char, ::xsd::cxx::tree::schema_type::double_ > west_traits;

  const west_optional&
  west () const;

  west_optional&
  west ();

  void
  west (const west_type& x);

  void
  west (const west_optional& x);

  // vendor
  //
  typedef ::xml_schema::string vendor_type;
  typedef ::xsd::cxx::tree::optional< vendor_type > vendor_optional;
  typedef ::xsd::cxx::tree::traits< vendor_type, char > vendor_traits;

  const vendor_optional&
  vendor () const;

  vendor_optional&
  vendor ();

  void
  vendor (const vendor_type& x);

  void
  vendor (const vendor_optional& x);

  void
  vendor (::std::unique_ptr< vendor_type > p);

  // Constructors.
  //
  t_header ();

  t_header (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_header (const t_header& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual t_header*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_header&
  operator= (const t_header& x);

  virtual 
  ~t_header ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geoReference_optional geoReference_;
  offset_optional offset_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< revMajor_type > revMajor_;
  ::xsd::cxx::tree::one< revMinor_type > revMinor_;
  name_optional name_;
  version_optional version_;
  date_optional date_;
  north_optional north_;
  south_optional south_;
  east_optional east_;
  west_optional west_;
  vendor_optional vendor_;
};

class t_header_GeoReference: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_header_GeoReference ();

  t_header_GeoReference (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_header_GeoReference (const t_header_GeoReference& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_header_GeoReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_header_GeoReference&
  operator= (const t_header_GeoReference& x);

  virtual 
  ~t_header_GeoReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_header_Offset: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_type&
  z () const;

  z_type&
  z ();

  void
  z (const z_type& x);

  // hdg
  //
  typedef ::xml_schema::float_ hdg_type;
  typedef ::xsd::cxx::tree::traits< hdg_type, char > hdg_traits;

  const hdg_type&
  hdg () const;

  hdg_type&
  hdg ();

  void
  hdg (const hdg_type& x);

  // Constructors.
  //
  t_header_Offset (const x_type&,
                   const y_type&,
                   const z_type&,
                   const hdg_type&);

  t_header_Offset (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  t_header_Offset (const t_header_Offset& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual t_header_Offset*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_header_Offset&
  operator= (const t_header_Offset& x);

  virtual 
  ~t_header_Offset ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< hdg_type > hdg_;
};

class t_road: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::t_road_link link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_optional&
  link () const;

  link_optional&
  link ();

  void
  link (const link_type& x);

  void
  link (const link_optional& x);

  void
  link (::std::unique_ptr< link_type > p);

  // type
  //
  typedef ::t_road_type type_type;
  typedef ::xsd::cxx::tree::sequence< type_type > type_sequence;
  typedef type_sequence::iterator type_iterator;
  typedef type_sequence::const_iterator type_const_iterator;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_sequence&
  type () const;

  type_sequence&
  type ();

  void
  type (const type_sequence& s);

  // planView
  //
  typedef ::t_road_planView planView_type;
  typedef ::xsd::cxx::tree::traits< planView_type, char > planView_traits;

  const planView_type&
  planView () const;

  planView_type&
  planView ();

  void
  planView (const planView_type& x);

  void
  planView (::std::unique_ptr< planView_type > p);

  // elevationProfile
  //
  typedef ::t_road_elevationProfile elevationProfile_type;
  typedef ::xsd::cxx::tree::optional< elevationProfile_type > elevationProfile_optional;
  typedef ::xsd::cxx::tree::traits< elevationProfile_type, char > elevationProfile_traits;

  const elevationProfile_optional&
  elevationProfile () const;

  elevationProfile_optional&
  elevationProfile ();

  void
  elevationProfile (const elevationProfile_type& x);

  void
  elevationProfile (const elevationProfile_optional& x);

  void
  elevationProfile (::std::unique_ptr< elevationProfile_type > p);

  // lateralProfile
  //
  typedef ::t_road_lateralProfile lateralProfile_type;
  typedef ::xsd::cxx::tree::optional< lateralProfile_type > lateralProfile_optional;
  typedef ::xsd::cxx::tree::traits< lateralProfile_type, char > lateralProfile_traits;

  const lateralProfile_optional&
  lateralProfile () const;

  lateralProfile_optional&
  lateralProfile ();

  void
  lateralProfile (const lateralProfile_type& x);

  void
  lateralProfile (const lateralProfile_optional& x);

  void
  lateralProfile (::std::unique_ptr< lateralProfile_type > p);

  // lanes
  //
  typedef ::t_road_lanes lanes_type;
  typedef ::xsd::cxx::tree::traits< lanes_type, char > lanes_traits;

  const lanes_type&
  lanes () const;

  lanes_type&
  lanes ();

  void
  lanes (const lanes_type& x);

  void
  lanes (::std::unique_ptr< lanes_type > p);

  // objects
  //
  typedef ::t_road_objects objects_type;
  typedef ::xsd::cxx::tree::optional< objects_type > objects_optional;
  typedef ::xsd::cxx::tree::traits< objects_type, char > objects_traits;

  const objects_optional&
  objects () const;

  objects_optional&
  objects ();

  void
  objects (const objects_type& x);

  void
  objects (const objects_optional& x);

  void
  objects (::std::unique_ptr< objects_type > p);

  // signals
  //
  typedef ::t_road_signals signals_type;
  typedef ::xsd::cxx::tree::optional< signals_type > signals_optional;
  typedef ::xsd::cxx::tree::traits< signals_type, char > signals_traits;

  const signals_optional&
  signals () const;

  signals_optional&
  signals ();

  void
  signals (const signals_type& x);

  void
  signals (const signals_optional& x);

  void
  signals (::std::unique_ptr< signals_type > p);

  // surface
  //
  typedef ::t_road_surface surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::unique_ptr< surface_type > p);

  // railroad
  //
  typedef ::t_road_railroad railroad_type;
  typedef ::xsd::cxx::tree::optional< railroad_type > railroad_optional;
  typedef ::xsd::cxx::tree::traits< railroad_type, char > railroad_traits;

  const railroad_optional&
  railroad () const;

  railroad_optional&
  railroad ();

  void
  railroad (const railroad_type& x);

  void
  railroad (const railroad_optional& x);

  void
  railroad (::std::unique_ptr< railroad_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // length
  //
  typedef ::t_grEqZero length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::unique_ptr< length_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // junction
  //
  typedef ::xml_schema::string junction_type;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_type&
  junction () const;

  junction_type&
  junction ();

  void
  junction (const junction_type& x);

  void
  junction (::std::unique_ptr< junction_type > p);

  // rule
  //
  typedef ::e_trafficRule rule_type;
  typedef ::xsd::cxx::tree::optional< rule_type > rule_optional;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_optional&
  rule () const;

  rule_optional&
  rule ();

  void
  rule (const rule_type& x);

  void
  rule (const rule_optional& x);

  void
  rule (::std::unique_ptr< rule_type > p);

  // Constructors.
  //
  t_road (const planView_type&,
          const lanes_type&,
          const length_type&,
          const id_type&,
          const junction_type&);

  t_road (::std::unique_ptr< planView_type >,
          ::std::unique_ptr< lanes_type >,
          const length_type&,
          const id_type&,
          const junction_type&);

  t_road (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  t_road (const t_road& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual t_road*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road&
  operator= (const t_road& x);

  virtual 
  ~t_road ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  link_optional link_;
  type_sequence type_;
  ::xsd::cxx::tree::one< planView_type > planView_;
  elevationProfile_optional elevationProfile_;
  lateralProfile_optional lateralProfile_;
  ::xsd::cxx::tree::one< lanes_type > lanes_;
  objects_optional objects_;
  signals_optional signals_;
  surface_optional surface_;
  railroad_optional railroad_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  name_optional name_;
  ::xsd::cxx::tree::one< length_type > length_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< junction_type > junction_;
  rule_optional rule_;
};

class e_trafficRule: public ::xml_schema::string
{
  public:
  enum value
  {
    RHT,
    LHT
  };

  e_trafficRule (value v);

  e_trafficRule (const char* v);

  e_trafficRule (const ::std::string& v);

  e_trafficRule (const ::xml_schema::string& v);

  e_trafficRule (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_trafficRule (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_trafficRule (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_trafficRule (const e_trafficRule& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual e_trafficRule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_trafficRule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_trafficRule_convert ();
  }

  protected:
  value
  _xsd_e_trafficRule_convert () const;

  public:
  static const char* const _xsd_e_trafficRule_literals_[2];
  static const value _xsd_e_trafficRule_indexes_[2];
};

class t_road_link: public ::xml_schema::type
{
  public:
  // predecessor
  //
  typedef ::t_road_link_predecessorSuccessor predecessor_type;
  typedef ::xsd::cxx::tree::optional< predecessor_type > predecessor_optional;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_optional&
  predecessor () const;

  predecessor_optional&
  predecessor ();

  void
  predecessor (const predecessor_type& x);

  void
  predecessor (const predecessor_optional& x);

  void
  predecessor (::std::unique_ptr< predecessor_type > p);

  // successor
  //
  typedef ::t_road_link_predecessorSuccessor successor_type;
  typedef ::xsd::cxx::tree::optional< successor_type > successor_optional;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_optional&
  successor () const;

  successor_optional&
  successor ();

  void
  successor (const successor_type& x);

  void
  successor (const successor_optional& x);

  void
  successor (::std::unique_ptr< successor_type > p);

  // neighbor
  //
  typedef ::t_road_link_neighbor neighbor_type;
  typedef ::xsd::cxx::tree::sequence< neighbor_type > neighbor_sequence;
  typedef neighbor_sequence::iterator neighbor_iterator;
  typedef neighbor_sequence::const_iterator neighbor_const_iterator;
  typedef ::xsd::cxx::tree::traits< neighbor_type, char > neighbor_traits;

  const neighbor_sequence&
  neighbor () const;

  neighbor_sequence&
  neighbor ();

  void
  neighbor (const neighbor_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_link ();

  t_road_link (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  t_road_link (const t_road_link& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual t_road_link*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_link&
  operator= (const t_road_link& x);

  virtual 
  ~t_road_link ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  predecessor_optional predecessor_;
  successor_optional successor_;
  neighbor_sequence neighbor_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_link_predecessorSuccessor: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // elementType
  //
  typedef ::e_road_link_elementType elementType_type;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_type&
  elementType () const;

  elementType_type&
  elementType ();

  void
  elementType (const elementType_type& x);

  void
  elementType (::std::unique_ptr< elementType_type > p);

  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_type&
  elementId () const;

  elementId_type&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // contactPoint
  //
  typedef ::e_contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // elementS
  //
  typedef ::t_grEqZero elementS_type;
  typedef ::xsd::cxx::tree::optional< elementS_type > elementS_optional;
  typedef ::xsd::cxx::tree::traits< elementS_type, char > elementS_traits;

  const elementS_optional&
  elementS () const;

  elementS_optional&
  elementS ();

  void
  elementS (const elementS_type& x);

  void
  elementS (const elementS_optional& x);

  void
  elementS (::std::unique_ptr< elementS_type > p);

  // elementDir
  //
  typedef ::e_elementDir elementDir_type;
  typedef ::xsd::cxx::tree::optional< elementDir_type > elementDir_optional;
  typedef ::xsd::cxx::tree::traits< elementDir_type, char > elementDir_traits;

  const elementDir_optional&
  elementDir () const;

  elementDir_optional&
  elementDir ();

  void
  elementDir (const elementDir_type& x);

  void
  elementDir (const elementDir_optional& x);

  void
  elementDir (::std::unique_ptr< elementDir_type > p);

  // Constructors.
  //
  t_road_link_predecessorSuccessor (const elementType_type&,
                                    const elementId_type&);

  t_road_link_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  t_road_link_predecessorSuccessor (const t_road_link_predecessorSuccessor& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual t_road_link_predecessorSuccessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_link_predecessorSuccessor&
  operator= (const t_road_link_predecessorSuccessor& x);

  virtual 
  ~t_road_link_predecessorSuccessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< elementType_type > elementType_;
  ::xsd::cxx::tree::one< elementId_type > elementId_;
  contactPoint_optional contactPoint_;
  elementS_optional elementS_;
  elementDir_optional elementDir_;
};

class e_road_link_elementType: public ::xml_schema::string
{
  public:
  enum value
  {
    road,
    junction
  };

  e_road_link_elementType (value v);

  e_road_link_elementType (const char* v);

  e_road_link_elementType (const ::std::string& v);

  e_road_link_elementType (const ::xml_schema::string& v);

  e_road_link_elementType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_link_elementType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_link_elementType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_link_elementType (const e_road_link_elementType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual e_road_link_elementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_link_elementType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_link_elementType_convert ();
  }

  protected:
  value
  _xsd_e_road_link_elementType_convert () const;

  public:
  static const char* const _xsd_e_road_link_elementType_literals_[2];
  static const value _xsd_e_road_link_elementType_indexes_[2];
};

class t_road_link_neighbor: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // side
  //
  typedef ::e_road_link_neighbor_side side_type;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_type&
  side () const;

  side_type&
  side ();

  void
  side (const side_type& x);

  void
  side (::std::unique_ptr< side_type > p);

  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_type&
  elementId () const;

  elementId_type&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // direction
  //
  typedef ::e_direction direction_type;
  typedef ::xsd::cxx::tree::traits< direction_type, char > direction_traits;

  const direction_type&
  direction () const;

  direction_type&
  direction ();

  void
  direction (const direction_type& x);

  void
  direction (::std::unique_ptr< direction_type > p);

  // Constructors.
  //
  t_road_link_neighbor (const side_type&,
                        const elementId_type&,
                        const direction_type&);

  t_road_link_neighbor (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  t_road_link_neighbor (const t_road_link_neighbor& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual t_road_link_neighbor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_link_neighbor&
  operator= (const t_road_link_neighbor& x);

  virtual 
  ~t_road_link_neighbor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< side_type > side_;
  ::xsd::cxx::tree::one< elementId_type > elementId_;
  ::xsd::cxx::tree::one< direction_type > direction_;
};

class e_road_link_neighbor_side: public ::xml_schema::string
{
  public:
  enum value
  {
    left,
    right
  };

  e_road_link_neighbor_side (value v);

  e_road_link_neighbor_side (const char* v);

  e_road_link_neighbor_side (const ::std::string& v);

  e_road_link_neighbor_side (const ::xml_schema::string& v);

  e_road_link_neighbor_side (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  e_road_link_neighbor_side (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  e_road_link_neighbor_side (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  e_road_link_neighbor_side (const e_road_link_neighbor_side& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual e_road_link_neighbor_side*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_link_neighbor_side&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_link_neighbor_side_convert ();
  }

  protected:
  value
  _xsd_e_road_link_neighbor_side_convert () const;

  public:
  static const char* const _xsd_e_road_link_neighbor_side_literals_[2];
  static const value _xsd_e_road_link_neighbor_side_indexes_[2];
};

class t_road_type: public ::xml_schema::type
{
  public:
  // speed
  //
  typedef ::t_road_type_speed speed_type;
  typedef ::xsd::cxx::tree::optional< speed_type > speed_optional;
  typedef ::xsd::cxx::tree::traits< speed_type, char > speed_traits;

  const speed_optional&
  speed () const;

  speed_optional&
  speed ();

  void
  speed (const speed_type& x);

  void
  speed (const speed_optional& x);

  void
  speed (::std::unique_ptr< speed_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // type
  //
  typedef ::e_roadType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // country
  //
  typedef ::e_countryCode country_type;
  typedef ::xsd::cxx::tree::optional< country_type > country_optional;
  typedef ::xsd::cxx::tree::traits< country_type, char > country_traits;

  const country_optional&
  country () const;

  country_optional&
  country ();

  void
  country (const country_type& x);

  void
  country (const country_optional& x);

  void
  country (::std::unique_ptr< country_type > p);

  // Constructors.
  //
  t_road_type (const s_type&,
               const type_type&);

  t_road_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  t_road_type (const t_road_type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual t_road_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_type&
  operator= (const t_road_type& x);

  virtual 
  ~t_road_type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  speed_optional speed_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< type_type > type_;
  country_optional country_;
};

class t_road_type_speed: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // max
  //
  typedef ::t_maxSpeed max_type;
  typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

  const max_type&
  fmax () const;

  max_type&
  fmax ();

  void
  fmax (const max_type& x);

  void
  fmax (::std::unique_ptr< max_type > p);

  // unit
  //
  typedef ::e_unitSpeed unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::unique_ptr< unit_type > p);

  // Constructors.
  //
  t_road_type_speed (const max_type&);

  t_road_type_speed (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  t_road_type_speed (const t_road_type_speed& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual t_road_type_speed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_type_speed&
  operator= (const t_road_type_speed& x);

  virtual 
  ~t_road_type_speed ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< max_type > fmax_;
  unit_optional unit_;
};

class t_road_planView: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::t_road_planView_geometry geometry_type;
  typedef ::xsd::cxx::tree::sequence< geometry_type > geometry_sequence;
  typedef geometry_sequence::iterator geometry_iterator;
  typedef geometry_sequence::const_iterator geometry_const_iterator;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_sequence&
  geometry () const;

  geometry_sequence&
  geometry ();

  void
  geometry (const geometry_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_planView ();

  t_road_planView (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  t_road_planView (const t_road_planView& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual t_road_planView*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView&
  operator= (const t_road_planView& x);

  virtual 
  ~t_road_planView ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geometry_sequence geometry_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_planView_geometry: public ::xml_schema::type
{
  public:
  // line
  //
  typedef ::t_road_planView_geometry_line line_type;
  typedef ::xsd::cxx::tree::optional< line_type > line_optional;
  typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

  const line_optional&
  line () const;

  line_optional&
  line ();

  void
  line (const line_type& x);

  void
  line (const line_optional& x);

  void
  line (::std::unique_ptr< line_type > p);

  // spiral
  //
  typedef ::t_road_planView_geometry_spiral spiral_type;
  typedef ::xsd::cxx::tree::optional< spiral_type > spiral_optional;
  typedef ::xsd::cxx::tree::traits< spiral_type, char > spiral_traits;

  const spiral_optional&
  spiral () const;

  spiral_optional&
  spiral ();

  void
  spiral (const spiral_type& x);

  void
  spiral (const spiral_optional& x);

  void
  spiral (::std::unique_ptr< spiral_type > p);

  // arc
  //
  typedef ::t_road_planView_geometry_arc arc_type;
  typedef ::xsd::cxx::tree::optional< arc_type > arc_optional;
  typedef ::xsd::cxx::tree::traits< arc_type, char > arc_traits;

  const arc_optional&
  arc () const;

  arc_optional&
  arc ();

  void
  arc (const arc_type& x);

  void
  arc (const arc_optional& x);

  void
  arc (::std::unique_ptr< arc_type > p);

  // poly3
  //
  typedef ::t_road_planView_geometry_poly3 poly3_type;
  typedef ::xsd::cxx::tree::optional< poly3_type > poly3_optional;
  typedef ::xsd::cxx::tree::traits< poly3_type, char > poly3_traits;

  const poly3_optional&
  poly3 () const;

  poly3_optional&
  poly3 ();

  void
  poly3 (const poly3_type& x);

  void
  poly3 (const poly3_optional& x);

  void
  poly3 (::std::unique_ptr< poly3_type > p);

  // paramPoly3
  //
  typedef ::t_road_planView_geometry_paramPoly3 paramPoly3_type;
  typedef ::xsd::cxx::tree::optional< paramPoly3_type > paramPoly3_optional;
  typedef ::xsd::cxx::tree::traits< paramPoly3_type, char > paramPoly3_traits;

  const paramPoly3_optional&
  paramPoly3 () const;

  paramPoly3_optional&
  paramPoly3 ();

  void
  paramPoly3 (const paramPoly3_type& x);

  void
  paramPoly3 (const paramPoly3_optional& x);

  void
  paramPoly3 (::std::unique_ptr< paramPoly3_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // hdg
  //
  typedef ::xml_schema::double_ hdg_type;
  typedef ::xsd::cxx::tree::traits< hdg_type, char, ::xsd::cxx::tree::schema_type::double_ > hdg_traits;

  const hdg_type&
  hdg () const;

  hdg_type&
  hdg ();

  void
  hdg (const hdg_type& x);

  // length
  //
  typedef ::t_grEqZero length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::unique_ptr< length_type > p);

  // Constructors.
  //
  t_road_planView_geometry (const s_type&,
                            const x_type&,
                            const y_type&,
                            const hdg_type&,
                            const length_type&);

  t_road_planView_geometry (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  t_road_planView_geometry (const t_road_planView_geometry& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry&
  operator= (const t_road_planView_geometry& x);

  virtual 
  ~t_road_planView_geometry ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  line_optional line_;
  spiral_optional spiral_;
  arc_optional arc_;
  poly3_optional poly3_;
  paramPoly3_optional paramPoly3_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< hdg_type > hdg_;
  ::xsd::cxx::tree::one< length_type > length_;
};

class t_road_planView_geometry_line: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_planView_geometry_line ();

  t_road_planView_geometry_line (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  t_road_planView_geometry_line (const t_road_planView_geometry_line& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_line*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_line&
  operator= (const t_road_planView_geometry_line& x);

  virtual 
  ~t_road_planView_geometry_line ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_planView_geometry_spiral: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // curvStart
  //
  typedef ::xml_schema::double_ curvStart_type;
  typedef ::xsd::cxx::tree::traits< curvStart_type, char, ::xsd::cxx::tree::schema_type::double_ > curvStart_traits;

  const curvStart_type&
  curvStart () const;

  curvStart_type&
  curvStart ();

  void
  curvStart (const curvStart_type& x);

  // curvEnd
  //
  typedef ::xml_schema::double_ curvEnd_type;
  typedef ::xsd::cxx::tree::traits< curvEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > curvEnd_traits;

  const curvEnd_type&
  curvEnd () const;

  curvEnd_type&
  curvEnd ();

  void
  curvEnd (const curvEnd_type& x);

  // Constructors.
  //
  t_road_planView_geometry_spiral (const curvStart_type&,
                                   const curvEnd_type&);

  t_road_planView_geometry_spiral (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  t_road_planView_geometry_spiral (const t_road_planView_geometry_spiral& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_spiral*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_spiral&
  operator= (const t_road_planView_geometry_spiral& x);

  virtual 
  ~t_road_planView_geometry_spiral ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< curvStart_type > curvStart_;
  ::xsd::cxx::tree::one< curvEnd_type > curvEnd_;
};

class t_road_planView_geometry_arc: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // curvature
  //
  typedef ::xml_schema::double_ curvature_type;
  typedef ::xsd::cxx::tree::traits< curvature_type, char, ::xsd::cxx::tree::schema_type::double_ > curvature_traits;

  const curvature_type&
  curvature () const;

  curvature_type&
  curvature ();

  void
  curvature (const curvature_type& x);

  // Constructors.
  //
  t_road_planView_geometry_arc (const curvature_type&);

  t_road_planView_geometry_arc (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  t_road_planView_geometry_arc (const t_road_planView_geometry_arc& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_arc*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_arc&
  operator= (const t_road_planView_geometry_arc& x);

  virtual 
  ~t_road_planView_geometry_arc ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< curvature_type > curvature_;
};

class t_road_planView_geometry_poly3: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_planView_geometry_poly3 (const a_type&,
                                  const b_type&,
                                  const c_type&,
                                  const d_type&);

  t_road_planView_geometry_poly3 (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_planView_geometry_poly3 (const t_road_planView_geometry_poly3& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_poly3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_poly3&
  operator= (const t_road_planView_geometry_poly3& x);

  virtual 
  ~t_road_planView_geometry_poly3 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_planView_geometry_paramPoly3: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // aU
  //
  typedef ::xml_schema::double_ aU_type;
  typedef ::xsd::cxx::tree::traits< aU_type, char, ::xsd::cxx::tree::schema_type::double_ > aU_traits;

  const aU_type&
  aU () const;

  aU_type&
  aU ();

  void
  aU (const aU_type& x);

  // bU
  //
  typedef ::xml_schema::double_ bU_type;
  typedef ::xsd::cxx::tree::traits< bU_type, char, ::xsd::cxx::tree::schema_type::double_ > bU_traits;

  const bU_type&
  bU () const;

  bU_type&
  bU ();

  void
  bU (const bU_type& x);

  // cU
  //
  typedef ::xml_schema::double_ cU_type;
  typedef ::xsd::cxx::tree::traits< cU_type, char, ::xsd::cxx::tree::schema_type::double_ > cU_traits;

  const cU_type&
  cU () const;

  cU_type&
  cU ();

  void
  cU (const cU_type& x);

  // dU
  //
  typedef ::xml_schema::double_ dU_type;
  typedef ::xsd::cxx::tree::traits< dU_type, char, ::xsd::cxx::tree::schema_type::double_ > dU_traits;

  const dU_type&
  dU () const;

  dU_type&
  dU ();

  void
  dU (const dU_type& x);

  // aV
  //
  typedef ::xml_schema::double_ aV_type;
  typedef ::xsd::cxx::tree::traits< aV_type, char, ::xsd::cxx::tree::schema_type::double_ > aV_traits;

  const aV_type&
  aV () const;

  aV_type&
  aV ();

  void
  aV (const aV_type& x);

  // bV
  //
  typedef ::xml_schema::double_ bV_type;
  typedef ::xsd::cxx::tree::traits< bV_type, char, ::xsd::cxx::tree::schema_type::double_ > bV_traits;

  const bV_type&
  bV () const;

  bV_type&
  bV ();

  void
  bV (const bV_type& x);

  // cV
  //
  typedef ::xml_schema::double_ cV_type;
  typedef ::xsd::cxx::tree::traits< cV_type, char, ::xsd::cxx::tree::schema_type::double_ > cV_traits;

  const cV_type&
  cV () const;

  cV_type&
  cV ();

  void
  cV (const cV_type& x);

  // dV
  //
  typedef ::xml_schema::double_ dV_type;
  typedef ::xsd::cxx::tree::traits< dV_type, char, ::xsd::cxx::tree::schema_type::double_ > dV_traits;

  const dV_type&
  dV () const;

  dV_type&
  dV ();

  void
  dV (const dV_type& x);

  // pRange
  //
  typedef ::e_paramPoly3_pRange pRange_type;
  typedef ::xsd::cxx::tree::traits< pRange_type, char > pRange_traits;

  const pRange_type&
  pRange () const;

  pRange_type&
  pRange ();

  void
  pRange (const pRange_type& x);

  void
  pRange (::std::unique_ptr< pRange_type > p);

  // Constructors.
  //
  t_road_planView_geometry_paramPoly3 (const aU_type&,
                                       const bU_type&,
                                       const cU_type&,
                                       const dU_type&,
                                       const aV_type&,
                                       const bV_type&,
                                       const cV_type&,
                                       const dV_type&,
                                       const pRange_type&);

  t_road_planView_geometry_paramPoly3 (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  t_road_planView_geometry_paramPoly3 (const t_road_planView_geometry_paramPoly3& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual t_road_planView_geometry_paramPoly3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_planView_geometry_paramPoly3&
  operator= (const t_road_planView_geometry_paramPoly3& x);

  virtual 
  ~t_road_planView_geometry_paramPoly3 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< aU_type > aU_;
  ::xsd::cxx::tree::one< bU_type > bU_;
  ::xsd::cxx::tree::one< cU_type > cU_;
  ::xsd::cxx::tree::one< dU_type > dU_;
  ::xsd::cxx::tree::one< aV_type > aV_;
  ::xsd::cxx::tree::one< bV_type > bV_;
  ::xsd::cxx::tree::one< cV_type > cV_;
  ::xsd::cxx::tree::one< dV_type > dV_;
  ::xsd::cxx::tree::one< pRange_type > pRange_;
};

class e_paramPoly3_pRange: public ::xml_schema::string
{
  public:
  enum value
  {
    arcLength,
    normalized
  };

  e_paramPoly3_pRange (value v);

  e_paramPoly3_pRange (const char* v);

  e_paramPoly3_pRange (const ::std::string& v);

  e_paramPoly3_pRange (const ::xml_schema::string& v);

  e_paramPoly3_pRange (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  e_paramPoly3_pRange (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  e_paramPoly3_pRange (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  e_paramPoly3_pRange (const e_paramPoly3_pRange& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual e_paramPoly3_pRange*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_paramPoly3_pRange&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_paramPoly3_pRange_convert ();
  }

  protected:
  value
  _xsd_e_paramPoly3_pRange_convert () const;

  public:
  static const char* const _xsd_e_paramPoly3_pRange_literals_[2];
  static const value _xsd_e_paramPoly3_pRange_indexes_[2];
};

class t_road_elevationProfile: public ::xml_schema::type
{
  public:
  // elevation
  //
  typedef ::t_road_elevationProfile_elevation elevation_type;
  typedef ::xsd::cxx::tree::sequence< elevation_type > elevation_sequence;
  typedef elevation_sequence::iterator elevation_iterator;
  typedef elevation_sequence::const_iterator elevation_const_iterator;
  typedef ::xsd::cxx::tree::traits< elevation_type, char > elevation_traits;

  const elevation_sequence&
  elevation () const;

  elevation_sequence&
  elevation ();

  void
  elevation (const elevation_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_elevationProfile ();

  t_road_elevationProfile (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  t_road_elevationProfile (const t_road_elevationProfile& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual t_road_elevationProfile*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_elevationProfile&
  operator= (const t_road_elevationProfile& x);

  virtual 
  ~t_road_elevationProfile ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  elevation_sequence elevation_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_elevationProfile_elevation: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_elevationProfile_elevation (const s_type&,
                                     const a_type&,
                                     const b_type&,
                                     const c_type&,
                                     const d_type&);

  t_road_elevationProfile_elevation (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  t_road_elevationProfile_elevation (const t_road_elevationProfile_elevation& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual t_road_elevationProfile_elevation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_elevationProfile_elevation&
  operator= (const t_road_elevationProfile_elevation& x);

  virtual 
  ~t_road_elevationProfile_elevation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lateralProfile: public ::xml_schema::type
{
  public:
  // superelevation
  //
  typedef ::t_road_lateralProfile_superelevation superelevation_type;
  typedef ::xsd::cxx::tree::sequence< superelevation_type > superelevation_sequence;
  typedef superelevation_sequence::iterator superelevation_iterator;
  typedef superelevation_sequence::const_iterator superelevation_const_iterator;
  typedef ::xsd::cxx::tree::traits< superelevation_type, char > superelevation_traits;

  const superelevation_sequence&
  superelevation () const;

  superelevation_sequence&
  superelevation ();

  void
  superelevation (const superelevation_sequence& s);

  // crossfall
  //
  typedef ::t_road_lateralProfile_crossfall crossfall_type;
  typedef ::xsd::cxx::tree::sequence< crossfall_type > crossfall_sequence;
  typedef crossfall_sequence::iterator crossfall_iterator;
  typedef crossfall_sequence::const_iterator crossfall_const_iterator;
  typedef ::xsd::cxx::tree::traits< crossfall_type, char > crossfall_traits;

  const crossfall_sequence&
  crossfall () const;

  crossfall_sequence&
  crossfall ();

  void
  crossfall (const crossfall_sequence& s);

  // shape
  //
  typedef ::t_road_lateralProfile_shape shape_type;
  typedef ::xsd::cxx::tree::sequence< shape_type > shape_sequence;
  typedef shape_sequence::iterator shape_iterator;
  typedef shape_sequence::const_iterator shape_const_iterator;
  typedef ::xsd::cxx::tree::traits< shape_type, char > shape_traits;

  const shape_sequence&
  shape () const;

  shape_sequence&
  shape ();

  void
  shape (const shape_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_lateralProfile ();

  t_road_lateralProfile (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_road_lateralProfile (const t_road_lateralProfile& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_road_lateralProfile*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lateralProfile&
  operator= (const t_road_lateralProfile& x);

  virtual 
  ~t_road_lateralProfile ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  superelevation_sequence superelevation_;
  crossfall_sequence crossfall_;
  shape_sequence shape_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_lateralProfile_superelevation: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lateralProfile_superelevation (const s_type&,
                                        const a_type&,
                                        const b_type&,
                                        const c_type&,
                                        const d_type&);

  t_road_lateralProfile_superelevation (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  t_road_lateralProfile_superelevation (const t_road_lateralProfile_superelevation& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual t_road_lateralProfile_superelevation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lateralProfile_superelevation&
  operator= (const t_road_lateralProfile_superelevation& x);

  virtual 
  ~t_road_lateralProfile_superelevation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lateralProfile_crossfall: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // side
  //
  typedef ::e_road_lateralProfile_crossfall_side side_type;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_type&
  side () const;

  side_type&
  side ();

  void
  side (const side_type& x);

  void
  side (::std::unique_ptr< side_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lateralProfile_crossfall (const side_type&,
                                   const s_type&,
                                   const a_type&,
                                   const b_type&,
                                   const c_type&,
                                   const d_type&);

  t_road_lateralProfile_crossfall (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  t_road_lateralProfile_crossfall (const t_road_lateralProfile_crossfall& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual t_road_lateralProfile_crossfall*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lateralProfile_crossfall&
  operator= (const t_road_lateralProfile_crossfall& x);

  virtual 
  ~t_road_lateralProfile_crossfall ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< side_type > side_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class e_road_lateralProfile_crossfall_side: public ::xml_schema::string
{
  public:
  enum value
  {
    left,
    right,
    both
  };

  e_road_lateralProfile_crossfall_side (value v);

  e_road_lateralProfile_crossfall_side (const char* v);

  e_road_lateralProfile_crossfall_side (const ::std::string& v);

  e_road_lateralProfile_crossfall_side (const ::xml_schema::string& v);

  e_road_lateralProfile_crossfall_side (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_road_lateralProfile_crossfall_side (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_road_lateralProfile_crossfall_side (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_road_lateralProfile_crossfall_side (const e_road_lateralProfile_crossfall_side& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual e_road_lateralProfile_crossfall_side*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_lateralProfile_crossfall_side&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_lateralProfile_crossfall_side_convert ();
  }

  protected:
  value
  _xsd_e_road_lateralProfile_crossfall_side_convert () const;

  public:
  static const char* const _xsd_e_road_lateralProfile_crossfall_side_literals_[3];
  static const value _xsd_e_road_lateralProfile_crossfall_side_indexes_[3];
};

class t_road_lateralProfile_shape: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lateralProfile_shape (const s_type&,
                               const t_type&,
                               const a_type&,
                               const b_type&,
                               const c_type&,
                               const d_type&);

  t_road_lateralProfile_shape (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  t_road_lateralProfile_shape (const t_road_lateralProfile_shape& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual t_road_lateralProfile_shape*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lateralProfile_shape&
  operator= (const t_road_lateralProfile_shape& x);

  virtual 
  ~t_road_lateralProfile_shape ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lanes: public ::xml_schema::type
{
  public:
  // laneOffset
  //
  typedef ::t_road_lanes_laneOffset laneOffset_type;
  typedef ::xsd::cxx::tree::sequence< laneOffset_type > laneOffset_sequence;
  typedef laneOffset_sequence::iterator laneOffset_iterator;
  typedef laneOffset_sequence::const_iterator laneOffset_const_iterator;
  typedef ::xsd::cxx::tree::traits< laneOffset_type, char > laneOffset_traits;

  const laneOffset_sequence&
  laneOffset () const;

  laneOffset_sequence&
  laneOffset ();

  void
  laneOffset (const laneOffset_sequence& s);

  // laneSection
  //
  typedef ::t_road_lanes_laneSection laneSection_type;
  typedef ::xsd::cxx::tree::sequence< laneSection_type > laneSection_sequence;
  typedef laneSection_sequence::iterator laneSection_iterator;
  typedef laneSection_sequence::const_iterator laneSection_const_iterator;
  typedef ::xsd::cxx::tree::traits< laneSection_type, char > laneSection_traits;

  const laneSection_sequence&
  laneSection () const;

  laneSection_sequence&
  laneSection ();

  void
  laneSection (const laneSection_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_lanes ();

  t_road_lanes (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  t_road_lanes (const t_road_lanes& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual t_road_lanes*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes&
  operator= (const t_road_lanes& x);

  virtual 
  ~t_road_lanes ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  laneOffset_sequence laneOffset_;
  laneSection_sequence laneSection_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_lanes_laneOffset: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lanes_laneOffset (const s_type&,
                           const a_type&,
                           const b_type&,
                           const c_type&,
                           const d_type&);

  t_road_lanes_laneOffset (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  t_road_lanes_laneOffset (const t_road_lanes_laneOffset& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneOffset*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneOffset&
  operator= (const t_road_lanes_laneOffset& x);

  virtual 
  ~t_road_lanes_laneOffset ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lanes_laneSection: public ::xml_schema::type
{
  public:
  // left
  //
  typedef ::t_road_lanes_laneSection_left left_type;
  typedef ::xsd::cxx::tree::optional< left_type > left_optional;
  typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

  const left_optional&
  left () const;

  left_optional&
  left ();

  void
  left (const left_type& x);

  void
  left (const left_optional& x);

  void
  left (::std::unique_ptr< left_type > p);

  // center
  //
  typedef ::t_road_lanes_laneSection_center center_type;
  typedef ::xsd::cxx::tree::optional< center_type > center_optional;
  typedef ::xsd::cxx::tree::traits< center_type, char > center_traits;

  const center_optional&
  center () const;

  center_optional&
  center ();

  void
  center (const center_type& x);

  void
  center (const center_optional& x);

  void
  center (::std::unique_ptr< center_type > p);

  // right
  //
  typedef ::t_road_lanes_laneSection_right right_type;
  typedef ::xsd::cxx::tree::optional< right_type > right_optional;
  typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

  const right_optional&
  right () const;

  right_optional&
  right ();

  void
  right (const right_type& x);

  void
  right (const right_optional& x);

  void
  right (::std::unique_ptr< right_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // singleSide
  //
  typedef ::t_bool singleSide_type;
  typedef ::xsd::cxx::tree::optional< singleSide_type > singleSide_optional;
  typedef ::xsd::cxx::tree::traits< singleSide_type, char > singleSide_traits;

  const singleSide_optional&
  singleSide () const;

  singleSide_optional&
  singleSide ();

  void
  singleSide (const singleSide_type& x);

  void
  singleSide (const singleSide_optional& x);

  void
  singleSide (::std::unique_ptr< singleSide_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection (const s_type&);

  t_road_lanes_laneSection (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  t_road_lanes_laneSection (const t_road_lanes_laneSection& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection&
  operator= (const t_road_lanes_laneSection& x);

  virtual 
  ~t_road_lanes_laneSection ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  left_optional left_;
  center_optional center_;
  right_optional right_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  singleSide_optional singleSide_;
};

class t_road_lanes_laneSection_left: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::t_road_lanes_laneSection_left_lane lane_type;
  typedef ::xsd::cxx::tree::sequence< lane_type > lane_sequence;
  typedef lane_sequence::iterator lane_iterator;
  typedef lane_sequence::const_iterator lane_const_iterator;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_sequence&
  lane () const;

  lane_sequence&
  lane ();

  void
  lane (const lane_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_left ();

  t_road_lanes_laneSection_left (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_left (const t_road_lanes_laneSection_left& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_left*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_left&
  operator= (const t_road_lanes_laneSection_left& x);

  virtual 
  ~t_road_lanes_laneSection_left ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lane_sequence lane_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_lanes_laneSection_center: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::t_road_lanes_laneSection_center_lane lane_type;
  typedef ::xsd::cxx::tree::sequence< lane_type > lane_sequence;
  typedef lane_sequence::iterator lane_iterator;
  typedef lane_sequence::const_iterator lane_const_iterator;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_sequence&
  lane () const;

  lane_sequence&
  lane ();

  void
  lane (const lane_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_center ();

  t_road_lanes_laneSection_center (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_center (const t_road_lanes_laneSection_center& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_center*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_center&
  operator= (const t_road_lanes_laneSection_center& x);

  virtual 
  ~t_road_lanes_laneSection_center ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lane_sequence lane_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_lanes_laneSection_right: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::t_road_lanes_laneSection_right_lane lane_type;
  typedef ::xsd::cxx::tree::sequence< lane_type > lane_sequence;
  typedef lane_sequence::iterator lane_iterator;
  typedef lane_sequence::const_iterator lane_const_iterator;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_sequence&
  lane () const;

  lane_sequence&
  lane ();

  void
  lane (const lane_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_right ();

  t_road_lanes_laneSection_right (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_right (const t_road_lanes_laneSection_right& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_right*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_right&
  operator= (const t_road_lanes_laneSection_right& x);

  virtual 
  ~t_road_lanes_laneSection_right ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lane_sequence lane_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_lanes_laneSection_center_lane: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_link link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_optional&
  link () const;

  link_optional&
  link ();

  void
  link (const link_type& x);

  void
  link (const link_optional& x);

  void
  link (::std::unique_ptr< link_type > p);

  // roadMark
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_roadMark roadMark_type;
  typedef ::xsd::cxx::tree::sequence< roadMark_type > roadMark_sequence;
  typedef roadMark_sequence::iterator roadMark_iterator;
  typedef roadMark_sequence::const_iterator roadMark_const_iterator;
  typedef ::xsd::cxx::tree::traits< roadMark_type, char > roadMark_traits;

  const roadMark_sequence&
  roadMark () const;

  roadMark_sequence&
  roadMark ();

  void
  roadMark (const roadMark_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  static id_type
  id_default_value ();

  // type
  //
  typedef ::e_laneType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // level
  //
  typedef ::t_bool level_type;
  typedef ::xsd::cxx::tree::optional< level_type > level_optional;
  typedef ::xsd::cxx::tree::traits< level_type, char > level_traits;

  const level_optional&
  level () const;

  level_optional&
  level ();

  void
  level (const level_type& x);

  void
  level (const level_optional& x);

  void
  level (::std::unique_ptr< level_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_center_lane (const type_type&);

  t_road_lanes_laneSection_center_lane (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_center_lane (const t_road_lanes_laneSection_center_lane& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_center_lane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_center_lane&
  operator= (const t_road_lanes_laneSection_center_lane& x);

  virtual 
  ~t_road_lanes_laneSection_center_lane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  link_optional link_;
  roadMark_sequence roadMark_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< type_type > type_;
  level_optional level_;
};

class t_road_lanes_laneSection_lr_lane: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_link link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_optional&
  link () const;

  link_optional&
  link ();

  void
  link (const link_type& x);

  void
  link (const link_optional& x);

  void
  link (::std::unique_ptr< link_type > p);

  // width
  //
  typedef ::t_road_lanes_laneSection_lr_lane_width width_type;
  typedef ::xsd::cxx::tree::sequence< width_type > width_sequence;
  typedef width_sequence::iterator width_iterator;
  typedef width_sequence::const_iterator width_const_iterator;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_sequence&
  width () const;

  width_sequence&
  width ();

  void
  width (const width_sequence& s);

  // border
  //
  typedef ::t_road_lanes_laneSection_lr_lane_border border_type;
  typedef ::xsd::cxx::tree::sequence< border_type > border_sequence;
  typedef border_sequence::iterator border_iterator;
  typedef border_sequence::const_iterator border_const_iterator;
  typedef ::xsd::cxx::tree::traits< border_type, char > border_traits;

  const border_sequence&
  border () const;

  border_sequence&
  border ();

  void
  border (const border_sequence& s);

  // roadMark
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_roadMark roadMark_type;
  typedef ::xsd::cxx::tree::sequence< roadMark_type > roadMark_sequence;
  typedef roadMark_sequence::iterator roadMark_iterator;
  typedef roadMark_sequence::const_iterator roadMark_const_iterator;
  typedef ::xsd::cxx::tree::traits< roadMark_type, char > roadMark_traits;

  const roadMark_sequence&
  roadMark () const;

  roadMark_sequence&
  roadMark ();

  void
  roadMark (const roadMark_sequence& s);

  // material
  //
  typedef ::t_road_lanes_laneSection_lr_lane_material material_type;
  typedef ::xsd::cxx::tree::sequence< material_type > material_sequence;
  typedef material_sequence::iterator material_iterator;
  typedef material_sequence::const_iterator material_const_iterator;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_sequence&
  material () const;

  material_sequence&
  material ();

  void
  material (const material_sequence& s);

  // visibility
  //
  typedef ::t_road_lanes_laneSection_lr_lane_visibility visibility_type;
  typedef ::xsd::cxx::tree::sequence< visibility_type > visibility_sequence;
  typedef visibility_sequence::iterator visibility_iterator;
  typedef visibility_sequence::const_iterator visibility_const_iterator;
  typedef ::xsd::cxx::tree::traits< visibility_type, char > visibility_traits;

  const visibility_sequence&
  visibility () const;

  visibility_sequence&
  visibility ();

  void
  visibility (const visibility_sequence& s);

  // speed
  //
  typedef ::t_road_lanes_laneSection_lr_lane_speed speed_type;
  typedef ::xsd::cxx::tree::sequence< speed_type > speed_sequence;
  typedef speed_sequence::iterator speed_iterator;
  typedef speed_sequence::const_iterator speed_const_iterator;
  typedef ::xsd::cxx::tree::traits< speed_type, char > speed_traits;

  const speed_sequence&
  speed () const;

  speed_sequence&
  speed ();

  void
  speed (const speed_sequence& s);

  // access
  //
  typedef ::t_road_lanes_laneSection_lr_lane_access access_type;
  typedef ::xsd::cxx::tree::sequence< access_type > access_sequence;
  typedef access_sequence::iterator access_iterator;
  typedef access_sequence::const_iterator access_const_iterator;
  typedef ::xsd::cxx::tree::traits< access_type, char > access_traits;

  const access_sequence&
  access () const;

  access_sequence&
  access ();

  void
  access (const access_sequence& s);

  // height
  //
  typedef ::t_road_lanes_laneSection_lr_lane_height height_type;
  typedef ::xsd::cxx::tree::sequence< height_type > height_sequence;
  typedef height_sequence::iterator height_iterator;
  typedef height_sequence::const_iterator height_const_iterator;
  typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

  const height_sequence&
  height () const;

  height_sequence&
  height ();

  void
  height (const height_sequence& s);

  // rule
  //
  typedef ::t_road_lanes_laneSection_lr_lane_rule rule_type;
  typedef ::xsd::cxx::tree::sequence< rule_type > rule_sequence;
  typedef rule_sequence::iterator rule_iterator;
  typedef rule_sequence::const_iterator rule_const_iterator;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_sequence&
  rule () const;

  rule_sequence&
  rule ();

  void
  rule (const rule_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // type
  //
  typedef ::e_laneType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // level
  //
  typedef ::t_bool level_type;
  typedef ::xsd::cxx::tree::optional< level_type > level_optional;
  typedef ::xsd::cxx::tree::traits< level_type, char > level_traits;

  const level_optional&
  level () const;

  level_optional&
  level ();

  void
  level (const level_type& x);

  void
  level (const level_optional& x);

  void
  level (::std::unique_ptr< level_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane (const type_type&);

  t_road_lanes_laneSection_lr_lane (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane (const t_road_lanes_laneSection_lr_lane& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane&
  operator= (const t_road_lanes_laneSection_lr_lane& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  link_optional link_;
  width_sequence width_;
  border_sequence border_;
  roadMark_sequence roadMark_;
  material_sequence material_;
  visibility_sequence visibility_;
  speed_sequence speed_;
  access_sequence access_;
  height_sequence height_;
  rule_sequence rule_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< type_type > type_;
  level_optional level_;
};

class t_road_lanes_laneSection_left_lane: public ::t_road_lanes_laneSection_lr_lane
{
  public:
  // id
  //
  typedef ::xml_schema::positive_integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // Constructors.
  //
  t_road_lanes_laneSection_left_lane (const type_type&,
                                      const id_type&);

  t_road_lanes_laneSection_left_lane (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_left_lane (const t_road_lanes_laneSection_left_lane& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_left_lane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_left_lane&
  operator= (const t_road_lanes_laneSection_left_lane& x);

  virtual 
  ~t_road_lanes_laneSection_left_lane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_road_lanes_laneSection_right_lane: public ::t_road_lanes_laneSection_lr_lane
{
  public:
  // id
  //
  typedef ::xml_schema::negative_integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // Constructors.
  //
  t_road_lanes_laneSection_right_lane (const type_type&,
                                       const id_type&);

  t_road_lanes_laneSection_right_lane (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_right_lane (const t_road_lanes_laneSection_right_lane& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_right_lane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_right_lane&
  operator= (const t_road_lanes_laneSection_right_lane& x);

  virtual 
  ~t_road_lanes_laneSection_right_lane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_road_lanes_laneSection_lcr_lane_link: public ::xml_schema::type
{
  public:
  // predecessor
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor predecessor_type;
  typedef ::xsd::cxx::tree::sequence< predecessor_type > predecessor_sequence;
  typedef predecessor_sequence::iterator predecessor_iterator;
  typedef predecessor_sequence::const_iterator predecessor_const_iterator;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_sequence&
  predecessor () const;

  predecessor_sequence&
  predecessor ();

  void
  predecessor (const predecessor_sequence& s);

  // successor
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor successor_type;
  typedef ::xsd::cxx::tree::sequence< successor_type > successor_sequence;
  typedef successor_sequence::iterator successor_iterator;
  typedef successor_sequence::const_iterator successor_const_iterator;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_sequence&
  successor () const;

  successor_sequence&
  successor ();

  void
  successor (const successor_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_link ();

  t_road_lanes_laneSection_lcr_lane_link (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_link (const t_road_lanes_laneSection_lcr_lane_link& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_link*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_link&
  operator= (const t_road_lanes_laneSection_lcr_lane_link& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_link ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  predecessor_sequence predecessor_;
  successor_sequence successor_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const id_type&);

  t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor (const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& x,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor&
  operator= (const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_road_lanes_laneSection_lr_lane_width: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_width (const sOffset_type&,
                                          const a_type&,
                                          const b_type&,
                                          const c_type&,
                                          const d_type&);

  t_road_lanes_laneSection_lr_lane_width (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_width (const t_road_lanes_laneSection_lr_lane_width& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_width*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_width&
  operator= (const t_road_lanes_laneSection_lr_lane_width& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_width ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lanes_laneSection_lr_lane_border: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_border (const sOffset_type&,
                                           const a_type&,
                                           const b_type&,
                                           const c_type&,
                                           const d_type&);

  t_road_lanes_laneSection_lr_lane_border (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_border (const t_road_lanes_laneSection_lr_lane_border& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_border*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_border&
  operator= (const t_road_lanes_laneSection_lr_lane_border& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_border ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lanes_laneSection_lcr_lane_roadMark: public ::xml_schema::type
{
  public:
  // sway
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_roadMark_sway sway_type;
  typedef ::xsd::cxx::tree::sequence< sway_type > sway_sequence;
  typedef sway_sequence::iterator sway_iterator;
  typedef sway_sequence::const_iterator sway_const_iterator;
  typedef ::xsd::cxx::tree::traits< sway_type, char > sway_traits;

  const sway_sequence&
  sway () const;

  sway_sequence&
  sway ();

  void
  sway (const sway_sequence& s);

  // type
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_roadMark_type type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // explicit
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_roadMark_explicit explicit_type;
  typedef ::xsd::cxx::tree::optional< explicit_type > explicit_optional;
  typedef ::xsd::cxx::tree::traits< explicit_type, char > explicit_traits;

  const explicit_optional&
  explicit_ () const;

  explicit_optional&
  explicit_ ();

  void
  explicit_ (const explicit_type& x);

  void
  explicit_ (const explicit_optional& x);

  void
  explicit_ (::std::unique_ptr< explicit_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // type
  //
  typedef ::e_roadMarkType type1_type;
  typedef ::xsd::cxx::tree::traits< type1_type, char > type1_traits;

  const type1_type&
  type1 () const;

  type1_type&
  type1 ();

  void
  type1 (const type1_type& x);

  void
  type1 (::std::unique_ptr< type1_type > p);

  // weight
  //
  typedef ::e_roadMarkWeight weight_type;
  typedef ::xsd::cxx::tree::optional< weight_type > weight_optional;
  typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

  const weight_optional&
  weight () const;

  weight_optional&
  weight ();

  void
  weight (const weight_type& x);

  void
  weight (const weight_optional& x);

  void
  weight (::std::unique_ptr< weight_type > p);

  // color
  //
  typedef ::e_roadMarkColor color_type;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_type&
  color () const;

  color_type&
  color ();

  void
  color (const color_type& x);

  void
  color (::std::unique_ptr< color_type > p);

  // material
  //
  typedef ::xml_schema::string material_type;
  typedef ::xsd::cxx::tree::optional< material_type > material_optional;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_optional&
  material () const;

  material_optional&
  material ();

  void
  material (const material_type& x);

  void
  material (const material_optional& x);

  void
  material (::std::unique_ptr< material_type > p);

  // width
  //
  typedef ::t_grEqZero width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  void
  width (::std::unique_ptr< width_type > p);

  // laneChange
  //
  typedef ::e_road_lanes_laneSection_lcr_lane_roadMark_laneChange laneChange_type;
  typedef ::xsd::cxx::tree::optional< laneChange_type > laneChange_optional;
  typedef ::xsd::cxx::tree::traits< laneChange_type, char > laneChange_traits;

  const laneChange_optional&
  laneChange () const;

  laneChange_optional&
  laneChange ();

  void
  laneChange (const laneChange_type& x);

  void
  laneChange (const laneChange_optional& x);

  void
  laneChange (::std::unique_ptr< laneChange_type > p);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_roadMark (const sOffset_type&,
                                              const type1_type&,
                                              const color_type&);

  t_road_lanes_laneSection_lcr_lane_roadMark (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_roadMark (const t_road_lanes_laneSection_lcr_lane_roadMark& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_roadMark*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_roadMark&
  operator= (const t_road_lanes_laneSection_lcr_lane_roadMark& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_roadMark ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  sway_sequence sway_;
  type_optional type_;
  explicit_optional explicit__;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< type1_type > type1_;
  weight_optional weight_;
  ::xsd::cxx::tree::one< color_type > color_;
  material_optional material_;
  width_optional width_;
  laneChange_optional laneChange_;
  height_optional height_;
};

class e_road_lanes_laneSection_lcr_lane_roadMark_laneChange: public ::xml_schema::string
{
  public:
  enum value
  {
    increase,
    decrease,
    both,
    none
  };

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (value v);

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const char* v);

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::std::string& v);

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xml_schema::string& v);

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::xercesc::DOMAttr& a,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const ::std::string& s,
                                                         const ::xercesc::DOMElement* e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange (const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

  virtual e_road_lanes_laneSection_lcr_lane_roadMark_laneChange*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_lanes_laneSection_lcr_lane_roadMark_laneChange&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert ();
  }

  protected:
  value
  _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_convert () const;

  public:
  static const char* const _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_literals_[4];
  static const value _xsd_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange_indexes_[4];
};

class t_road_lanes_laneSection_lcr_lane_roadMark_sway: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // ds
  //
  typedef ::t_grEqZero ds_type;
  typedef ::xsd::cxx::tree::traits< ds_type, char > ds_traits;

  const ds_type&
  ds () const;

  ds_type&
  ds ();

  void
  ds (const ds_type& x);

  void
  ds (::std::unique_ptr< ds_type > p);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_type&
  a () const;

  a_type&
  a ();

  void
  a (const a_type& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_type&
  c () const;

  c_type&
  c ();

  void
  c (const c_type& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_type&
  d () const;

  d_type&
  d ();

  void
  d (const d_type& x);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_roadMark_sway (const ds_type&,
                                                   const a_type&,
                                                   const b_type&,
                                                   const c_type&,
                                                   const d_type&);

  t_road_lanes_laneSection_lcr_lane_roadMark_sway (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_roadMark_sway (const t_road_lanes_laneSection_lcr_lane_roadMark_sway& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_roadMark_sway*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_roadMark_sway&
  operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_sway& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_roadMark_sway ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< ds_type > ds_;
  ::xsd::cxx::tree::one< a_type > a_;
  ::xsd::cxx::tree::one< b_type > b_;
  ::xsd::cxx::tree::one< c_type > c_;
  ::xsd::cxx::tree::one< d_type > d_;
};

class t_road_lanes_laneSection_lcr_lane_roadMark_type: public ::xml_schema::type
{
  public:
  // line
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_roadMark_type_line line_type;
  typedef ::xsd::cxx::tree::sequence< line_type > line_sequence;
  typedef line_sequence::iterator line_iterator;
  typedef line_sequence::const_iterator line_const_iterator;
  typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

  const line_sequence&
  line () const;

  line_sequence&
  line ();

  void
  line (const line_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // width
  //
  typedef ::t_grEqZero width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  void
  width (::std::unique_ptr< width_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_roadMark_type (const name_type&,
                                                   const width_type&);

  t_road_lanes_laneSection_lcr_lane_roadMark_type (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_roadMark_type (const t_road_lanes_laneSection_lcr_lane_roadMark_type& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_roadMark_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_roadMark_type&
  operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_type& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_roadMark_type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  line_sequence line_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< width_type > width_;
};

class t_road_lanes_laneSection_lcr_lane_roadMark_type_line: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // length
  //
  typedef ::t_grEqZero length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::unique_ptr< length_type > p);

  // space
  //
  typedef ::t_grEqZero space_type;
  typedef ::xsd::cxx::tree::traits< space_type, char > space_traits;

  const space_type&
  space () const;

  space_type&
  space ();

  void
  space (const space_type& x);

  void
  space (::std::unique_ptr< space_type > p);

  // tOffset
  //
  typedef ::xml_schema::double_ tOffset_type;
  typedef ::xsd::cxx::tree::traits< tOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > tOffset_traits;

  const tOffset_type&
  tOffset () const;

  tOffset_type&
  tOffset ();

  void
  tOffset (const tOffset_type& x);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // rule
  //
  typedef ::e_roadMarkRule rule_type;
  typedef ::xsd::cxx::tree::optional< rule_type > rule_optional;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_optional&
  rule () const;

  rule_optional&
  rule ();

  void
  rule (const rule_type& x);

  void
  rule (const rule_optional& x);

  void
  rule (::std::unique_ptr< rule_type > p);

  // width
  //
  typedef ::t_grEqZero width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  void
  width (::std::unique_ptr< width_type > p);

  // color
  //
  typedef ::e_roadMarkColor color_type;
  typedef ::xsd::cxx::tree::optional< color_type > color_optional;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_optional&
  color () const;

  color_optional&
  color ();

  void
  color (const color_type& x);

  void
  color (const color_optional& x);

  void
  color (::std::unique_ptr< color_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const length_type&,
                                                        const space_type&,
                                                        const tOffset_type&,
                                                        const sOffset_type&,
                                                        const width_type&);

  t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_roadMark_type_line (const t_road_lanes_laneSection_lcr_lane_roadMark_type_line& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_roadMark_type_line*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_roadMark_type_line&
  operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_type_line& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_roadMark_type_line ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< length_type > length_;
  ::xsd::cxx::tree::one< space_type > space_;
  ::xsd::cxx::tree::one< tOffset_type > tOffset_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  rule_optional rule_;
  ::xsd::cxx::tree::one< width_type > width_;
  color_optional color_;
};

class t_road_lanes_laneSection_lcr_lane_roadMark_explicit: public ::xml_schema::type
{
  public:
  // line
  //
  typedef ::t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line line_type;
  typedef ::xsd::cxx::tree::sequence< line_type > line_sequence;
  typedef line_sequence::iterator line_iterator;
  typedef line_sequence::const_iterator line_const_iterator;
  typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

  const line_sequence&
  line () const;

  line_sequence&
  line ();

  void
  line (const line_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_roadMark_explicit ();

  t_road_lanes_laneSection_lcr_lane_roadMark_explicit (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_roadMark_explicit (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_roadMark_explicit*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_roadMark_explicit&
  operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_roadMark_explicit ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  line_sequence line_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // length
  //
  typedef ::t_grEqZero length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::unique_ptr< length_type > p);

  // tOffset
  //
  typedef ::xml_schema::double_ tOffset_type;
  typedef ::xsd::cxx::tree::traits< tOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > tOffset_traits;

  const tOffset_type&
  tOffset () const;

  tOffset_type&
  tOffset ();

  void
  tOffset (const tOffset_type& x);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // rule
  //
  typedef ::e_roadMarkRule rule_type;
  typedef ::xsd::cxx::tree::optional< rule_type > rule_optional;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_optional&
  rule () const;

  rule_optional&
  rule ();

  void
  rule (const rule_type& x);

  void
  rule (const rule_optional& x);

  void
  rule (::std::unique_ptr< rule_type > p);

  // width
  //
  typedef ::t_grEqZero width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  void
  width (::std::unique_ptr< width_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const length_type&,
                                                            const tOffset_type&,
                                                            const sOffset_type&,
                                                            const width_type&);

  t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line&
  operator= (const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line& x);

  virtual 
  ~t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< length_type > length_;
  ::xsd::cxx::tree::one< tOffset_type > tOffset_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  rule_optional rule_;
  ::xsd::cxx::tree::one< width_type > width_;
};

class t_road_lanes_laneSection_lr_lane_material: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // surface
  //
  typedef ::xml_schema::string surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::unique_ptr< surface_type > p);

  // friction
  //
  typedef ::t_grEqZero friction_type;
  typedef ::xsd::cxx::tree::traits< friction_type, char > friction_traits;

  const friction_type&
  friction () const;

  friction_type&
  friction ();

  void
  friction (const friction_type& x);

  void
  friction (::std::unique_ptr< friction_type > p);

  // roughness
  //
  typedef ::t_grEqZero roughness_type;
  typedef ::xsd::cxx::tree::optional< roughness_type > roughness_optional;
  typedef ::xsd::cxx::tree::traits< roughness_type, char > roughness_traits;

  const roughness_optional&
  roughness () const;

  roughness_optional&
  roughness ();

  void
  roughness (const roughness_type& x);

  void
  roughness (const roughness_optional& x);

  void
  roughness (::std::unique_ptr< roughness_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_material (const sOffset_type&,
                                             const friction_type&);

  t_road_lanes_laneSection_lr_lane_material (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_material (const t_road_lanes_laneSection_lr_lane_material& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_material*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_material&
  operator= (const t_road_lanes_laneSection_lr_lane_material& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_material ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  surface_optional surface_;
  ::xsd::cxx::tree::one< friction_type > friction_;
  roughness_optional roughness_;
};

class t_road_lanes_laneSection_lr_lane_visibility: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // forward
  //
  typedef ::t_grEqZero forward_type;
  typedef ::xsd::cxx::tree::traits< forward_type, char > forward_traits;

  const forward_type&
  forward () const;

  forward_type&
  forward ();

  void
  forward (const forward_type& x);

  void
  forward (::std::unique_ptr< forward_type > p);

  // back
  //
  typedef ::t_grEqZero back_type;
  typedef ::xsd::cxx::tree::traits< back_type, char > back_traits;

  const back_type&
  back () const;

  back_type&
  back ();

  void
  back (const back_type& x);

  void
  back (::std::unique_ptr< back_type > p);

  // left
  //
  typedef ::t_grEqZero left_type;
  typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

  const left_type&
  left () const;

  left_type&
  left ();

  void
  left (const left_type& x);

  void
  left (::std::unique_ptr< left_type > p);

  // right
  //
  typedef ::t_grEqZero right_type;
  typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

  const right_type&
  right () const;

  right_type&
  right ();

  void
  right (const right_type& x);

  void
  right (::std::unique_ptr< right_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_visibility (const sOffset_type&,
                                               const forward_type&,
                                               const back_type&,
                                               const left_type&,
                                               const right_type&);

  t_road_lanes_laneSection_lr_lane_visibility (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_visibility (const t_road_lanes_laneSection_lr_lane_visibility& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_visibility*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_visibility&
  operator= (const t_road_lanes_laneSection_lr_lane_visibility& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_visibility ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< forward_type > forward_;
  ::xsd::cxx::tree::one< back_type > back_;
  ::xsd::cxx::tree::one< left_type > left_;
  ::xsd::cxx::tree::one< right_type > right_;
};

class t_road_lanes_laneSection_lr_lane_speed: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // max
  //
  typedef ::t_grEqZero max_type;
  typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

  const max_type&
  fmax () const;

  max_type&
  fmax ();

  void
  fmax (const max_type& x);

  void
  fmax (::std::unique_ptr< max_type > p);

  // unit
  //
  typedef ::e_unitSpeed unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::unique_ptr< unit_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_speed (const sOffset_type&,
                                          const max_type&);

  t_road_lanes_laneSection_lr_lane_speed (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_speed (const t_road_lanes_laneSection_lr_lane_speed& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_speed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_speed&
  operator= (const t_road_lanes_laneSection_lr_lane_speed& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_speed ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< max_type > fmax_;
  unit_optional unit_;
};

class t_road_lanes_laneSection_lr_lane_access: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // rule
  //
  typedef ::e_road_lanes_laneSection_lr_lane_access_rule rule_type;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_type&
  rule () const;

  rule_type&
  rule ();

  void
  rule (const rule_type& x);

  void
  rule (::std::unique_ptr< rule_type > p);

  // restriction
  //
  typedef ::e_accessRestrictionType restriction_type;
  typedef ::xsd::cxx::tree::traits< restriction_type, char > restriction_traits;

  const restriction_type&
  restriction () const;

  restriction_type&
  restriction ();

  void
  restriction (const restriction_type& x);

  void
  restriction (::std::unique_ptr< restriction_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_access (const sOffset_type&,
                                           const rule_type&,
                                           const restriction_type&);

  t_road_lanes_laneSection_lr_lane_access (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_access (const t_road_lanes_laneSection_lr_lane_access& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_access*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_access&
  operator= (const t_road_lanes_laneSection_lr_lane_access& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_access ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< rule_type > rule_;
  ::xsd::cxx::tree::one< restriction_type > restriction_;
};

class e_road_lanes_laneSection_lr_lane_access_rule: public ::xml_schema::string
{
  public:
  enum value
  {
    allow,
    deny
  };

  e_road_lanes_laneSection_lr_lane_access_rule (value v);

  e_road_lanes_laneSection_lr_lane_access_rule (const char* v);

  e_road_lanes_laneSection_lr_lane_access_rule (const ::std::string& v);

  e_road_lanes_laneSection_lr_lane_access_rule (const ::xml_schema::string& v);

  e_road_lanes_laneSection_lr_lane_access_rule (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

  e_road_lanes_laneSection_lr_lane_access_rule (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

  e_road_lanes_laneSection_lr_lane_access_rule (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

  e_road_lanes_laneSection_lr_lane_access_rule (const e_road_lanes_laneSection_lr_lane_access_rule& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

  virtual e_road_lanes_laneSection_lr_lane_access_rule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_lanes_laneSection_lr_lane_access_rule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert ();
  }

  protected:
  value
  _xsd_e_road_lanes_laneSection_lr_lane_access_rule_convert () const;

  public:
  static const char* const _xsd_e_road_lanes_laneSection_lr_lane_access_rule_literals_[2];
  static const value _xsd_e_road_lanes_laneSection_lr_lane_access_rule_indexes_[2];
};

class t_road_lanes_laneSection_lr_lane_height: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // inner
  //
  typedef ::xml_schema::double_ inner_type;
  typedef ::xsd::cxx::tree::traits< inner_type, char, ::xsd::cxx::tree::schema_type::double_ > inner_traits;

  const inner_type&
  inner () const;

  inner_type&
  inner ();

  void
  inner (const inner_type& x);

  // outer
  //
  typedef ::xml_schema::double_ outer_type;
  typedef ::xsd::cxx::tree::traits< outer_type, char, ::xsd::cxx::tree::schema_type::double_ > outer_traits;

  const outer_type&
  outer () const;

  outer_type&
  outer ();

  void
  outer (const outer_type& x);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_height (const sOffset_type&,
                                           const inner_type&,
                                           const outer_type&);

  t_road_lanes_laneSection_lr_lane_height (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_height (const t_road_lanes_laneSection_lr_lane_height& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_height*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_height&
  operator= (const t_road_lanes_laneSection_lr_lane_height& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_height ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< inner_type > inner_;
  ::xsd::cxx::tree::one< outer_type > outer_;
};

class t_road_lanes_laneSection_lr_lane_rule: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // sOffset
  //
  typedef ::t_grEqZero sOffset_type;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char > sOffset_traits;

  const sOffset_type&
  sOffset () const;

  sOffset_type&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (::std::unique_ptr< sOffset_type > p);

  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::unique_ptr< value_type > p);

  // Constructors.
  //
  t_road_lanes_laneSection_lr_lane_rule (const sOffset_type&,
                                         const value_type&);

  t_road_lanes_laneSection_lr_lane_rule (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  t_road_lanes_laneSection_lr_lane_rule (const t_road_lanes_laneSection_lr_lane_rule& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  virtual t_road_lanes_laneSection_lr_lane_rule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_lanes_laneSection_lr_lane_rule&
  operator= (const t_road_lanes_laneSection_lr_lane_rule& x);

  virtual 
  ~t_road_lanes_laneSection_lr_lane_rule ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< sOffset_type > sOffset_;
  ::xsd::cxx::tree::one< value_type > value_;
};

class t_road_objects: public ::xml_schema::type
{
  public:
  // object
  //
  typedef ::t_road_objects_object object_type;
  typedef ::xsd::cxx::tree::sequence< object_type > object_sequence;
  typedef object_sequence::iterator object_iterator;
  typedef object_sequence::const_iterator object_const_iterator;
  typedef ::xsd::cxx::tree::traits< object_type, char > object_traits;

  const object_sequence&
  object () const;

  object_sequence&
  object ();

  void
  object (const object_sequence& s);

  // objectReference
  //
  typedef ::t_road_objects_objectReference objectReference_type;
  typedef ::xsd::cxx::tree::sequence< objectReference_type > objectReference_sequence;
  typedef objectReference_sequence::iterator objectReference_iterator;
  typedef objectReference_sequence::const_iterator objectReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< objectReference_type, char > objectReference_traits;

  const objectReference_sequence&
  objectReference () const;

  objectReference_sequence&
  objectReference ();

  void
  objectReference (const objectReference_sequence& s);

  // tunnel
  //
  typedef ::t_road_objects_tunnel tunnel_type;
  typedef ::xsd::cxx::tree::sequence< tunnel_type > tunnel_sequence;
  typedef tunnel_sequence::iterator tunnel_iterator;
  typedef tunnel_sequence::const_iterator tunnel_const_iterator;
  typedef ::xsd::cxx::tree::traits< tunnel_type, char > tunnel_traits;

  const tunnel_sequence&
  tunnel () const;

  tunnel_sequence&
  tunnel ();

  void
  tunnel (const tunnel_sequence& s);

  // bridge
  //
  typedef ::t_road_objects_bridge bridge_type;
  typedef ::xsd::cxx::tree::sequence< bridge_type > bridge_sequence;
  typedef bridge_sequence::iterator bridge_iterator;
  typedef bridge_sequence::const_iterator bridge_const_iterator;
  typedef ::xsd::cxx::tree::traits< bridge_type, char > bridge_traits;

  const bridge_sequence&
  bridge () const;

  bridge_sequence&
  bridge ();

  void
  bridge (const bridge_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_objects ();

  t_road_objects (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  t_road_objects (const t_road_objects& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual t_road_objects*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects&
  operator= (const t_road_objects& x);

  virtual 
  ~t_road_objects ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  object_sequence object_;
  objectReference_sequence objectReference_;
  tunnel_sequence tunnel_;
  bridge_sequence bridge_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_objects_object: public ::xml_schema::type
{
  public:
  // repeat
  //
  typedef ::t_road_objects_object_repeat repeat_type;
  typedef ::xsd::cxx::tree::optional< repeat_type > repeat_optional;
  typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

  const repeat_optional&
  repeat () const;

  repeat_optional&
  repeat ();

  void
  repeat (const repeat_type& x);

  void
  repeat (const repeat_optional& x);

  void
  repeat (::std::unique_ptr< repeat_type > p);

  // outline
  //
  typedef ::t_road_objects_object_outlines_outline outline_type;
  typedef ::xsd::cxx::tree::optional< outline_type > outline_optional;
  typedef ::xsd::cxx::tree::traits< outline_type, char > outline_traits;

  const outline_optional&
  outline () const;

  outline_optional&
  outline ();

  void
  outline (const outline_type& x);

  void
  outline (const outline_optional& x);

  void
  outline (::std::unique_ptr< outline_type > p);

  // outlines
  //
  typedef ::t_road_objects_object_outlines outlines_type;
  typedef ::xsd::cxx::tree::optional< outlines_type > outlines_optional;
  typedef ::xsd::cxx::tree::traits< outlines_type, char > outlines_traits;

  const outlines_optional&
  outlines () const;

  outlines_optional&
  outlines ();

  void
  outlines (const outlines_type& x);

  void
  outlines (const outlines_optional& x);

  void
  outlines (::std::unique_ptr< outlines_type > p);

  // material
  //
  typedef ::t_road_objects_object_material material_type;
  typedef ::xsd::cxx::tree::sequence< material_type > material_sequence;
  typedef material_sequence::iterator material_iterator;
  typedef material_sequence::const_iterator material_const_iterator;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_sequence&
  material () const;

  material_sequence&
  material ();

  void
  material (const material_sequence& s);

  // validity
  //
  typedef ::t_road_objects_object_laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // parkingSpace
  //
  typedef ::t_road_objects_object_parkingSpace parkingSpace_type;
  typedef ::xsd::cxx::tree::optional< parkingSpace_type > parkingSpace_optional;
  typedef ::xsd::cxx::tree::traits< parkingSpace_type, char > parkingSpace_traits;

  const parkingSpace_optional&
  parkingSpace () const;

  parkingSpace_optional&
  parkingSpace ();

  void
  parkingSpace (const parkingSpace_type& x);

  void
  parkingSpace (const parkingSpace_optional& x);

  void
  parkingSpace (::std::unique_ptr< parkingSpace_type > p);

  // markings
  //
  typedef ::t_road_objects_object_markings markings_type;
  typedef ::xsd::cxx::tree::optional< markings_type > markings_optional;
  typedef ::xsd::cxx::tree::traits< markings_type, char > markings_traits;

  const markings_optional&
  markings () const;

  markings_optional&
  markings ();

  void
  markings (const markings_type& x);

  void
  markings (const markings_optional& x);

  void
  markings (::std::unique_ptr< markings_type > p);

  // borders
  //
  typedef ::t_road_objects_object_borders borders_type;
  typedef ::xsd::cxx::tree::optional< borders_type > borders_optional;
  typedef ::xsd::cxx::tree::traits< borders_type, char > borders_traits;

  const borders_optional&
  borders () const;

  borders_optional&
  borders ();

  void
  borders (const borders_type& x);

  void
  borders (const borders_optional& x);

  void
  borders (::std::unique_ptr< borders_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // type
  //
  typedef ::e_objectType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // subtype
  //
  typedef ::xml_schema::string subtype_type;
  typedef ::xsd::cxx::tree::optional< subtype_type > subtype_optional;
  typedef ::xsd::cxx::tree::traits< subtype_type, char > subtype_traits;

  const subtype_optional&
  subtype () const;

  subtype_optional&
  subtype ();

  void
  subtype (const subtype_type& x);

  void
  subtype (const subtype_optional& x);

  void
  subtype (::std::unique_ptr< subtype_type > p);

  // dynamic
  //
  typedef ::t_yesNo dynamic_type;
  typedef ::xsd::cxx::tree::traits< dynamic_type, char > dynamic_traits;

  const dynamic_type&
  dynamic () const;

  dynamic_type&
  dynamic ();

  void
  dynamic (const dynamic_type& x);

  void
  dynamic (::std::unique_ptr< dynamic_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_type&
  zOffset () const;

  zOffset_type&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  // validLength
  //
  typedef ::t_grEqZero validLength_type;
  typedef ::xsd::cxx::tree::traits< validLength_type, char > validLength_traits;

  const validLength_type&
  validLength () const;

  validLength_type&
  validLength ();

  void
  validLength (const validLength_type& x);

  void
  validLength (::std::unique_ptr< validLength_type > p);

  // orientation
  //
  typedef ::e_orientation orientation_type;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_type&
  orientation () const;

  orientation_type&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // hdg
  //
  typedef ::xml_schema::double_ hdg_type;
  typedef ::xsd::cxx::tree::traits< hdg_type, char, ::xsd::cxx::tree::schema_type::double_ > hdg_traits;

  const hdg_type&
  hdg () const;

  hdg_type&
  hdg ();

  void
  hdg (const hdg_type& x);

  // pitch
  //
  typedef ::xml_schema::double_ pitch_type;
  typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::double_ > pitch_traits;

  const pitch_type&
  pitch () const;

  pitch_type&
  pitch ();

  void
  pitch (const pitch_type& x);

  // roll
  //
  typedef ::xml_schema::double_ roll_type;
  typedef ::xsd::cxx::tree::traits< roll_type, char, ::xsd::cxx::tree::schema_type::double_ > roll_traits;

  const roll_type&
  roll () const;

  roll_type&
  roll ();

  void
  roll (const roll_type& x);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_type&
  height () const;

  height_type&
  height ();

  void
  height (const height_type& x);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // radius
  //
  typedef ::xml_schema::double_ radius_type;
  typedef ::xsd::cxx::tree::optional< radius_type > radius_optional;
  typedef ::xsd::cxx::tree::traits< radius_type, char, ::xsd::cxx::tree::schema_type::double_ > radius_traits;

  const radius_optional&
  radius () const;

  radius_optional&
  radius ();

  void
  radius (const radius_type& x);

  void
  radius (const radius_optional& x);

  // Constructors.
  //
  t_road_objects_object (const dynamic_type&,
                         const id_type&,
                         const s_type&,
                         const t_type&,
                         const zOffset_type&,
                         const validLength_type&,
                         const orientation_type&,
                         const hdg_type&,
                         const pitch_type&,
                         const roll_type&,
                         const height_type&);

  t_road_objects_object (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_road_objects_object (const t_road_objects_object& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_road_objects_object*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object&
  operator= (const t_road_objects_object& x);

  virtual 
  ~t_road_objects_object ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  repeat_optional repeat_;
  outline_optional outline_;
  outlines_optional outlines_;
  material_sequence material_;
  validity_sequence validity_;
  parkingSpace_optional parkingSpace_;
  markings_optional markings_;
  borders_optional borders_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  type_optional type_;
  subtype_optional subtype_;
  ::xsd::cxx::tree::one< dynamic_type > dynamic_;
  name_optional name_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< zOffset_type > zOffset_;
  ::xsd::cxx::tree::one< validLength_type > validLength_;
  ::xsd::cxx::tree::one< orientation_type > orientation_;
  ::xsd::cxx::tree::one< hdg_type > hdg_;
  ::xsd::cxx::tree::one< pitch_type > pitch_;
  ::xsd::cxx::tree::one< roll_type > roll_;
  ::xsd::cxx::tree::one< height_type > height_;
  length_optional length_;
  width_optional width_;
  radius_optional radius_;
};

class t_road_objects_object_repeat: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // length
  //
  typedef ::t_grEqZero length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::unique_ptr< length_type > p);

  // distance
  //
  typedef ::t_grEqZero distance_type;
  typedef ::xsd::cxx::tree::traits< distance_type, char > distance_traits;

  const distance_type&
  distance () const;

  distance_type&
  distance ();

  void
  distance (const distance_type& x);

  void
  distance (::std::unique_ptr< distance_type > p);

  // tStart
  //
  typedef ::xml_schema::double_ tStart_type;
  typedef ::xsd::cxx::tree::traits< tStart_type, char, ::xsd::cxx::tree::schema_type::double_ > tStart_traits;

  const tStart_type&
  tStart () const;

  tStart_type&
  tStart ();

  void
  tStart (const tStart_type& x);

  // tEnd
  //
  typedef ::xml_schema::double_ tEnd_type;
  typedef ::xsd::cxx::tree::traits< tEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > tEnd_traits;

  const tEnd_type&
  tEnd () const;

  tEnd_type&
  tEnd ();

  void
  tEnd (const tEnd_type& x);

  // heightStart
  //
  typedef ::xml_schema::double_ heightStart_type;
  typedef ::xsd::cxx::tree::traits< heightStart_type, char, ::xsd::cxx::tree::schema_type::double_ > heightStart_traits;

  const heightStart_type&
  heightStart () const;

  heightStart_type&
  heightStart ();

  void
  heightStart (const heightStart_type& x);

  // heightEnd
  //
  typedef ::xml_schema::double_ heightEnd_type;
  typedef ::xsd::cxx::tree::traits< heightEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > heightEnd_traits;

  const heightEnd_type&
  heightEnd () const;

  heightEnd_type&
  heightEnd ();

  void
  heightEnd (const heightEnd_type& x);

  // zOffsetStart
  //
  typedef ::xml_schema::double_ zOffsetStart_type;
  typedef ::xsd::cxx::tree::traits< zOffsetStart_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffsetStart_traits;

  const zOffsetStart_type&
  zOffsetStart () const;

  zOffsetStart_type&
  zOffsetStart ();

  void
  zOffsetStart (const zOffsetStart_type& x);

  // zOffsetEnd
  //
  typedef ::xml_schema::double_ zOffsetEnd_type;
  typedef ::xsd::cxx::tree::traits< zOffsetEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffsetEnd_traits;

  const zOffsetEnd_type&
  zOffsetEnd () const;

  zOffsetEnd_type&
  zOffsetEnd ();

  void
  zOffsetEnd (const zOffsetEnd_type& x);

  // widthStart
  //
  typedef ::t_grEqZero widthStart_type;
  typedef ::xsd::cxx::tree::traits< widthStart_type, char > widthStart_traits;

  const widthStart_type&
  widthStart () const;

  widthStart_type&
  widthStart ();

  void
  widthStart (const widthStart_type& x);

  void
  widthStart (::std::unique_ptr< widthStart_type > p);

  // widthEnd
  //
  typedef ::t_grEqZero widthEnd_type;
  typedef ::xsd::cxx::tree::traits< widthEnd_type, char > widthEnd_traits;

  const widthEnd_type&
  widthEnd () const;

  widthEnd_type&
  widthEnd ();

  void
  widthEnd (const widthEnd_type& x);

  void
  widthEnd (::std::unique_ptr< widthEnd_type > p);

  // lengthStart
  //
  typedef ::t_grEqZero lengthStart_type;
  typedef ::xsd::cxx::tree::optional< lengthStart_type > lengthStart_optional;
  typedef ::xsd::cxx::tree::traits< lengthStart_type, char > lengthStart_traits;

  const lengthStart_optional&
  lengthStart () const;

  lengthStart_optional&
  lengthStart ();

  void
  lengthStart (const lengthStart_type& x);

  void
  lengthStart (const lengthStart_optional& x);

  void
  lengthStart (::std::unique_ptr< lengthStart_type > p);

  // lengthEnd
  //
  typedef ::t_grEqZero lengthEnd_type;
  typedef ::xsd::cxx::tree::optional< lengthEnd_type > lengthEnd_optional;
  typedef ::xsd::cxx::tree::traits< lengthEnd_type, char > lengthEnd_traits;

  const lengthEnd_optional&
  lengthEnd () const;

  lengthEnd_optional&
  lengthEnd ();

  void
  lengthEnd (const lengthEnd_type& x);

  void
  lengthEnd (const lengthEnd_optional& x);

  void
  lengthEnd (::std::unique_ptr< lengthEnd_type > p);

  // radiusStart
  //
  typedef ::t_grEqZero radiusStart_type;
  typedef ::xsd::cxx::tree::optional< radiusStart_type > radiusStart_optional;
  typedef ::xsd::cxx::tree::traits< radiusStart_type, char > radiusStart_traits;

  const radiusStart_optional&
  radiusStart () const;

  radiusStart_optional&
  radiusStart ();

  void
  radiusStart (const radiusStart_type& x);

  void
  radiusStart (const radiusStart_optional& x);

  void
  radiusStart (::std::unique_ptr< radiusStart_type > p);

  // radiusEnd
  //
  typedef ::t_grEqZero radiusEnd_type;
  typedef ::xsd::cxx::tree::optional< radiusEnd_type > radiusEnd_optional;
  typedef ::xsd::cxx::tree::traits< radiusEnd_type, char > radiusEnd_traits;

  const radiusEnd_optional&
  radiusEnd () const;

  radiusEnd_optional&
  radiusEnd ();

  void
  radiusEnd (const radiusEnd_type& x);

  void
  radiusEnd (const radiusEnd_optional& x);

  void
  radiusEnd (::std::unique_ptr< radiusEnd_type > p);

  // Constructors.
  //
  t_road_objects_object_repeat (const s_type&,
                                const length_type&,
                                const distance_type&,
                                const tStart_type&,
                                const tEnd_type&,
                                const heightStart_type&,
                                const heightEnd_type&,
                                const zOffsetStart_type&,
                                const zOffsetEnd_type&,
                                const widthStart_type&,
                                const widthEnd_type&);

  t_road_objects_object_repeat (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  t_road_objects_object_repeat (const t_road_objects_object_repeat& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual t_road_objects_object_repeat*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_repeat&
  operator= (const t_road_objects_object_repeat& x);

  virtual 
  ~t_road_objects_object_repeat ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< length_type > length_;
  ::xsd::cxx::tree::one< distance_type > distance_;
  ::xsd::cxx::tree::one< tStart_type > tStart_;
  ::xsd::cxx::tree::one< tEnd_type > tEnd_;
  ::xsd::cxx::tree::one< heightStart_type > heightStart_;
  ::xsd::cxx::tree::one< heightEnd_type > heightEnd_;
  ::xsd::cxx::tree::one< zOffsetStart_type > zOffsetStart_;
  ::xsd::cxx::tree::one< zOffsetEnd_type > zOffsetEnd_;
  ::xsd::cxx::tree::one< widthStart_type > widthStart_;
  ::xsd::cxx::tree::one< widthEnd_type > widthEnd_;
  lengthStart_optional lengthStart_;
  lengthEnd_optional lengthEnd_;
  radiusStart_optional radiusStart_;
  radiusEnd_optional radiusEnd_;
};

class t_road_objects_object_outlines: public ::xml_schema::type
{
  public:
  // outline
  //
  typedef ::t_road_objects_object_outlines_outline outline_type;
  typedef ::xsd::cxx::tree::sequence< outline_type > outline_sequence;
  typedef outline_sequence::iterator outline_iterator;
  typedef outline_sequence::const_iterator outline_const_iterator;
  typedef ::xsd::cxx::tree::traits< outline_type, char > outline_traits;

  const outline_sequence&
  outline () const;

  outline_sequence&
  outline ();

  void
  outline (const outline_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_objects_object_outlines ();

  t_road_objects_object_outlines (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_objects_object_outlines (const t_road_objects_object_outlines& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_objects_object_outlines*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_outlines&
  operator= (const t_road_objects_object_outlines& x);

  virtual 
  ~t_road_objects_object_outlines ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  outline_sequence outline_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_objects_object_outlines_outline: public ::xml_schema::type
{
  public:
  // cornerRoad
  //
  typedef ::t_road_objects_object_outlines_outline_cornerRoad cornerRoad_type;
  typedef ::xsd::cxx::tree::sequence< cornerRoad_type > cornerRoad_sequence;
  typedef cornerRoad_sequence::iterator cornerRoad_iterator;
  typedef cornerRoad_sequence::const_iterator cornerRoad_const_iterator;
  typedef ::xsd::cxx::tree::traits< cornerRoad_type, char > cornerRoad_traits;

  const cornerRoad_sequence&
  cornerRoad () const;

  cornerRoad_sequence&
  cornerRoad ();

  void
  cornerRoad (const cornerRoad_sequence& s);

  // cornerLocal
  //
  typedef ::t_road_objects_object_outlines_outline_cornerLocal cornerLocal_type;
  typedef ::xsd::cxx::tree::sequence< cornerLocal_type > cornerLocal_sequence;
  typedef cornerLocal_sequence::iterator cornerLocal_iterator;
  typedef cornerLocal_sequence::const_iterator cornerLocal_const_iterator;
  typedef ::xsd::cxx::tree::traits< cornerLocal_type, char > cornerLocal_traits;

  const cornerLocal_sequence&
  cornerLocal () const;

  cornerLocal_sequence&
  cornerLocal ();

  void
  cornerLocal (const cornerLocal_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::non_negative_integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // fillType
  //
  typedef ::e_outlineFillType fillType_type;
  typedef ::xsd::cxx::tree::traits< fillType_type, char > fillType_traits;

  const fillType_type&
  fillType () const;

  fillType_type&
  fillType ();

  void
  fillType (const fillType_type& x);

  void
  fillType (::std::unique_ptr< fillType_type > p);

  // outer
  //
  typedef ::t_bool outer_type;
  typedef ::xsd::cxx::tree::traits< outer_type, char > outer_traits;

  const outer_type&
  outer () const;

  outer_type&
  outer ();

  void
  outer (const outer_type& x);

  void
  outer (::std::unique_ptr< outer_type > p);

  // closed
  //
  typedef ::t_bool closed_type;
  typedef ::xsd::cxx::tree::traits< closed_type, char > closed_traits;

  const closed_type&
  closed () const;

  closed_type&
  closed ();

  void
  closed (const closed_type& x);

  void
  closed (::std::unique_ptr< closed_type > p);

  // laneType
  //
  typedef ::e_laneType laneType_type;
  typedef ::xsd::cxx::tree::traits< laneType_type, char > laneType_traits;

  const laneType_type&
  laneType () const;

  laneType_type&
  laneType ();

  void
  laneType (const laneType_type& x);

  void
  laneType (::std::unique_ptr< laneType_type > p);

  // Constructors.
  //
  t_road_objects_object_outlines_outline (const id_type&,
                                          const fillType_type&,
                                          const outer_type&,
                                          const closed_type&,
                                          const laneType_type&);

  t_road_objects_object_outlines_outline (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  t_road_objects_object_outlines_outline (const t_road_objects_object_outlines_outline& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  virtual t_road_objects_object_outlines_outline*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_outlines_outline&
  operator= (const t_road_objects_object_outlines_outline& x);

  virtual 
  ~t_road_objects_object_outlines_outline ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  cornerRoad_sequence cornerRoad_;
  cornerLocal_sequence cornerLocal_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< fillType_type > fillType_;
  ::xsd::cxx::tree::one< outer_type > outer_;
  ::xsd::cxx::tree::one< closed_type > closed_;
  ::xsd::cxx::tree::one< laneType_type > laneType_;
};

class t_road_objects_object_outlines_outline_cornerRoad: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // dz
  //
  typedef ::xml_schema::double_ dz_type;
  typedef ::xsd::cxx::tree::traits< dz_type, char, ::xsd::cxx::tree::schema_type::double_ > dz_traits;

  const dz_type&
  dz () const;

  dz_type&
  dz ();

  void
  dz (const dz_type& x);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_type&
  height () const;

  height_type&
  height ();

  void
  height (const height_type& x);

  // id
  //
  typedef ::xml_schema::non_negative_integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // Constructors.
  //
  t_road_objects_object_outlines_outline_cornerRoad (const s_type&,
                                                     const t_type&,
                                                     const dz_type&,
                                                     const height_type&,
                                                     const id_type&);

  t_road_objects_object_outlines_outline_cornerRoad (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

  t_road_objects_object_outlines_outline_cornerRoad (const t_road_objects_object_outlines_outline_cornerRoad& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

  virtual t_road_objects_object_outlines_outline_cornerRoad*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_outlines_outline_cornerRoad&
  operator= (const t_road_objects_object_outlines_outline_cornerRoad& x);

  virtual 
  ~t_road_objects_object_outlines_outline_cornerRoad ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< dz_type > dz_;
  ::xsd::cxx::tree::one< height_type > height_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_road_objects_object_outlines_outline_cornerLocal: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // u
  //
  typedef ::xml_schema::double_ u_type;
  typedef ::xsd::cxx::tree::traits< u_type, char, ::xsd::cxx::tree::schema_type::double_ > u_traits;

  const u_type&
  u () const;

  u_type&
  u ();

  void
  u (const u_type& x);

  // v
  //
  typedef ::xml_schema::double_ v_type;
  typedef ::xsd::cxx::tree::traits< v_type, char, ::xsd::cxx::tree::schema_type::double_ > v_traits;

  const v_type&
  v () const;

  v_type&
  v ();

  void
  v (const v_type& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_type&
  z () const;

  z_type&
  z ();

  void
  z (const z_type& x);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_type&
  height () const;

  height_type&
  height ();

  void
  height (const height_type& x);

  // id
  //
  typedef ::xml_schema::non_negative_integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // Constructors.
  //
  t_road_objects_object_outlines_outline_cornerLocal (const u_type&,
                                                      const v_type&,
                                                      const z_type&,
                                                      const height_type&,
                                                      const id_type&);

  t_road_objects_object_outlines_outline_cornerLocal (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

  t_road_objects_object_outlines_outline_cornerLocal (const t_road_objects_object_outlines_outline_cornerLocal& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

  virtual t_road_objects_object_outlines_outline_cornerLocal*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_outlines_outline_cornerLocal&
  operator= (const t_road_objects_object_outlines_outline_cornerLocal& x);

  virtual 
  ~t_road_objects_object_outlines_outline_cornerLocal ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< u_type > u_;
  ::xsd::cxx::tree::one< v_type > v_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< height_type > height_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_road_objects_object_material: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // surface
  //
  typedef ::xml_schema::string surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::unique_ptr< surface_type > p);

  // friction
  //
  typedef ::t_grEqZero friction_type;
  typedef ::xsd::cxx::tree::optional< friction_type > friction_optional;
  typedef ::xsd::cxx::tree::traits< friction_type, char > friction_traits;

  const friction_optional&
  friction () const;

  friction_optional&
  friction ();

  void
  friction (const friction_type& x);

  void
  friction (const friction_optional& x);

  void
  friction (::std::unique_ptr< friction_type > p);

  // roughness
  //
  typedef ::t_grEqZero roughness_type;
  typedef ::xsd::cxx::tree::optional< roughness_type > roughness_optional;
  typedef ::xsd::cxx::tree::traits< roughness_type, char > roughness_traits;

  const roughness_optional&
  roughness () const;

  roughness_optional&
  roughness ();

  void
  roughness (const roughness_type& x);

  void
  roughness (const roughness_optional& x);

  void
  roughness (::std::unique_ptr< roughness_type > p);

  // Constructors.
  //
  t_road_objects_object_material ();

  t_road_objects_object_material (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_objects_object_material (const t_road_objects_object_material& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_objects_object_material*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_material&
  operator= (const t_road_objects_object_material& x);

  virtual 
  ~t_road_objects_object_material ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  surface_optional surface_;
  friction_optional friction_;
  roughness_optional roughness_;
};

class t_road_objects_object_laneValidity: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // fromLane
  //
  typedef ::xml_schema::integer fromLane_type;
  typedef ::xsd::cxx::tree::traits< fromLane_type, char > fromLane_traits;

  const fromLane_type&
  fromLane () const;

  fromLane_type&
  fromLane ();

  void
  fromLane (const fromLane_type& x);

  // toLane
  //
  typedef ::xml_schema::integer toLane_type;
  typedef ::xsd::cxx::tree::traits< toLane_type, char > toLane_traits;

  const toLane_type&
  toLane () const;

  toLane_type&
  toLane ();

  void
  toLane (const toLane_type& x);

  // Constructors.
  //
  t_road_objects_object_laneValidity (const fromLane_type&,
                                      const toLane_type&);

  t_road_objects_object_laneValidity (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  t_road_objects_object_laneValidity (const t_road_objects_object_laneValidity& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual t_road_objects_object_laneValidity*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_laneValidity&
  operator= (const t_road_objects_object_laneValidity& x);

  virtual 
  ~t_road_objects_object_laneValidity ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< fromLane_type > fromLane_;
  ::xsd::cxx::tree::one< toLane_type > toLane_;
};

class t_road_objects_object_parkingSpace: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // access
  //
  typedef ::e_road_objects_object_parkingSpace_access access_type;
  typedef ::xsd::cxx::tree::traits< access_type, char > access_traits;

  const access_type&
  access () const;

  access_type&
  access ();

  void
  access (const access_type& x);

  void
  access (::std::unique_ptr< access_type > p);

  // restrictions
  //
  typedef ::xml_schema::string restrictions_type;
  typedef ::xsd::cxx::tree::optional< restrictions_type > restrictions_optional;
  typedef ::xsd::cxx::tree::traits< restrictions_type, char > restrictions_traits;

  const restrictions_optional&
  restrictions () const;

  restrictions_optional&
  restrictions ();

  void
  restrictions (const restrictions_type& x);

  void
  restrictions (const restrictions_optional& x);

  void
  restrictions (::std::unique_ptr< restrictions_type > p);

  // Constructors.
  //
  t_road_objects_object_parkingSpace (const access_type&);

  t_road_objects_object_parkingSpace (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  t_road_objects_object_parkingSpace (const t_road_objects_object_parkingSpace& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual t_road_objects_object_parkingSpace*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_parkingSpace&
  operator= (const t_road_objects_object_parkingSpace& x);

  virtual 
  ~t_road_objects_object_parkingSpace ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< access_type > access_;
  restrictions_optional restrictions_;
};

class e_road_objects_object_parkingSpace_access: public ::xml_schema::string
{
  public:
  enum value
  {
    all,
    car,
    women,
    handicapped,
    bus,
    truck,
    electric,
    residents
  };

  e_road_objects_object_parkingSpace_access (value v);

  e_road_objects_object_parkingSpace_access (const char* v);

  e_road_objects_object_parkingSpace_access (const ::std::string& v);

  e_road_objects_object_parkingSpace_access (const ::xml_schema::string& v);

  e_road_objects_object_parkingSpace_access (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  e_road_objects_object_parkingSpace_access (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  e_road_objects_object_parkingSpace_access (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  e_road_objects_object_parkingSpace_access (const e_road_objects_object_parkingSpace_access& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual e_road_objects_object_parkingSpace_access*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_objects_object_parkingSpace_access&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_objects_object_parkingSpace_access_convert ();
  }

  protected:
  value
  _xsd_e_road_objects_object_parkingSpace_access_convert () const;

  public:
  static const char* const _xsd_e_road_objects_object_parkingSpace_access_literals_[8];
  static const value _xsd_e_road_objects_object_parkingSpace_access_indexes_[8];
};

class t_road_objects_object_markings: public ::xml_schema::type
{
  public:
  // marking
  //
  typedef ::t_road_objects_object_markings_marking marking_type;
  typedef ::xsd::cxx::tree::sequence< marking_type > marking_sequence;
  typedef marking_sequence::iterator marking_iterator;
  typedef marking_sequence::const_iterator marking_const_iterator;
  typedef ::xsd::cxx::tree::traits< marking_type, char > marking_traits;

  const marking_sequence&
  marking () const;

  marking_sequence&
  marking ();

  void
  marking (const marking_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_objects_object_markings ();

  t_road_objects_object_markings (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_objects_object_markings (const t_road_objects_object_markings& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_objects_object_markings*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_markings&
  operator= (const t_road_objects_object_markings& x);

  virtual 
  ~t_road_objects_object_markings ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  marking_sequence marking_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_objects_object_markings_marking: public ::xml_schema::type
{
  public:
  // cornerReference
  //
  typedef ::t_road_objects_object_markings_marking_cornerReference cornerReference_type;
  typedef ::xsd::cxx::tree::sequence< cornerReference_type > cornerReference_sequence;
  typedef cornerReference_sequence::iterator cornerReference_iterator;
  typedef cornerReference_sequence::const_iterator cornerReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< cornerReference_type, char > cornerReference_traits;

  const cornerReference_sequence&
  cornerReference () const;

  cornerReference_sequence&
  cornerReference ();

  void
  cornerReference (const cornerReference_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // side
  //
  typedef ::e_sideType side_type;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_type&
  side () const;

  side_type&
  side ();

  void
  side (const side_type& x);

  void
  side (::std::unique_ptr< side_type > p);

  // weight
  //
  typedef ::e_roadMarkWeight weight_type;
  typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

  const weight_type&
  weight () const;

  weight_type&
  weight ();

  void
  weight (const weight_type& x);

  void
  weight (::std::unique_ptr< weight_type > p);

  // width
  //
  typedef ::t_grEqZero width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  void
  width (::std::unique_ptr< width_type > p);

  // color
  //
  typedef ::e_roadMarkColor color_type;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_type&
  color () const;

  color_type&
  color ();

  void
  color (const color_type& x);

  void
  color (::std::unique_ptr< color_type > p);

  // zOffset
  //
  typedef ::t_grEqZero zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  void
  zOffset (::std::unique_ptr< zOffset_type > p);

  // spaceLength
  //
  typedef ::t_grEqZero spaceLength_type;
  typedef ::xsd::cxx::tree::traits< spaceLength_type, char > spaceLength_traits;

  const spaceLength_type&
  spaceLength () const;

  spaceLength_type&
  spaceLength ();

  void
  spaceLength (const spaceLength_type& x);

  void
  spaceLength (::std::unique_ptr< spaceLength_type > p);

  // lineLength
  //
  typedef ::t_grEqZero lineLength_type;
  typedef ::xsd::cxx::tree::traits< lineLength_type, char > lineLength_traits;

  const lineLength_type&
  lineLength () const;

  lineLength_type&
  lineLength ();

  void
  lineLength (const lineLength_type& x);

  void
  lineLength (::std::unique_ptr< lineLength_type > p);

  // startOffset
  //
  typedef ::xml_schema::double_ startOffset_type;
  typedef ::xsd::cxx::tree::traits< startOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > startOffset_traits;

  const startOffset_type&
  startOffset () const;

  startOffset_type&
  startOffset ();

  void
  startOffset (const startOffset_type& x);

  // stopOffset
  //
  typedef ::xml_schema::double_ stopOffset_type;
  typedef ::xsd::cxx::tree::traits< stopOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > stopOffset_traits;

  const stopOffset_type&
  stopOffset () const;

  stopOffset_type&
  stopOffset ();

  void
  stopOffset (const stopOffset_type& x);

  // Constructors.
  //
  t_road_objects_object_markings_marking (const side_type&,
                                          const weight_type&,
                                          const color_type&,
                                          const spaceLength_type&,
                                          const lineLength_type&,
                                          const startOffset_type&,
                                          const stopOffset_type&);

  t_road_objects_object_markings_marking (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  t_road_objects_object_markings_marking (const t_road_objects_object_markings_marking& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  virtual t_road_objects_object_markings_marking*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_markings_marking&
  operator= (const t_road_objects_object_markings_marking& x);

  virtual 
  ~t_road_objects_object_markings_marking ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  cornerReference_sequence cornerReference_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< side_type > side_;
  ::xsd::cxx::tree::one< weight_type > weight_;
  width_optional width_;
  ::xsd::cxx::tree::one< color_type > color_;
  zOffset_optional zOffset_;
  ::xsd::cxx::tree::one< spaceLength_type > spaceLength_;
  ::xsd::cxx::tree::one< lineLength_type > lineLength_;
  ::xsd::cxx::tree::one< startOffset_type > startOffset_;
  ::xsd::cxx::tree::one< stopOffset_type > stopOffset_;
};

class t_road_objects_object_markings_marking_cornerReference: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::non_negative_integer id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  // Constructors.
  //
  t_road_objects_object_markings_marking_cornerReference (const id_type&);

  t_road_objects_object_markings_marking_cornerReference (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

  t_road_objects_object_markings_marking_cornerReference (const t_road_objects_object_markings_marking_cornerReference& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

  virtual t_road_objects_object_markings_marking_cornerReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_markings_marking_cornerReference&
  operator= (const t_road_objects_object_markings_marking_cornerReference& x);

  virtual 
  ~t_road_objects_object_markings_marking_cornerReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_road_objects_object_borders: public ::xml_schema::type
{
  public:
  // border
  //
  typedef ::t_road_objects_object_borders_border border_type;
  typedef ::xsd::cxx::tree::sequence< border_type > border_sequence;
  typedef border_sequence::iterator border_iterator;
  typedef border_sequence::const_iterator border_const_iterator;
  typedef ::xsd::cxx::tree::traits< border_type, char > border_traits;

  const border_sequence&
  border () const;

  border_sequence&
  border ();

  void
  border (const border_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_objects_object_borders ();

  t_road_objects_object_borders (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  t_road_objects_object_borders (const t_road_objects_object_borders& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual t_road_objects_object_borders*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_borders&
  operator= (const t_road_objects_object_borders& x);

  virtual 
  ~t_road_objects_object_borders ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  border_sequence border_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_objects_object_borders_border: public ::xml_schema::type
{
  public:
  // cornerReference
  //
  typedef ::t_road_objects_object_markings_marking_cornerReference cornerReference_type;
  typedef ::xsd::cxx::tree::sequence< cornerReference_type > cornerReference_sequence;
  typedef cornerReference_sequence::iterator cornerReference_iterator;
  typedef cornerReference_sequence::const_iterator cornerReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< cornerReference_type, char > cornerReference_traits;

  const cornerReference_sequence&
  cornerReference () const;

  cornerReference_sequence&
  cornerReference ();

  void
  cornerReference (const cornerReference_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // width
  //
  typedef ::t_grEqZero width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  void
  width (::std::unique_ptr< width_type > p);

  // type
  //
  typedef ::e_borderType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // outlineId
  //
  typedef ::xml_schema::non_negative_integer outlineId_type;
  typedef ::xsd::cxx::tree::traits< outlineId_type, char > outlineId_traits;

  const outlineId_type&
  outlineId () const;

  outlineId_type&
  outlineId ();

  void
  outlineId (const outlineId_type& x);

  // useCompleteOutline
  //
  typedef ::t_bool useCompleteOutline_type;
  typedef ::xsd::cxx::tree::optional< useCompleteOutline_type > useCompleteOutline_optional;
  typedef ::xsd::cxx::tree::traits< useCompleteOutline_type, char > useCompleteOutline_traits;

  const useCompleteOutline_optional&
  useCompleteOutline () const;

  useCompleteOutline_optional&
  useCompleteOutline ();

  void
  useCompleteOutline (const useCompleteOutline_type& x);

  void
  useCompleteOutline (const useCompleteOutline_optional& x);

  void
  useCompleteOutline (::std::unique_ptr< useCompleteOutline_type > p);

  // Constructors.
  //
  t_road_objects_object_borders_border (const width_type&,
                                        const type_type&,
                                        const outlineId_type&);

  t_road_objects_object_borders_border (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  t_road_objects_object_borders_border (const t_road_objects_object_borders_border& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual t_road_objects_object_borders_border*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_object_borders_border&
  operator= (const t_road_objects_object_borders_border& x);

  virtual 
  ~t_road_objects_object_borders_border ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  cornerReference_sequence cornerReference_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< width_type > width_;
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< outlineId_type > outlineId_;
  useCompleteOutline_optional useCompleteOutline_;
};

class t_road_objects_objectReference: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::t_road_objects_object_laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_type&
  zOffset () const;

  zOffset_type&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  // validLength
  //
  typedef ::t_grEqZero validLength_type;
  typedef ::xsd::cxx::tree::traits< validLength_type, char > validLength_traits;

  const validLength_type&
  validLength () const;

  validLength_type&
  validLength ();

  void
  validLength (const validLength_type& x);

  void
  validLength (::std::unique_ptr< validLength_type > p);

  // orientation
  //
  typedef ::e_orientation orientation_type;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_type&
  orientation () const;

  orientation_type&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // Constructors.
  //
  t_road_objects_objectReference (const s_type&,
                                  const t_type&,
                                  const id_type&,
                                  const zOffset_type&,
                                  const validLength_type&,
                                  const orientation_type&);

  t_road_objects_objectReference (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_objects_objectReference (const t_road_objects_objectReference& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_objects_objectReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_objectReference&
  operator= (const t_road_objects_objectReference& x);

  virtual 
  ~t_road_objects_objectReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< zOffset_type > zOffset_;
  ::xsd::cxx::tree::one< validLength_type > validLength_;
  ::xsd::cxx::tree::one< orientation_type > orientation_;
};

class t_road_objects_tunnel: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::t_road_objects_object_laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // length
  //
  typedef ::t_grEqZero length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::unique_ptr< length_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::e_tunnelType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // lighting
  //
  typedef ::t_zeroOne lighting_type;
  typedef ::xsd::cxx::tree::optional< lighting_type > lighting_optional;
  typedef ::xsd::cxx::tree::traits< lighting_type, char > lighting_traits;

  const lighting_optional&
  lighting () const;

  lighting_optional&
  lighting ();

  void
  lighting (const lighting_type& x);

  void
  lighting (const lighting_optional& x);

  void
  lighting (::std::unique_ptr< lighting_type > p);

  // daylight
  //
  typedef ::t_zeroOne daylight_type;
  typedef ::xsd::cxx::tree::optional< daylight_type > daylight_optional;
  typedef ::xsd::cxx::tree::traits< daylight_type, char > daylight_traits;

  const daylight_optional&
  daylight () const;

  daylight_optional&
  daylight ();

  void
  daylight (const daylight_type& x);

  void
  daylight (const daylight_optional& x);

  void
  daylight (::std::unique_ptr< daylight_type > p);

  // Constructors.
  //
  t_road_objects_tunnel (const s_type&,
                         const length_type&,
                         const id_type&,
                         const type_type&);

  t_road_objects_tunnel (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_road_objects_tunnel (const t_road_objects_tunnel& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_road_objects_tunnel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_tunnel&
  operator= (const t_road_objects_tunnel& x);

  virtual 
  ~t_road_objects_tunnel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< length_type > length_;
  name_optional name_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< type_type > type_;
  lighting_optional lighting_;
  daylight_optional daylight_;
};

class t_road_objects_bridge: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::t_road_objects_object_laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // length
  //
  typedef ::t_grEqZero length_type;
  typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

  const length_type&
  length () const;

  length_type&
  length ();

  void
  length (const length_type& x);

  void
  length (::std::unique_ptr< length_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::e_bridgeType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_road_objects_bridge (const s_type&,
                         const length_type&,
                         const id_type&,
                         const type_type&);

  t_road_objects_bridge (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_road_objects_bridge (const t_road_objects_bridge& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_road_objects_bridge*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_objects_bridge&
  operator= (const t_road_objects_bridge& x);

  virtual 
  ~t_road_objects_bridge ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< length_type > length_;
  name_optional name_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< type_type > type_;
};

class t_road_signals: public ::xml_schema::type
{
  public:
  // signal
  //
  typedef ::t_road_signals_signal signal_type;
  typedef ::xsd::cxx::tree::sequence< signal_type > signal_sequence;
  typedef signal_sequence::iterator signal_iterator;
  typedef signal_sequence::const_iterator signal_const_iterator;
  typedef ::xsd::cxx::tree::traits< signal_type, char > signal_traits;

  const signal_sequence&
  signal () const;

  signal_sequence&
  signal ();

  void
  signal (const signal_sequence& s);

  // signalReference
  //
  typedef ::t_road_signals_signalReference signalReference_type;
  typedef ::xsd::cxx::tree::sequence< signalReference_type > signalReference_sequence;
  typedef signalReference_sequence::iterator signalReference_iterator;
  typedef signalReference_sequence::const_iterator signalReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< signalReference_type, char > signalReference_traits;

  const signalReference_sequence&
  signalReference () const;

  signalReference_sequence&
  signalReference ();

  void
  signalReference (const signalReference_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_signals ();

  t_road_signals (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  t_road_signals (const t_road_signals& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual t_road_signals*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_signals&
  operator= (const t_road_signals& x);

  virtual 
  ~t_road_signals ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  signal_sequence signal_;
  signalReference_sequence signalReference_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_signals_signal: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::t_road_objects_object_laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // dependency
  //
  typedef ::t_road_signals_signal_dependency dependency_type;
  typedef ::xsd::cxx::tree::sequence< dependency_type > dependency_sequence;
  typedef dependency_sequence::iterator dependency_iterator;
  typedef dependency_sequence::const_iterator dependency_const_iterator;
  typedef ::xsd::cxx::tree::traits< dependency_type, char > dependency_traits;

  const dependency_sequence&
  dependency () const;

  dependency_sequence&
  dependency ();

  void
  dependency (const dependency_sequence& s);

  // reference
  //
  typedef ::t_road_signals_signal_reference reference_type;
  typedef ::xsd::cxx::tree::sequence< reference_type > reference_sequence;
  typedef reference_sequence::iterator reference_iterator;
  typedef reference_sequence::const_iterator reference_const_iterator;
  typedef ::xsd::cxx::tree::traits< reference_type, char > reference_traits;

  const reference_sequence&
  reference () const;

  reference_sequence&
  reference ();

  void
  reference (const reference_sequence& s);

  // positionRoad
  //
  typedef ::t_road_signals_signal_positionRoad positionRoad_type;
  typedef ::xsd::cxx::tree::optional< positionRoad_type > positionRoad_optional;
  typedef ::xsd::cxx::tree::traits< positionRoad_type, char > positionRoad_traits;

  const positionRoad_optional&
  positionRoad () const;

  positionRoad_optional&
  positionRoad ();

  void
  positionRoad (const positionRoad_type& x);

  void
  positionRoad (const positionRoad_optional& x);

  void
  positionRoad (::std::unique_ptr< positionRoad_type > p);

  // positionInertial
  //
  typedef ::t_road_signals_signal_positionInertial positionInertial_type;
  typedef ::xsd::cxx::tree::optional< positionInertial_type > positionInertial_optional;
  typedef ::xsd::cxx::tree::traits< positionInertial_type, char > positionInertial_traits;

  const positionInertial_optional&
  positionInertial () const;

  positionInertial_optional&
  positionInertial ();

  void
  positionInertial (const positionInertial_type& x);

  void
  positionInertial (const positionInertial_optional& x);

  void
  positionInertial (::std::unique_ptr< positionInertial_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // dynamic
  //
  typedef ::t_yesNo dynamic_type;
  typedef ::xsd::cxx::tree::traits< dynamic_type, char > dynamic_traits;

  const dynamic_type&
  dynamic () const;

  dynamic_type&
  dynamic ();

  void
  dynamic (const dynamic_type& x);

  void
  dynamic (::std::unique_ptr< dynamic_type > p);

  // orientation
  //
  typedef ::e_orientation orientation_type;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_type&
  orientation () const;

  orientation_type&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_type&
  zOffset () const;

  zOffset_type&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  // country
  //
  typedef ::e_countryCode country_type;
  typedef ::xsd::cxx::tree::optional< country_type > country_optional;
  typedef ::xsd::cxx::tree::traits< country_type, char > country_traits;

  const country_optional&
  country () const;

  country_optional&
  country ();

  void
  country (const country_type& x);

  void
  country (const country_optional& x);

  void
  country (::std::unique_ptr< country_type > p);

  // countryRevision
  //
  typedef ::xml_schema::string countryRevision_type;
  typedef ::xsd::cxx::tree::optional< countryRevision_type > countryRevision_optional;
  typedef ::xsd::cxx::tree::traits< countryRevision_type, char > countryRevision_traits;

  const countryRevision_optional&
  countryRevision () const;

  countryRevision_optional&
  countryRevision ();

  void
  countryRevision (const countryRevision_type& x);

  void
  countryRevision (const countryRevision_optional& x);

  void
  countryRevision (::std::unique_ptr< countryRevision_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // subtype
  //
  typedef ::xml_schema::string subtype_type;
  typedef ::xsd::cxx::tree::traits< subtype_type, char > subtype_traits;

  const subtype_type&
  subtype () const;

  subtype_type&
  subtype ();

  void
  subtype (const subtype_type& x);

  void
  subtype (::std::unique_ptr< subtype_type > p);

  // value
  //
  typedef ::xml_schema::double_ value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  // unit
  //
  typedef ::e_unit unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::unique_ptr< unit_type > p);

  // height
  //
  typedef ::t_grEqZero height_type;
  typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

  const height_type&
  height () const;

  height_type&
  height ();

  void
  height (const height_type& x);

  void
  height (::std::unique_ptr< height_type > p);

  // width
  //
  typedef ::t_grEqZero width_type;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_type&
  width () const;

  width_type&
  width ();

  void
  width (const width_type& x);

  void
  width (::std::unique_ptr< width_type > p);

  // text
  //
  typedef ::xml_schema::string text_type;
  typedef ::xsd::cxx::tree::optional< text_type > text_optional;
  typedef ::xsd::cxx::tree::traits< text_type, char > text_traits;

  const text_optional&
  text () const;

  text_optional&
  text ();

  void
  text (const text_type& x);

  void
  text (const text_optional& x);

  void
  text (::std::unique_ptr< text_type > p);

  // hOffset
  //
  typedef ::xml_schema::double_ hOffset_type;
  typedef ::xsd::cxx::tree::optional< hOffset_type > hOffset_optional;
  typedef ::xsd::cxx::tree::traits< hOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > hOffset_traits;

  const hOffset_optional&
  hOffset () const;

  hOffset_optional&
  hOffset ();

  void
  hOffset (const hOffset_type& x);

  void
  hOffset (const hOffset_optional& x);

  // pitch
  //
  typedef ::xml_schema::double_ pitch_type;
  typedef ::xsd::cxx::tree::optional< pitch_type > pitch_optional;
  typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::double_ > pitch_traits;

  const pitch_optional&
  pitch () const;

  pitch_optional&
  pitch ();

  void
  pitch (const pitch_type& x);

  void
  pitch (const pitch_optional& x);

  // roll
  //
  typedef ::xml_schema::double_ roll_type;
  typedef ::xsd::cxx::tree::optional< roll_type > roll_optional;
  typedef ::xsd::cxx::tree::traits< roll_type, char, ::xsd::cxx::tree::schema_type::double_ > roll_traits;

  const roll_optional&
  roll () const;

  roll_optional&
  roll ();

  void
  roll (const roll_type& x);

  void
  roll (const roll_optional& x);

  // Constructors.
  //
  t_road_signals_signal (const s_type&,
                         const t_type&,
                         const id_type&,
                         const dynamic_type&,
                         const orientation_type&,
                         const zOffset_type&,
                         const type_type&,
                         const subtype_type&,
                         const height_type&,
                         const width_type&);

  t_road_signals_signal (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_road_signals_signal (const t_road_signals_signal& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_road_signals_signal*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_signals_signal&
  operator= (const t_road_signals_signal& x);

  virtual 
  ~t_road_signals_signal ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  dependency_sequence dependency_;
  reference_sequence reference_;
  positionRoad_optional positionRoad_;
  positionInertial_optional positionInertial_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< id_type > id_;
  name_optional name_;
  ::xsd::cxx::tree::one< dynamic_type > dynamic_;
  ::xsd::cxx::tree::one< orientation_type > orientation_;
  ::xsd::cxx::tree::one< zOffset_type > zOffset_;
  country_optional country_;
  countryRevision_optional countryRevision_;
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< subtype_type > subtype_;
  value_optional value_;
  unit_optional unit_;
  ::xsd::cxx::tree::one< height_type > height_;
  ::xsd::cxx::tree::one< width_type > width_;
  text_optional text_;
  hOffset_optional hOffset_;
  pitch_optional pitch_;
  roll_optional roll_;
};

class t_road_signals_signal_dependency: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_road_signals_signal_dependency (const id_type&);

  t_road_signals_signal_dependency (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  t_road_signals_signal_dependency (const t_road_signals_signal_dependency& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual t_road_signals_signal_dependency*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_signals_signal_dependency&
  operator= (const t_road_signals_signal_dependency& x);

  virtual 
  ~t_road_signals_signal_dependency ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
};

class t_road_signals_signal_reference: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // elementType
  //
  typedef ::e_road_signals_signal_reference_elementType elementType_type;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_type&
  elementType () const;

  elementType_type&
  elementType ();

  void
  elementType (const elementType_type& x);

  void
  elementType (::std::unique_ptr< elementType_type > p);

  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_type&
  elementId () const;

  elementId_type&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_road_signals_signal_reference (const elementType_type&,
                                   const elementId_type&);

  t_road_signals_signal_reference (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  t_road_signals_signal_reference (const t_road_signals_signal_reference& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual t_road_signals_signal_reference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_signals_signal_reference&
  operator= (const t_road_signals_signal_reference& x);

  virtual 
  ~t_road_signals_signal_reference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< elementType_type > elementType_;
  ::xsd::cxx::tree::one< elementId_type > elementId_;
  type_optional type_;
};

class e_road_signals_signal_reference_elementType: public ::xml_schema::string
{
  public:
  enum value
  {
    object,
    signal
  };

  e_road_signals_signal_reference_elementType (value v);

  e_road_signals_signal_reference_elementType (const char* v);

  e_road_signals_signal_reference_elementType (const ::std::string& v);

  e_road_signals_signal_reference_elementType (const ::xml_schema::string& v);

  e_road_signals_signal_reference_elementType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  e_road_signals_signal_reference_elementType (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  e_road_signals_signal_reference_elementType (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  e_road_signals_signal_reference_elementType (const e_road_signals_signal_reference_elementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  virtual e_road_signals_signal_reference_elementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_signals_signal_reference_elementType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_signals_signal_reference_elementType_convert ();
  }

  protected:
  value
  _xsd_e_road_signals_signal_reference_elementType_convert () const;

  public:
  static const char* const _xsd_e_road_signals_signal_reference_elementType_literals_[2];
  static const value _xsd_e_road_signals_signal_reference_elementType_indexes_[2];
};

class t_road_signals_signal_positionRoad: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // roadId
  //
  typedef ::xml_schema::string roadId_type;
  typedef ::xsd::cxx::tree::traits< roadId_type, char > roadId_traits;

  const roadId_type&
  roadId () const;

  roadId_type&
  roadId ();

  void
  roadId (const roadId_type& x);

  void
  roadId (::std::unique_ptr< roadId_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_type&
  zOffset () const;

  zOffset_type&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  // hOffset
  //
  typedef ::xml_schema::double_ hOffset_type;
  typedef ::xsd::cxx::tree::traits< hOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > hOffset_traits;

  const hOffset_type&
  hOffset () const;

  hOffset_type&
  hOffset ();

  void
  hOffset (const hOffset_type& x);

  // pitch
  //
  typedef ::xml_schema::double_ pitch_type;
  typedef ::xsd::cxx::tree::optional< pitch_type > pitch_optional;
  typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::double_ > pitch_traits;

  const pitch_optional&
  pitch () const;

  pitch_optional&
  pitch ();

  void
  pitch (const pitch_type& x);

  void
  pitch (const pitch_optional& x);

  // roll
  //
  typedef ::xml_schema::double_ roll_type;
  typedef ::xsd::cxx::tree::optional< roll_type > roll_optional;
  typedef ::xsd::cxx::tree::traits< roll_type, char, ::xsd::cxx::tree::schema_type::double_ > roll_traits;

  const roll_optional&
  roll () const;

  roll_optional&
  roll ();

  void
  roll (const roll_type& x);

  void
  roll (const roll_optional& x);

  // Constructors.
  //
  t_road_signals_signal_positionRoad (const roadId_type&,
                                      const s_type&,
                                      const t_type&,
                                      const zOffset_type&,
                                      const hOffset_type&);

  t_road_signals_signal_positionRoad (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  t_road_signals_signal_positionRoad (const t_road_signals_signal_positionRoad& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual t_road_signals_signal_positionRoad*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_signals_signal_positionRoad&
  operator= (const t_road_signals_signal_positionRoad& x);

  virtual 
  ~t_road_signals_signal_positionRoad ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< roadId_type > roadId_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< zOffset_type > zOffset_;
  ::xsd::cxx::tree::one< hOffset_type > hOffset_;
  pitch_optional pitch_;
  roll_optional roll_;
};

class t_road_signals_signal_positionInertial: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_type&
  x () const;

  x_type&
  x ();

  void
  x (const x_type& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_type&
  y () const;

  y_type&
  y ();

  void
  y (const y_type& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_type&
  z () const;

  z_type&
  z ();

  void
  z (const z_type& x);

  // hdg
  //
  typedef ::xml_schema::double_ hdg_type;
  typedef ::xsd::cxx::tree::traits< hdg_type, char, ::xsd::cxx::tree::schema_type::double_ > hdg_traits;

  const hdg_type&
  hdg () const;

  hdg_type&
  hdg ();

  void
  hdg (const hdg_type& x);

  // pitch
  //
  typedef ::xml_schema::double_ pitch_type;
  typedef ::xsd::cxx::tree::optional< pitch_type > pitch_optional;
  typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::double_ > pitch_traits;

  const pitch_optional&
  pitch () const;

  pitch_optional&
  pitch ();

  void
  pitch (const pitch_type& x);

  void
  pitch (const pitch_optional& x);

  // roll
  //
  typedef ::xml_schema::double_ roll_type;
  typedef ::xsd::cxx::tree::optional< roll_type > roll_optional;
  typedef ::xsd::cxx::tree::traits< roll_type, char, ::xsd::cxx::tree::schema_type::double_ > roll_traits;

  const roll_optional&
  roll () const;

  roll_optional&
  roll ();

  void
  roll (const roll_type& x);

  void
  roll (const roll_optional& x);

  // Constructors.
  //
  t_road_signals_signal_positionInertial (const x_type&,
                                          const y_type&,
                                          const z_type&,
                                          const hdg_type&);

  t_road_signals_signal_positionInertial (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  t_road_signals_signal_positionInertial (const t_road_signals_signal_positionInertial& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

  virtual t_road_signals_signal_positionInertial*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_signals_signal_positionInertial&
  operator= (const t_road_signals_signal_positionInertial& x);

  virtual 
  ~t_road_signals_signal_positionInertial ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;
  ::xsd::cxx::tree::one< hdg_type > hdg_;
  pitch_optional pitch_;
  roll_optional roll_;
};

class t_road_signals_signalReference: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::t_road_objects_object_laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_type&
  t () const;

  t_type&
  t ();

  void
  t (const t_type& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // orientation
  //
  typedef ::e_orientation orientation_type;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_type&
  orientation () const;

  orientation_type&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // Constructors.
  //
  t_road_signals_signalReference (const s_type&,
                                  const t_type&,
                                  const id_type&,
                                  const orientation_type&);

  t_road_signals_signalReference (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_signals_signalReference (const t_road_signals_signalReference& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_signals_signalReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_signals_signalReference&
  operator= (const t_road_signals_signalReference& x);

  virtual 
  ~t_road_signals_signalReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< t_type > t_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< orientation_type > orientation_;
};

class t_road_surface: public ::xml_schema::type
{
  public:
  // CRG
  //
  typedef ::t_road_surface_CRG CRG_type;
  typedef ::xsd::cxx::tree::sequence< CRG_type > CRG_sequence;
  typedef CRG_sequence::iterator CRG_iterator;
  typedef CRG_sequence::const_iterator CRG_const_iterator;
  typedef ::xsd::cxx::tree::traits< CRG_type, char > CRG_traits;

  const CRG_sequence&
  CRG () const;

  CRG_sequence&
  CRG ();

  void
  CRG (const CRG_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_surface ();

  t_road_surface (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  t_road_surface (const t_road_surface& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual t_road_surface*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_surface&
  operator= (const t_road_surface& x);

  virtual 
  ~t_road_surface ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  CRG_sequence CRG_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_surface_CRG: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // file
  //
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::unique_ptr< file_type > p);

  // sStart
  //
  typedef ::t_grEqZero sStart_type;
  typedef ::xsd::cxx::tree::traits< sStart_type, char > sStart_traits;

  const sStart_type&
  sStart () const;

  sStart_type&
  sStart ();

  void
  sStart (const sStart_type& x);

  void
  sStart (::std::unique_ptr< sStart_type > p);

  // sEnd
  //
  typedef ::t_grEqZero sEnd_type;
  typedef ::xsd::cxx::tree::traits< sEnd_type, char > sEnd_traits;

  const sEnd_type&
  sEnd () const;

  sEnd_type&
  sEnd ();

  void
  sEnd (const sEnd_type& x);

  void
  sEnd (::std::unique_ptr< sEnd_type > p);

  // orientation
  //
  typedef ::e_direction orientation_type;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_type&
  orientation () const;

  orientation_type&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // mode
  //
  typedef ::e_road_surface_CRG_mode mode_type;
  typedef ::xsd::cxx::tree::traits< mode_type, char > mode_traits;

  const mode_type&
  mode () const;

  mode_type&
  mode ();

  void
  mode (const mode_type& x);

  void
  mode (::std::unique_ptr< mode_type > p);

  // purpose
  //
  typedef ::e_road_surface_CRG_purpose purpose_type;
  typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
  typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

  const purpose_optional&
  purpose () const;

  purpose_optional&
  purpose ();

  void
  purpose (const purpose_type& x);

  void
  purpose (const purpose_optional& x);

  void
  purpose (::std::unique_ptr< purpose_type > p);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // tOffset
  //
  typedef ::xml_schema::double_ tOffset_type;
  typedef ::xsd::cxx::tree::optional< tOffset_type > tOffset_optional;
  typedef ::xsd::cxx::tree::traits< tOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > tOffset_traits;

  const tOffset_optional&
  tOffset () const;

  tOffset_optional&
  tOffset ();

  void
  tOffset (const tOffset_type& x);

  void
  tOffset (const tOffset_optional& x);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  // zScale
  //
  typedef ::xml_schema::double_ zScale_type;
  typedef ::xsd::cxx::tree::optional< zScale_type > zScale_optional;
  typedef ::xsd::cxx::tree::traits< zScale_type, char, ::xsd::cxx::tree::schema_type::double_ > zScale_traits;

  const zScale_optional&
  zScale () const;

  zScale_optional&
  zScale ();

  void
  zScale (const zScale_type& x);

  void
  zScale (const zScale_optional& x);

  // hOffset
  //
  typedef ::xml_schema::double_ hOffset_type;
  typedef ::xsd::cxx::tree::optional< hOffset_type > hOffset_optional;
  typedef ::xsd::cxx::tree::traits< hOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > hOffset_traits;

  const hOffset_optional&
  hOffset () const;

  hOffset_optional&
  hOffset ();

  void
  hOffset (const hOffset_type& x);

  void
  hOffset (const hOffset_optional& x);

  // Constructors.
  //
  t_road_surface_CRG (const file_type&,
                      const sStart_type&,
                      const sEnd_type&,
                      const orientation_type&,
                      const mode_type&);

  t_road_surface_CRG (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  t_road_surface_CRG (const t_road_surface_CRG& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual t_road_surface_CRG*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_surface_CRG&
  operator= (const t_road_surface_CRG& x);

  virtual 
  ~t_road_surface_CRG ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< file_type > file_;
  ::xsd::cxx::tree::one< sStart_type > sStart_;
  ::xsd::cxx::tree::one< sEnd_type > sEnd_;
  ::xsd::cxx::tree::one< orientation_type > orientation_;
  ::xsd::cxx::tree::one< mode_type > mode_;
  purpose_optional purpose_;
  sOffset_optional sOffset_;
  tOffset_optional tOffset_;
  zOffset_optional zOffset_;
  zScale_optional zScale_;
  hOffset_optional hOffset_;
};

class e_road_surface_CRG_purpose: public ::xml_schema::string
{
  public:
  enum value
  {
    elevation,
    friction
  };

  e_road_surface_CRG_purpose (value v);

  e_road_surface_CRG_purpose (const char* v);

  e_road_surface_CRG_purpose (const ::std::string& v);

  e_road_surface_CRG_purpose (const ::xml_schema::string& v);

  e_road_surface_CRG_purpose (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  e_road_surface_CRG_purpose (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  e_road_surface_CRG_purpose (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  e_road_surface_CRG_purpose (const e_road_surface_CRG_purpose& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  virtual e_road_surface_CRG_purpose*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_surface_CRG_purpose&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_surface_CRG_purpose_convert ();
  }

  protected:
  value
  _xsd_e_road_surface_CRG_purpose_convert () const;

  public:
  static const char* const _xsd_e_road_surface_CRG_purpose_literals_[2];
  static const value _xsd_e_road_surface_CRG_purpose_indexes_[2];
};

class e_road_surface_CRG_mode: public ::xml_schema::string
{
  public:
  enum value
  {
    attached,
    attached0,
    genuine,
    global
  };

  e_road_surface_CRG_mode (value v);

  e_road_surface_CRG_mode (const char* v);

  e_road_surface_CRG_mode (const ::std::string& v);

  e_road_surface_CRG_mode (const ::xml_schema::string& v);

  e_road_surface_CRG_mode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_surface_CRG_mode (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_surface_CRG_mode (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_road_surface_CRG_mode (const e_road_surface_CRG_mode& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual e_road_surface_CRG_mode*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_surface_CRG_mode&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_surface_CRG_mode_convert ();
  }

  protected:
  value
  _xsd_e_road_surface_CRG_mode_convert () const;

  public:
  static const char* const _xsd_e_road_surface_CRG_mode_literals_[4];
  static const value _xsd_e_road_surface_CRG_mode_indexes_[4];
};

class t_road_railroad: public ::xml_schema::type
{
  public:
  // switch
  //
  typedef ::t_road_railroad_switch switch_type;
  typedef ::xsd::cxx::tree::sequence< switch_type > switch_sequence;
  typedef switch_sequence::iterator switch_iterator;
  typedef switch_sequence::const_iterator switch_const_iterator;
  typedef ::xsd::cxx::tree::traits< switch_type, char > switch_traits;

  const switch_sequence&
  switch_ () const;

  switch_sequence&
  switch_ ();

  void
  switch_ (const switch_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_road_railroad ();

  t_road_railroad (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  t_road_railroad (const t_road_railroad& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual t_road_railroad*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_railroad&
  operator= (const t_road_railroad& x);

  virtual 
  ~t_road_railroad ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  switch_sequence switch__;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_road_railroad_switch: public ::xml_schema::type
{
  public:
  // mainTrack
  //
  typedef ::t_road_railroad_switch_mainTrack mainTrack_type;
  typedef ::xsd::cxx::tree::traits< mainTrack_type, char > mainTrack_traits;

  const mainTrack_type&
  mainTrack () const;

  mainTrack_type&
  mainTrack ();

  void
  mainTrack (const mainTrack_type& x);

  void
  mainTrack (::std::unique_ptr< mainTrack_type > p);

  // sideTrack
  //
  typedef ::t_road_railroad_switch_sideTrack sideTrack_type;
  typedef ::xsd::cxx::tree::traits< sideTrack_type, char > sideTrack_traits;

  const sideTrack_type&
  sideTrack () const;

  sideTrack_type&
  sideTrack ();

  void
  sideTrack (const sideTrack_type& x);

  void
  sideTrack (::std::unique_ptr< sideTrack_type > p);

  // partner
  //
  typedef ::t_road_railroad_switch_partner partner_type;
  typedef ::xsd::cxx::tree::optional< partner_type > partner_optional;
  typedef ::xsd::cxx::tree::traits< partner_type, char > partner_traits;

  const partner_optional&
  partner () const;

  partner_optional&
  partner ();

  void
  partner (const partner_type& x);

  void
  partner (const partner_optional& x);

  void
  partner (::std::unique_ptr< partner_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // position
  //
  typedef ::e_road_railroad_switch_position position_type;
  typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

  const position_type&
  position () const;

  position_type&
  position ();

  void
  position (const position_type& x);

  void
  position (::std::unique_ptr< position_type > p);

  // Constructors.
  //
  t_road_railroad_switch (const mainTrack_type&,
                          const sideTrack_type&,
                          const name_type&,
                          const id_type&,
                          const position_type&);

  t_road_railroad_switch (::std::unique_ptr< mainTrack_type >,
                          ::std::unique_ptr< sideTrack_type >,
                          const name_type&,
                          const id_type&,
                          const position_type&);

  t_road_railroad_switch (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  t_road_railroad_switch (const t_road_railroad_switch& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual t_road_railroad_switch*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_railroad_switch&
  operator= (const t_road_railroad_switch& x);

  virtual 
  ~t_road_railroad_switch ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< mainTrack_type > mainTrack_;
  ::xsd::cxx::tree::one< sideTrack_type > sideTrack_;
  partner_optional partner_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< position_type > position_;
};

class e_road_railroad_switch_position: public ::xml_schema::string
{
  public:
  enum value
  {
    dynamic,
    straight,
    turn
  };

  e_road_railroad_switch_position (value v);

  e_road_railroad_switch_position (const char* v);

  e_road_railroad_switch_position (const ::std::string& v);

  e_road_railroad_switch_position (const ::xml_schema::string& v);

  e_road_railroad_switch_position (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  e_road_railroad_switch_position (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  e_road_railroad_switch_position (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  e_road_railroad_switch_position (const e_road_railroad_switch_position& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual e_road_railroad_switch_position*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_road_railroad_switch_position&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_road_railroad_switch_position_convert ();
  }

  protected:
  value
  _xsd_e_road_railroad_switch_position_convert () const;

  public:
  static const char* const _xsd_e_road_railroad_switch_position_literals_[3];
  static const value _xsd_e_road_railroad_switch_position_indexes_[3];
};

class t_road_railroad_switch_mainTrack: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // dir
  //
  typedef ::e_elementDir dir_type;
  typedef ::xsd::cxx::tree::traits< dir_type, char > dir_traits;

  const dir_type&
  dir () const;

  dir_type&
  dir ();

  void
  dir (const dir_type& x);

  void
  dir (::std::unique_ptr< dir_type > p);

  // Constructors.
  //
  t_road_railroad_switch_mainTrack (const id_type&,
                                    const s_type&,
                                    const dir_type&);

  t_road_railroad_switch_mainTrack (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  t_road_railroad_switch_mainTrack (const t_road_railroad_switch_mainTrack& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual t_road_railroad_switch_mainTrack*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_railroad_switch_mainTrack&
  operator= (const t_road_railroad_switch_mainTrack& x);

  virtual 
  ~t_road_railroad_switch_mainTrack ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< dir_type > dir_;
};

class t_road_railroad_switch_sideTrack: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // s
  //
  typedef ::t_grEqZero s_type;
  typedef ::xsd::cxx::tree::traits< s_type, char > s_traits;

  const s_type&
  s () const;

  s_type&
  s ();

  void
  s (const s_type& x);

  void
  s (::std::unique_ptr< s_type > p);

  // dir
  //
  typedef ::e_elementDir dir_type;
  typedef ::xsd::cxx::tree::traits< dir_type, char > dir_traits;

  const dir_type&
  dir () const;

  dir_type&
  dir ();

  void
  dir (const dir_type& x);

  void
  dir (::std::unique_ptr< dir_type > p);

  // Constructors.
  //
  t_road_railroad_switch_sideTrack (const id_type&,
                                    const s_type&,
                                    const dir_type&);

  t_road_railroad_switch_sideTrack (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  t_road_railroad_switch_sideTrack (const t_road_railroad_switch_sideTrack& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual t_road_railroad_switch_sideTrack*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_railroad_switch_sideTrack&
  operator= (const t_road_railroad_switch_sideTrack& x);

  virtual 
  ~t_road_railroad_switch_sideTrack ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< s_type > s_;
  ::xsd::cxx::tree::one< dir_type > dir_;
};

class t_road_railroad_switch_partner: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // Constructors.
  //
  t_road_railroad_switch_partner (const id_type&);

  t_road_railroad_switch_partner (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_road_railroad_switch_partner (const t_road_railroad_switch_partner& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_road_railroad_switch_partner*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_road_railroad_switch_partner&
  operator= (const t_road_railroad_switch_partner& x);

  virtual 
  ~t_road_railroad_switch_partner ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  name_optional name_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_controller: public ::xml_schema::type
{
  public:
  // control
  //
  typedef ::t_controller_control control_type;
  typedef ::xsd::cxx::tree::sequence< control_type > control_sequence;
  typedef control_sequence::iterator control_iterator;
  typedef control_sequence::const_iterator control_const_iterator;
  typedef ::xsd::cxx::tree::traits< control_type, char > control_traits;

  const control_sequence&
  control () const;

  control_sequence&
  control ();

  void
  control (const control_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // sequence
  //
  typedef ::xml_schema::non_negative_integer sequence_type;
  typedef ::xsd::cxx::tree::optional< sequence_type > sequence_optional;
  typedef ::xsd::cxx::tree::traits< sequence_type, char > sequence_traits;

  const sequence_optional&
  sequence () const;

  sequence_optional&
  sequence ();

  void
  sequence (const sequence_type& x);

  void
  sequence (const sequence_optional& x);

  // Constructors.
  //
  t_controller (const id_type&);

  t_controller (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  t_controller (const t_controller& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual t_controller*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_controller&
  operator= (const t_controller& x);

  virtual 
  ~t_controller ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  control_sequence control_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  name_optional name_;
  sequence_optional sequence_;
};

class t_controller_control: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // signalId
  //
  typedef ::xml_schema::string signalId_type;
  typedef ::xsd::cxx::tree::traits< signalId_type, char > signalId_traits;

  const signalId_type&
  signalId () const;

  signalId_type&
  signalId ();

  void
  signalId (const signalId_type& x);

  void
  signalId (::std::unique_ptr< signalId_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_controller_control (const signalId_type&);

  t_controller_control (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  t_controller_control (const t_controller_control& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual t_controller_control*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_controller_control&
  operator= (const t_controller_control& x);

  virtual 
  ~t_controller_control ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< signalId_type > signalId_;
  type_optional type_;
};

class t_junction: public ::xml_schema::type
{
  public:
  // connection
  //
  typedef ::t_junction_connection connection_type;
  typedef ::xsd::cxx::tree::sequence< connection_type > connection_sequence;
  typedef connection_sequence::iterator connection_iterator;
  typedef connection_sequence::const_iterator connection_const_iterator;
  typedef ::xsd::cxx::tree::traits< connection_type, char > connection_traits;

  const connection_sequence&
  connection () const;

  connection_sequence&
  connection ();

  void
  connection (const connection_sequence& s);

  // priority
  //
  typedef ::t_junction_priority priority_type;
  typedef ::xsd::cxx::tree::sequence< priority_type > priority_sequence;
  typedef priority_sequence::iterator priority_iterator;
  typedef priority_sequence::const_iterator priority_const_iterator;
  typedef ::xsd::cxx::tree::traits< priority_type, char > priority_traits;

  const priority_sequence&
  priority () const;

  priority_sequence&
  priority ();

  void
  priority (const priority_sequence& s);

  // controller
  //
  typedef ::t_junction_controller controller_type;
  typedef ::xsd::cxx::tree::sequence< controller_type > controller_sequence;
  typedef controller_sequence::iterator controller_iterator;
  typedef controller_sequence::const_iterator controller_const_iterator;
  typedef ::xsd::cxx::tree::traits< controller_type, char > controller_traits;

  const controller_sequence&
  controller () const;

  controller_sequence&
  controller ();

  void
  controller (const controller_sequence& s);

  // surface
  //
  typedef ::t_junction_surface surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::unique_ptr< surface_type > p);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::t_junction_id id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::e_junction_type type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_junction (const id_type&);

  t_junction (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_junction (const t_junction& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual t_junction*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction&
  operator= (const t_junction& x);

  virtual 
  ~t_junction ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  connection_sequence connection_;
  priority_sequence priority_;
  controller_sequence controller_;
  surface_optional surface_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  name_optional name_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
};

class e_junction_type: public ::xml_schema::string
{
  public:
  enum value
  {
    default_,
    virtual_
  };

  e_junction_type (value v);

  e_junction_type (const char* v);

  e_junction_type (const ::std::string& v);

  e_junction_type (const ::xml_schema::string& v);

  e_junction_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  e_junction_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  e_junction_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  e_junction_type (const e_junction_type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual e_junction_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_junction_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_junction_type_convert ();
  }

  protected:
  value
  _xsd_e_junction_type_convert () const;

  public:
  static const char* const _xsd_e_junction_type_literals_[2];
  static const value _xsd_e_junction_type_indexes_[2];
};

class t_junction_connection: public ::xml_schema::type
{
  public:
  // predecessor
  //
  typedef ::t_junction_predecessorSuccessor predecessor_type;
  typedef ::xsd::cxx::tree::optional< predecessor_type > predecessor_optional;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_optional&
  predecessor () const;

  predecessor_optional&
  predecessor ();

  void
  predecessor (const predecessor_type& x);

  void
  predecessor (const predecessor_optional& x);

  void
  predecessor (::std::unique_ptr< predecessor_type > p);

  // successor
  //
  typedef ::t_junction_predecessorSuccessor successor_type;
  typedef ::xsd::cxx::tree::optional< successor_type > successor_optional;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_optional&
  successor () const;

  successor_optional&
  successor ();

  void
  successor (const successor_type& x);

  void
  successor (const successor_optional& x);

  void
  successor (::std::unique_ptr< successor_type > p);

  // laneLink
  //
  typedef ::t_junction_connection_laneLink laneLink_type;
  typedef ::xsd::cxx::tree::sequence< laneLink_type > laneLink_sequence;
  typedef laneLink_sequence::iterator laneLink_iterator;
  typedef laneLink_sequence::const_iterator laneLink_const_iterator;
  typedef ::xsd::cxx::tree::traits< laneLink_type, char > laneLink_traits;

  const laneLink_sequence&
  laneLink () const;

  laneLink_sequence&
  laneLink ();

  void
  laneLink (const laneLink_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // incomingRoad
  //
  typedef ::xml_schema::string incomingRoad_type;
  typedef ::xsd::cxx::tree::traits< incomingRoad_type, char > incomingRoad_traits;

  const incomingRoad_type&
  incomingRoad () const;

  incomingRoad_type&
  incomingRoad ();

  void
  incomingRoad (const incomingRoad_type& x);

  void
  incomingRoad (::std::unique_ptr< incomingRoad_type > p);

  // connectingRoad
  //
  typedef ::xml_schema::string connectingRoad_type;
  typedef ::xsd::cxx::tree::traits< connectingRoad_type, char > connectingRoad_traits;

  const connectingRoad_type&
  connectingRoad () const;

  connectingRoad_type&
  connectingRoad ();

  void
  connectingRoad (const connectingRoad_type& x);

  void
  connectingRoad (::std::unique_ptr< connectingRoad_type > p);

  // contactPoint
  //
  typedef ::e_contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_type&
  contactPoint () const;

  contactPoint_type&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // connectionMaster
  //
  typedef ::xml_schema::string connectionMaster_type;
  typedef ::xsd::cxx::tree::optional< connectionMaster_type > connectionMaster_optional;
  typedef ::xsd::cxx::tree::traits< connectionMaster_type, char > connectionMaster_traits;

  const connectionMaster_optional&
  connectionMaster () const;

  connectionMaster_optional&
  connectionMaster ();

  void
  connectionMaster (const connectionMaster_type& x);

  void
  connectionMaster (const connectionMaster_optional& x);

  void
  connectionMaster (::std::unique_ptr< connectionMaster_type > p);

  // type
  //
  typedef ::e_junction_type type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_junction_connection (const id_type&,
                         const incomingRoad_type&,
                         const connectingRoad_type&,
                         const contactPoint_type&);

  t_junction_connection (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_junction_connection (const t_junction_connection& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_junction_connection*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction_connection&
  operator= (const t_junction_connection& x);

  virtual 
  ~t_junction_connection ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  predecessor_optional predecessor_;
  successor_optional successor_;
  laneLink_sequence laneLink_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< incomingRoad_type > incomingRoad_;
  ::xsd::cxx::tree::one< connectingRoad_type > connectingRoad_;
  ::xsd::cxx::tree::one< contactPoint_type > contactPoint_;
  connectionMaster_optional connectionMaster_;
  type_optional type_;
};

class t_junction_predecessorSuccessor: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // elementType
  //
  typedef ::xml_schema::string elementType_type;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_type&
  elementType () const;

  static const elementType_type&
  elementType_default_value ();

  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_type&
  elementId () const;

  elementId_type&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // elementS
  //
  typedef ::t_grZero elementS_type;
  typedef ::xsd::cxx::tree::traits< elementS_type, char > elementS_traits;

  const elementS_type&
  elementS () const;

  elementS_type&
  elementS ();

  void
  elementS (const elementS_type& x);

  void
  elementS (::std::unique_ptr< elementS_type > p);

  // elementDir
  //
  typedef ::e_elementDir elementDir_type;
  typedef ::xsd::cxx::tree::traits< elementDir_type, char > elementDir_traits;

  const elementDir_type&
  elementDir () const;

  elementDir_type&
  elementDir ();

  void
  elementDir (const elementDir_type& x);

  void
  elementDir (::std::unique_ptr< elementDir_type > p);

  // Constructors.
  //
  t_junction_predecessorSuccessor (const elementId_type&,
                                   const elementS_type&,
                                   const elementDir_type&);

  t_junction_predecessorSuccessor (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  t_junction_predecessorSuccessor (const t_junction_predecessorSuccessor& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual t_junction_predecessorSuccessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction_predecessorSuccessor&
  operator= (const t_junction_predecessorSuccessor& x);

  virtual 
  ~t_junction_predecessorSuccessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< elementType_type > elementType_;
  static const elementType_type elementType_default_value_;
  ::xsd::cxx::tree::one< elementId_type > elementId_;
  ::xsd::cxx::tree::one< elementS_type > elementS_;
  ::xsd::cxx::tree::one< elementDir_type > elementDir_;
};

class t_junction_connection_laneLink: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // from
  //
  typedef ::xml_schema::integer from_type;
  typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

  const from_type&
  from () const;

  from_type&
  from ();

  void
  from (const from_type& x);

  // to
  //
  typedef ::xml_schema::integer to_type;
  typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

  const to_type&
  to () const;

  to_type&
  to ();

  void
  to (const to_type& x);

  // Constructors.
  //
  t_junction_connection_laneLink (const from_type&,
                                  const to_type&);

  t_junction_connection_laneLink (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  t_junction_connection_laneLink (const t_junction_connection_laneLink& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual t_junction_connection_laneLink*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction_connection_laneLink&
  operator= (const t_junction_connection_laneLink& x);

  virtual 
  ~t_junction_connection_laneLink ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< from_type > from_;
  ::xsd::cxx::tree::one< to_type > to_;
};

class t_junction_priority: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // high
  //
  typedef ::xml_schema::string high_type;
  typedef ::xsd::cxx::tree::optional< high_type > high_optional;
  typedef ::xsd::cxx::tree::traits< high_type, char > high_traits;

  const high_optional&
  high () const;

  high_optional&
  high ();

  void
  high (const high_type& x);

  void
  high (const high_optional& x);

  void
  high (::std::unique_ptr< high_type > p);

  // low
  //
  typedef ::xml_schema::string low_type;
  typedef ::xsd::cxx::tree::optional< low_type > low_optional;
  typedef ::xsd::cxx::tree::traits< low_type, char > low_traits;

  const low_optional&
  low () const;

  low_optional&
  low ();

  void
  low (const low_type& x);

  void
  low (const low_optional& x);

  void
  low (::std::unique_ptr< low_type > p);

  // Constructors.
  //
  t_junction_priority ();

  t_junction_priority (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  t_junction_priority (const t_junction_priority& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual t_junction_priority*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction_priority&
  operator= (const t_junction_priority& x);

  virtual 
  ~t_junction_priority ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  high_optional high_;
  low_optional low_;
};

class t_junction_controller: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // sequence
  //
  typedef ::xml_schema::non_negative_integer sequence_type;
  typedef ::xsd::cxx::tree::optional< sequence_type > sequence_optional;
  typedef ::xsd::cxx::tree::traits< sequence_type, char > sequence_traits;

  const sequence_optional&
  sequence () const;

  sequence_optional&
  sequence ();

  void
  sequence (const sequence_type& x);

  void
  sequence (const sequence_optional& x);

  // Constructors.
  //
  t_junction_controller (const id_type&);

  t_junction_controller (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_junction_controller (const t_junction_controller& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_junction_controller*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction_controller&
  operator= (const t_junction_controller& x);

  virtual 
  ~t_junction_controller ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
  sequence_optional sequence_;
};

class t_junction_surface: public ::xml_schema::type
{
  public:
  // CRG
  //
  typedef ::t_junction_surface_CRG CRG_type;
  typedef ::xsd::cxx::tree::sequence< CRG_type > CRG_sequence;
  typedef CRG_sequence::iterator CRG_iterator;
  typedef CRG_sequence::const_iterator CRG_const_iterator;
  typedef ::xsd::cxx::tree::traits< CRG_type, char > CRG_traits;

  const CRG_sequence&
  CRG () const;

  CRG_sequence&
  CRG ();

  void
  CRG (const CRG_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  t_junction_surface ();

  t_junction_surface (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  t_junction_surface (const t_junction_surface& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual t_junction_surface*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction_surface&
  operator= (const t_junction_surface& x);

  virtual 
  ~t_junction_surface ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  CRG_sequence CRG_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

class t_junction_surface_CRG: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // file
  //
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::unique_ptr< file_type > p);

  // mode
  //
  typedef ::e_road_surface_CRG_mode mode_type;
  typedef ::xsd::cxx::tree::traits< mode_type, char > mode_traits;

  const mode_type&
  mode () const;

  static const mode_type&
  mode_default_value ();

  // purpose
  //
  typedef ::e_road_surface_CRG_purpose purpose_type;
  typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
  typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

  const purpose_optional&
  purpose () const;

  purpose_optional&
  purpose ();

  void
  purpose (const purpose_type& x);

  void
  purpose (const purpose_optional& x);

  void
  purpose (::std::unique_ptr< purpose_type > p);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  // zScale
  //
  typedef ::xml_schema::double_ zScale_type;
  typedef ::xsd::cxx::tree::optional< zScale_type > zScale_optional;
  typedef ::xsd::cxx::tree::traits< zScale_type, char, ::xsd::cxx::tree::schema_type::double_ > zScale_traits;

  const zScale_optional&
  zScale () const;

  zScale_optional&
  zScale ();

  void
  zScale (const zScale_type& x);

  void
  zScale (const zScale_optional& x);

  // Constructors.
  //
  t_junction_surface_CRG (const file_type&);

  t_junction_surface_CRG (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  t_junction_surface_CRG (const t_junction_surface_CRG& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual t_junction_surface_CRG*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junction_surface_CRG&
  operator= (const t_junction_surface_CRG& x);

  virtual 
  ~t_junction_surface_CRG ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< file_type > file_;
  ::xsd::cxx::tree::one< mode_type > mode_;
  static const mode_type mode_default_value_;
  purpose_optional purpose_;
  zOffset_optional zOffset_;
  zScale_optional zScale_;
};

class t_junctionGroup: public ::xml_schema::type
{
  public:
  // junctionReference
  //
  typedef ::t_junctionGroup_junctionReference junctionReference_type;
  typedef ::xsd::cxx::tree::sequence< junctionReference_type > junctionReference_sequence;
  typedef junctionReference_sequence::iterator junctionReference_iterator;
  typedef junctionReference_sequence::const_iterator junctionReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< junctionReference_type, char > junctionReference_traits;

  const junctionReference_sequence&
  junctionReference () const;

  junctionReference_sequence&
  junctionReference ();

  void
  junctionReference (const junctionReference_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::e_junctionGroup_type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_junctionGroup (const id_type&,
                   const type_type&);

  t_junctionGroup (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  t_junctionGroup (const t_junctionGroup& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual t_junctionGroup*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junctionGroup&
  operator= (const t_junctionGroup& x);

  virtual 
  ~t_junctionGroup ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  junctionReference_sequence junctionReference_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  name_optional name_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< type_type > type_;
};

class e_junctionGroup_type: public ::xml_schema::string
{
  public:
  enum value
  {
    roundabout,
    unknown
  };

  e_junctionGroup_type (value v);

  e_junctionGroup_type (const char* v);

  e_junctionGroup_type (const ::std::string& v);

  e_junctionGroup_type (const ::xml_schema::string& v);

  e_junctionGroup_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  e_junctionGroup_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  e_junctionGroup_type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  e_junctionGroup_type (const e_junctionGroup_type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual e_junctionGroup_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_junctionGroup_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_junctionGroup_type_convert ();
  }

  protected:
  value
  _xsd_e_junctionGroup_type_convert () const;

  public:
  static const char* const _xsd_e_junctionGroup_type_literals_[2];
  static const value _xsd_e_junctionGroup_type_indexes_[2];
};

class t_junctionGroup_junctionReference: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // junction
  //
  typedef ::xml_schema::string junction_type;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_type&
  junction () const;

  junction_type&
  junction ();

  void
  junction (const junction_type& x);

  void
  junction (::std::unique_ptr< junction_type > p);

  // Constructors.
  //
  t_junctionGroup_junctionReference (const junction_type&);

  t_junctionGroup_junctionReference (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  t_junctionGroup_junctionReference (const t_junctionGroup_junctionReference& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual t_junctionGroup_junctionReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_junctionGroup_junctionReference&
  operator= (const t_junctionGroup_junctionReference& x);

  virtual 
  ~t_junctionGroup_junctionReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< junction_type > junction_;
};

class t_station: public ::xml_schema::type
{
  public:
  // platform
  //
  typedef ::t_station_platform platform_type;
  typedef ::xsd::cxx::tree::sequence< platform_type > platform_sequence;
  typedef platform_sequence::iterator platform_iterator;
  typedef platform_sequence::const_iterator platform_const_iterator;
  typedef ::xsd::cxx::tree::traits< platform_type, char > platform_traits;

  const platform_sequence&
  platform () const;

  platform_sequence&
  platform ();

  void
  platform (const platform_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::e_station_type type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  t_station (const name_type&,
             const id_type&);

  t_station (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_station (const t_station& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual t_station*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_station&
  operator= (const t_station& x);

  virtual 
  ~t_station ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  platform_sequence platform_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< id_type > id_;
  type_optional type_;
};

class e_station_type: public ::xml_schema::string
{
  public:
  enum value
  {
    smaller,
    medium,
    large
  };

  e_station_type (value v);

  e_station_type (const char* v);

  e_station_type (const ::std::string& v);

  e_station_type (const ::xml_schema::string& v);

  e_station_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_station_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_station_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_station_type (const e_station_type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual e_station_type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_station_type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_station_type_convert ();
  }

  protected:
  value
  _xsd_e_station_type_convert () const;

  public:
  static const char* const _xsd_e_station_type_literals_[3];
  static const value _xsd_e_station_type_indexes_[3];
};

class t_station_platform: public ::xml_schema::type
{
  public:
  // segment
  //
  typedef ::t_station_platform_segment segment_type;
  typedef ::xsd::cxx::tree::sequence< segment_type > segment_sequence;
  typedef segment_sequence::iterator segment_iterator;
  typedef segment_sequence::const_iterator segment_const_iterator;
  typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

  const segment_sequence&
  segment () const;

  segment_sequence&
  segment ();

  void
  segment (const segment_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_type&
  id () const;

  id_type&
  id ();

  void
  id (const id_type& x);

  void
  id (::std::unique_ptr< id_type > p);

  // Constructors.
  //
  t_station_platform (const id_type&);

  t_station_platform (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  t_station_platform (const t_station_platform& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual t_station_platform*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_station_platform&
  operator= (const t_station_platform& x);

  virtual 
  ~t_station_platform ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  segment_sequence segment_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  name_optional name_;
  ::xsd::cxx::tree::one< id_type > id_;
};

class t_station_platform_segment: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // roadId
  //
  typedef ::xml_schema::string roadId_type;
  typedef ::xsd::cxx::tree::traits< roadId_type, char > roadId_traits;

  const roadId_type&
  roadId () const;

  roadId_type&
  roadId ();

  void
  roadId (const roadId_type& x);

  void
  roadId (::std::unique_ptr< roadId_type > p);

  // sStart
  //
  typedef ::t_grEqZero sStart_type;
  typedef ::xsd::cxx::tree::traits< sStart_type, char > sStart_traits;

  const sStart_type&
  sStart () const;

  sStart_type&
  sStart ();

  void
  sStart (const sStart_type& x);

  void
  sStart (::std::unique_ptr< sStart_type > p);

  // sEnd
  //
  typedef ::t_grEqZero sEnd_type;
  typedef ::xsd::cxx::tree::traits< sEnd_type, char > sEnd_traits;

  const sEnd_type&
  sEnd () const;

  sEnd_type&
  sEnd ();

  void
  sEnd (const sEnd_type& x);

  void
  sEnd (::std::unique_ptr< sEnd_type > p);

  // side
  //
  typedef ::e_station_platform_segment_side side_type;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_type&
  side () const;

  side_type&
  side ();

  void
  side (const side_type& x);

  void
  side (::std::unique_ptr< side_type > p);

  // Constructors.
  //
  t_station_platform_segment (const roadId_type&,
                              const sStart_type&,
                              const sEnd_type&,
                              const side_type&);

  t_station_platform_segment (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  t_station_platform_segment (const t_station_platform_segment& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  virtual t_station_platform_segment*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_station_platform_segment&
  operator= (const t_station_platform_segment& x);

  virtual 
  ~t_station_platform_segment ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
  ::xsd::cxx::tree::one< roadId_type > roadId_;
  ::xsd::cxx::tree::one< sStart_type > sStart_;
  ::xsd::cxx::tree::one< sEnd_type > sEnd_;
  ::xsd::cxx::tree::one< side_type > side_;
};

class e_station_platform_segment_side: public ::xml_schema::string
{
  public:
  enum value
  {
    left,
    right
  };

  e_station_platform_segment_side (value v);

  e_station_platform_segment_side (const char* v);

  e_station_platform_segment_side (const ::std::string& v);

  e_station_platform_segment_side (const ::xml_schema::string& v);

  e_station_platform_segment_side (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  e_station_platform_segment_side (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  e_station_platform_segment_side (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  e_station_platform_segment_side (const e_station_platform_segment_side& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual e_station_platform_segment_side*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_station_platform_segment_side&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_station_platform_segment_side_convert ();
  }

  protected:
  value
  _xsd_e_station_platform_segment_side_convert () const;

  public:
  static const char* const _xsd_e_station_platform_segment_side_literals_[2];
  static const value _xsd_e_station_platform_segment_side_indexes_[2];
};

class t_userData: public ::xml_schema::type
{
  public:
  // code
  //
  typedef ::xml_schema::string code_type;
  typedef ::xsd::cxx::tree::traits< code_type, char > code_traits;

  const code_type&
  code () const;

  code_type&
  code ();

  void
  code (const code_type& x);

  void
  code (::std::unique_ptr< code_type > p);

  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::unique_ptr< value_type > p);

  // Constructors.
  //
  t_userData (const code_type&,
              const value_type&);

  t_userData (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  t_userData (const t_userData& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual t_userData*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_userData&
  operator= (const t_userData& x);

  virtual 
  ~t_userData ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< code_type > code_;
  ::xsd::cxx::tree::one< value_type > value_;
};

class t_include: public ::xml_schema::type
{
  public:
  // file
  //
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::unique_ptr< file_type > p);

  // Constructors.
  //
  t_include (const file_type&);

  t_include (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  t_include (const t_include& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual t_include*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_include&
  operator= (const t_include& x);

  virtual 
  ~t_include ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< file_type > file_;
};

class t_dataQuality: public ::xml_schema::type
{
  public:
  // error
  //
  typedef ::t_dataQuality_Error error_type;
  typedef ::xsd::cxx::tree::optional< error_type > error_optional;
  typedef ::xsd::cxx::tree::traits< error_type, char > error_traits;

  const error_optional&
  error () const;

  error_optional&
  error ();

  void
  error (const error_type& x);

  void
  error (const error_optional& x);

  void
  error (::std::unique_ptr< error_type > p);

  // rawData
  //
  typedef ::t_dataQuality_RawData rawData_type;
  typedef ::xsd::cxx::tree::optional< rawData_type > rawData_optional;
  typedef ::xsd::cxx::tree::traits< rawData_type, char > rawData_traits;

  const rawData_optional&
  rawData () const;

  rawData_optional&
  rawData ();

  void
  rawData (const rawData_type& x);

  void
  rawData (const rawData_optional& x);

  void
  rawData (::std::unique_ptr< rawData_type > p);

  // Constructors.
  //
  t_dataQuality ();

  t_dataQuality (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  t_dataQuality (const t_dataQuality& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual t_dataQuality*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_dataQuality&
  operator= (const t_dataQuality& x);

  virtual 
  ~t_dataQuality ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  error_optional error_;
  rawData_optional rawData_;
};

class t_dataQuality_Error: public ::xml_schema::type
{
  public:
  // xyAbsolute
  //
  typedef ::xml_schema::double_ xyAbsolute_type;
  typedef ::xsd::cxx::tree::traits< xyAbsolute_type, char, ::xsd::cxx::tree::schema_type::double_ > xyAbsolute_traits;

  const xyAbsolute_type&
  xyAbsolute () const;

  xyAbsolute_type&
  xyAbsolute ();

  void
  xyAbsolute (const xyAbsolute_type& x);

  // zAbsolute
  //
  typedef ::xml_schema::double_ zAbsolute_type;
  typedef ::xsd::cxx::tree::traits< zAbsolute_type, char, ::xsd::cxx::tree::schema_type::double_ > zAbsolute_traits;

  const zAbsolute_type&
  zAbsolute () const;

  zAbsolute_type&
  zAbsolute ();

  void
  zAbsolute (const zAbsolute_type& x);

  // xyRelative
  //
  typedef ::xml_schema::double_ xyRelative_type;
  typedef ::xsd::cxx::tree::traits< xyRelative_type, char, ::xsd::cxx::tree::schema_type::double_ > xyRelative_traits;

  const xyRelative_type&
  xyRelative () const;

  xyRelative_type&
  xyRelative ();

  void
  xyRelative (const xyRelative_type& x);

  // zRelative
  //
  typedef ::xml_schema::double_ zRelative_type;
  typedef ::xsd::cxx::tree::traits< zRelative_type, char, ::xsd::cxx::tree::schema_type::double_ > zRelative_traits;

  const zRelative_type&
  zRelative () const;

  zRelative_type&
  zRelative ();

  void
  zRelative (const zRelative_type& x);

  // Constructors.
  //
  t_dataQuality_Error (const xyAbsolute_type&,
                       const zAbsolute_type&,
                       const xyRelative_type&,
                       const zRelative_type&);

  t_dataQuality_Error (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  t_dataQuality_Error (const t_dataQuality_Error& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual t_dataQuality_Error*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_dataQuality_Error&
  operator= (const t_dataQuality_Error& x);

  virtual 
  ~t_dataQuality_Error ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< xyAbsolute_type > xyAbsolute_;
  ::xsd::cxx::tree::one< zAbsolute_type > zAbsolute_;
  ::xsd::cxx::tree::one< xyRelative_type > xyRelative_;
  ::xsd::cxx::tree::one< zRelative_type > zRelative_;
};

class t_dataQuality_RawData: public ::xml_schema::type
{
  public:
  // date
  //
  typedef ::xml_schema::string date_type;
  typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

  const date_type&
  date () const;

  date_type&
  date ();

  void
  date (const date_type& x);

  void
  date (::std::unique_ptr< date_type > p);

  // source
  //
  typedef ::e_dataQuality_RawData_Source source_type;
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  const source_type&
  source () const;

  source_type&
  source ();

  void
  source (const source_type& x);

  void
  source (::std::unique_ptr< source_type > p);

  // sourceComment
  //
  typedef ::xml_schema::string sourceComment_type;
  typedef ::xsd::cxx::tree::optional< sourceComment_type > sourceComment_optional;
  typedef ::xsd::cxx::tree::traits< sourceComment_type, char > sourceComment_traits;

  const sourceComment_optional&
  sourceComment () const;

  sourceComment_optional&
  sourceComment ();

  void
  sourceComment (const sourceComment_type& x);

  void
  sourceComment (const sourceComment_optional& x);

  void
  sourceComment (::std::unique_ptr< sourceComment_type > p);

  // postProcessing
  //
  typedef ::e_dataQuality_RawData_PostProcessing postProcessing_type;
  typedef ::xsd::cxx::tree::traits< postProcessing_type, char > postProcessing_traits;

  const postProcessing_type&
  postProcessing () const;

  postProcessing_type&
  postProcessing ();

  void
  postProcessing (const postProcessing_type& x);

  void
  postProcessing (::std::unique_ptr< postProcessing_type > p);

  // postProcessingComment
  //
  typedef ::xml_schema::string postProcessingComment_type;
  typedef ::xsd::cxx::tree::optional< postProcessingComment_type > postProcessingComment_optional;
  typedef ::xsd::cxx::tree::traits< postProcessingComment_type, char > postProcessingComment_traits;

  const postProcessingComment_optional&
  postProcessingComment () const;

  postProcessingComment_optional&
  postProcessingComment ();

  void
  postProcessingComment (const postProcessingComment_type& x);

  void
  postProcessingComment (const postProcessingComment_optional& x);

  void
  postProcessingComment (::std::unique_ptr< postProcessingComment_type > p);

  // Constructors.
  //
  t_dataQuality_RawData (const date_type&,
                         const source_type&,
                         const postProcessing_type&);

  t_dataQuality_RawData (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  t_dataQuality_RawData (const t_dataQuality_RawData& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual t_dataQuality_RawData*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_dataQuality_RawData&
  operator= (const t_dataQuality_RawData& x);

  virtual 
  ~t_dataQuality_RawData ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< date_type > date_;
  ::xsd::cxx::tree::one< source_type > source_;
  sourceComment_optional sourceComment_;
  ::xsd::cxx::tree::one< postProcessing_type > postProcessing_;
  postProcessingComment_optional postProcessingComment_;
};

class e_dataQuality_RawData_Source: public ::xml_schema::string
{
  public:
  enum value
  {
    sensor,
    cadaster,
    custom
  };

  e_dataQuality_RawData_Source (value v);

  e_dataQuality_RawData_Source (const char* v);

  e_dataQuality_RawData_Source (const ::std::string& v);

  e_dataQuality_RawData_Source (const ::xml_schema::string& v);

  e_dataQuality_RawData_Source (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  e_dataQuality_RawData_Source (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  e_dataQuality_RawData_Source (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  e_dataQuality_RawData_Source (const e_dataQuality_RawData_Source& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual e_dataQuality_RawData_Source*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_dataQuality_RawData_Source&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_dataQuality_RawData_Source_convert ();
  }

  protected:
  value
  _xsd_e_dataQuality_RawData_Source_convert () const;

  public:
  static const char* const _xsd_e_dataQuality_RawData_Source_literals_[3];
  static const value _xsd_e_dataQuality_RawData_Source_indexes_[3];
};

class e_dataQuality_RawData_PostProcessing: public ::xml_schema::string
{
  public:
  enum value
  {
    raw,
    cleaned,
    processed,
    fused
  };

  e_dataQuality_RawData_PostProcessing (value v);

  e_dataQuality_RawData_PostProcessing (const char* v);

  e_dataQuality_RawData_PostProcessing (const ::std::string& v);

  e_dataQuality_RawData_PostProcessing (const ::xml_schema::string& v);

  e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_dataQuality_RawData_PostProcessing (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_dataQuality_RawData_PostProcessing (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  e_dataQuality_RawData_PostProcessing (const e_dataQuality_RawData_PostProcessing& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual e_dataQuality_RawData_PostProcessing*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_dataQuality_RawData_PostProcessing&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_dataQuality_RawData_PostProcessing_convert ();
  }

  protected:
  value
  _xsd_e_dataQuality_RawData_PostProcessing_convert () const;

  public:
  static const char* const _xsd_e_dataQuality_RawData_PostProcessing_literals_[4];
  static const value _xsd_e_dataQuality_RawData_PostProcessing_indexes_[4];
};

class e_unitDistance: public ::xml_schema::string
{
  public:
  enum value
  {
    m,
    km,
    ft,
    mile
  };

  e_unitDistance (value v);

  e_unitDistance (const char* v);

  e_unitDistance (const ::std::string& v);

  e_unitDistance (const ::xml_schema::string& v);

  e_unitDistance (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_unitDistance (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_unitDistance (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_unitDistance (const e_unitDistance& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual e_unitDistance*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitDistance&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitDistance_convert ();
  }

  protected:
  value
  _xsd_e_unitDistance_convert () const;

  public:
  static const char* const _xsd_e_unitDistance_literals_[4];
  static const value _xsd_e_unitDistance_indexes_[4];
};

class e_unitSpeed: public ::xml_schema::string
{
  public:
  enum value
  {
    m_s,
    mph,
    km_h
  };

  e_unitSpeed (value v);

  e_unitSpeed (const char* v);

  e_unitSpeed (const ::std::string& v);

  e_unitSpeed (const ::xml_schema::string& v);

  e_unitSpeed (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSpeed (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSpeed (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSpeed (const e_unitSpeed& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual e_unitSpeed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitSpeed&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitSpeed_convert ();
  }

  protected:
  value
  _xsd_e_unitSpeed_convert () const;

  public:
  static const char* const _xsd_e_unitSpeed_literals_[3];
  static const value _xsd_e_unitSpeed_indexes_[3];
};

class e_unitMass: public ::xml_schema::string
{
  public:
  enum value
  {
    kg,
    t
  };

  e_unitMass (value v);

  e_unitMass (const char* v);

  e_unitMass (const ::std::string& v);

  e_unitMass (const ::xml_schema::string& v);

  e_unitMass (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_unitMass (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_unitMass (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_unitMass (const e_unitMass& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual e_unitMass*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitMass&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitMass_convert ();
  }

  protected:
  value
  _xsd_e_unitMass_convert () const;

  public:
  static const char* const _xsd_e_unitMass_literals_[2];
  static const value _xsd_e_unitMass_indexes_[2];
};

class e_unitSlope: public ::xml_schema::string
{
  public:
  enum value
  {
    cxx_
  };

  e_unitSlope (value v);

  e_unitSlope (const char* v);

  e_unitSlope (const ::std::string& v);

  e_unitSlope (const ::xml_schema::string& v);

  e_unitSlope (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSlope (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSlope (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_unitSlope (const e_unitSlope& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual e_unitSlope*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unitSlope&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unitSlope_convert ();
  }

  protected:
  value
  _xsd_e_unitSlope_convert () const;

  public:
  static const char* const _xsd_e_unitSlope_literals_[1];
  static const value _xsd_e_unitSlope_indexes_[1];
};

class e_unit: public ::xml_schema::string
{
  public:
  enum value
  {
    m,
    km,
    ft,
    mile,
    m_s,
    mph,
    km_h,
    kg,
    t,
    cxx_
  };

  e_unit (value v);

  e_unit (const char* v);

  e_unit (const ::std::string& v);

  e_unit (const ::xml_schema::string& v);

  e_unit (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  e_unit (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  e_unit (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  e_unit (const e_unit& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual e_unit*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_unit&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_unit_convert ();
  }

  protected:
  value
  _xsd_e_unit_convert () const;

  public:
  static const char* const _xsd_e_unit_literals_[10];
  static const value _xsd_e_unit_indexes_[10];
};

class e_roadType: public ::xml_schema::string
{
  public:
  enum value
  {
    unknown,
    rural,
    motorway,
    town,
    lowSpeed,
    pedestrian,
    bicycle,
    townExpressway,
    townCollector,
    townArterial,
    townPrivate,
    townLocal,
    townPlayStreet
  };

  e_roadType (value v);

  e_roadType (const char* v);

  e_roadType (const ::std::string& v);

  e_roadType (const ::xml_schema::string& v);

  e_roadType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_roadType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_roadType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_roadType (const e_roadType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual e_roadType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_roadType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_roadType_convert ();
  }

  protected:
  value
  _xsd_e_roadType_convert () const;

  public:
  static const char* const _xsd_e_roadType_literals_[13];
  static const value _xsd_e_roadType_indexes_[13];
};

class e_roadMarkType: public ::xml_schema::string
{
  public:
  enum value
  {
    none,
    solid,
    broken,
    solid_solid,
    solid_broken,
    broken_solid,
    broken_broken,
    botts_dots,
    grass,
    curb,
    custom,
    edge
  };

  e_roadMarkType (value v);

  e_roadMarkType (const char* v);

  e_roadMarkType (const ::std::string& v);

  e_roadMarkType (const ::xml_schema::string& v);

  e_roadMarkType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_roadMarkType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_roadMarkType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_roadMarkType (const e_roadMarkType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual e_roadMarkType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_roadMarkType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_roadMarkType_convert ();
  }

  protected:
  value
  _xsd_e_roadMarkType_convert () const;

  public:
  static const char* const _xsd_e_roadMarkType_literals_[12];
  static const value _xsd_e_roadMarkType_indexes_[12];
};

class e_roadMarkWeight: public ::xml_schema::string
{
  public:
  enum value
  {
    standard,
    bold
  };

  e_roadMarkWeight (value v);

  e_roadMarkWeight (const char* v);

  e_roadMarkWeight (const ::std::string& v);

  e_roadMarkWeight (const ::xml_schema::string& v);

  e_roadMarkWeight (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_roadMarkWeight (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_roadMarkWeight (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  e_roadMarkWeight (const e_roadMarkWeight& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual e_roadMarkWeight*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_roadMarkWeight&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_roadMarkWeight_convert ();
  }

  protected:
  value
  _xsd_e_roadMarkWeight_convert () const;

  public:
  static const char* const _xsd_e_roadMarkWeight_literals_[2];
  static const value _xsd_e_roadMarkWeight_indexes_[2];
};

class e_roadMarkColor: public ::xml_schema::string
{
  public:
  enum value
  {
    standard,
    blue,
    green,
    red,
    white,
    yellow,
    orange
  };

  e_roadMarkColor (value v);

  e_roadMarkColor (const char* v);

  e_roadMarkColor (const ::std::string& v);

  e_roadMarkColor (const ::xml_schema::string& v);

  e_roadMarkColor (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  e_roadMarkColor (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  e_roadMarkColor (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  e_roadMarkColor (const e_roadMarkColor& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual e_roadMarkColor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_roadMarkColor&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_roadMarkColor_convert ();
  }

  protected:
  value
  _xsd_e_roadMarkColor_convert () const;

  public:
  static const char* const _xsd_e_roadMarkColor_literals_[7];
  static const value _xsd_e_roadMarkColor_indexes_[7];
};

class e_laneType: public ::xml_schema::string
{
  public:
  enum value
  {
    none,
    driving,
    stop,
    shoulder,
    biking,
    sidewalk,
    border,
    restricted,
    parking,
    bidirectional,
    median,
    special1,
    special2,
    special3,
    roadWorks,
    tram,
    rail,
    entry,
    exit,
    offRamp,
    onRamp,
    connectingRamp,
    bus,
    taxi,
    HOV,
    mwyEntry,
    mwyExit
  };

  e_laneType (value v);

  e_laneType (const char* v);

  e_laneType (const ::std::string& v);

  e_laneType (const ::xml_schema::string& v);

  e_laneType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_laneType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_laneType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_laneType (const e_laneType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual e_laneType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_laneType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_laneType_convert ();
  }

  protected:
  value
  _xsd_e_laneType_convert () const;

  public:
  static const char* const _xsd_e_laneType_literals_[27];
  static const value _xsd_e_laneType_indexes_[27];
};

class e_objectType: public ::xml_schema::string
{
  public:
  enum value
  {
    none,
    obstacle,
    car,
    pole,
    tree,
    vegetation,
    barrier,
    building,
    parkingSpace,
    patch,
    railing,
    trafficIsland,
    crosswalk,
    streetLamp,
    gantry,
    soundBarrier,
    truck,
    van,
    bus,
    trailer,
    bike,
    motorbike,
    tram,
    train,
    pedestrian,
    wind
  };

  e_objectType (value v);

  e_objectType (const char* v);

  e_objectType (const ::std::string& v);

  e_objectType (const ::xml_schema::string& v);

  e_objectType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_objectType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_objectType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_objectType (const e_objectType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual e_objectType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_objectType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_objectType_convert ();
  }

  protected:
  value
  _xsd_e_objectType_convert () const;

  public:
  static const char* const _xsd_e_objectType_literals_[26];
  static const value _xsd_e_objectType_indexes_[26];
};

class e_tunnelType: public ::xml_schema::string
{
  public:
  enum value
  {
    standard,
    underpass
  };

  e_tunnelType (value v);

  e_tunnelType (const char* v);

  e_tunnelType (const ::std::string& v);

  e_tunnelType (const ::xml_schema::string& v);

  e_tunnelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_tunnelType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_tunnelType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_tunnelType (const e_tunnelType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual e_tunnelType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_tunnelType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_tunnelType_convert ();
  }

  protected:
  value
  _xsd_e_tunnelType_convert () const;

  public:
  static const char* const _xsd_e_tunnelType_literals_[2];
  static const value _xsd_e_tunnelType_indexes_[2];
};

class e_bridgeType: public ::xml_schema::string
{
  public:
  enum value
  {
    concrete,
    steel,
    brick,
    wood
  };

  e_bridgeType (value v);

  e_bridgeType (const char* v);

  e_bridgeType (const ::std::string& v);

  e_bridgeType (const ::xml_schema::string& v);

  e_bridgeType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_bridgeType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_bridgeType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_bridgeType (const e_bridgeType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual e_bridgeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_bridgeType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_bridgeType_convert ();
  }

  protected:
  value
  _xsd_e_bridgeType_convert () const;

  public:
  static const char* const _xsd_e_bridgeType_literals_[4];
  static const value _xsd_e_bridgeType_indexes_[4];
};

class e_accessRestrictionType: public ::xml_schema::string
{
  public:
  enum value
  {
    simulator,
    autonomousTraffic,
    pedestrian,
    passengerCar,
    bus,
    delivery,
    emergency,
    taxi,
    throughTraffic,
    truck,
    bicycle,
    motorcycle,
    none,
    trucks
  };

  e_accessRestrictionType (value v);

  e_accessRestrictionType (const char* v);

  e_accessRestrictionType (const ::std::string& v);

  e_accessRestrictionType (const ::xml_schema::string& v);

  e_accessRestrictionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_accessRestrictionType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_accessRestrictionType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  e_accessRestrictionType (const e_accessRestrictionType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual e_accessRestrictionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_accessRestrictionType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_accessRestrictionType_convert ();
  }

  protected:
  value
  _xsd_e_accessRestrictionType_convert () const;

  public:
  static const char* const _xsd_e_accessRestrictionType_literals_[14];
  static const value _xsd_e_accessRestrictionType_indexes_[14];
};

class e_countryCode: public ::xml_schema::string
{
  public:

  e_countryCode (const char* v);

  e_countryCode (const ::std::string& v);

  e_countryCode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_countryCode (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_countryCode (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_countryCode (const e_countryCode& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual e_countryCode*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class e_countryCode_deprecated: public ::xml_schema::string
{
  public:
  enum value
  {
    OpenDRIVE,
    Austria,
    Brazil,
    China,
    France,
    Germany,
    Italy,
    Switzerland,
    USA
  };

  e_countryCode_deprecated (value v);

  e_countryCode_deprecated (const char* v);

  e_countryCode_deprecated (const ::std::string& v);

  e_countryCode_deprecated (const ::xml_schema::string& v);

  e_countryCode_deprecated (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  e_countryCode_deprecated (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  e_countryCode_deprecated (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  e_countryCode_deprecated (const e_countryCode_deprecated& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual e_countryCode_deprecated*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_countryCode_deprecated&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_countryCode_deprecated_convert ();
  }

  protected:
  value
  _xsd_e_countryCode_deprecated_convert () const;

  public:
  static const char* const _xsd_e_countryCode_deprecated_literals_[9];
  static const value _xsd_e_countryCode_deprecated_indexes_[9];
};

class e_countryCode_iso3166alpha3: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  e_countryCode_iso3166alpha3 ();

  e_countryCode_iso3166alpha3 (const char*);

  e_countryCode_iso3166alpha3 (const ::std::string&);

  e_countryCode_iso3166alpha3 (const ::xml_schema::string&);

  e_countryCode_iso3166alpha3 (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha3 (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha3 (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  e_countryCode_iso3166alpha3 (const e_countryCode_iso3166alpha3& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual e_countryCode_iso3166alpha3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~e_countryCode_iso3166alpha3 ();
};

class e_sideType: public ::xml_schema::string
{
  public:
  enum value
  {
    left,
    right,
    front,
    rear
  };

  e_sideType (value v);

  e_sideType (const char* v);

  e_sideType (const ::std::string& v);

  e_sideType (const ::xml_schema::string& v);

  e_sideType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_sideType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_sideType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  e_sideType (const e_sideType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual e_sideType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_sideType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_sideType_convert ();
  }

  protected:
  value
  _xsd_e_sideType_convert () const;

  public:
  static const char* const _xsd_e_sideType_literals_[4];
  static const value _xsd_e_sideType_indexes_[4];
};

class e_outlineFillType: public ::xml_schema::string
{
  public:
  enum value
  {
    grass,
    concrete,
    cobble,
    asphalt,
    pavement,
    gravel,
    soil
  };

  e_outlineFillType (value v);

  e_outlineFillType (const char* v);

  e_outlineFillType (const ::std::string& v);

  e_outlineFillType (const ::xml_schema::string& v);

  e_outlineFillType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  e_outlineFillType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  e_outlineFillType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  e_outlineFillType (const e_outlineFillType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual e_outlineFillType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_outlineFillType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_outlineFillType_convert ();
  }

  protected:
  value
  _xsd_e_outlineFillType_convert () const;

  public:
  static const char* const _xsd_e_outlineFillType_literals_[7];
  static const value _xsd_e_outlineFillType_indexes_[7];
};

class e_borderType: public ::xml_schema::string
{
  public:
  enum value
  {
    concrete,
    curb
  };

  e_borderType (value v);

  e_borderType (const char* v);

  e_borderType (const ::std::string& v);

  e_borderType (const ::xml_schema::string& v);

  e_borderType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_borderType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_borderType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_borderType (const e_borderType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual e_borderType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_borderType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_borderType_convert ();
  }

  protected:
  value
  _xsd_e_borderType_convert () const;

  public:
  static const char* const _xsd_e_borderType_literals_[2];
  static const value _xsd_e_borderType_indexes_[2];
};

class e_contactPoint: public ::xml_schema::string
{
  public:
  enum value
  {
    start,
    end
  };

  e_contactPoint (value v);

  e_contactPoint (const char* v);

  e_contactPoint (const ::std::string& v);

  e_contactPoint (const ::xml_schema::string& v);

  e_contactPoint (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_contactPoint (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_contactPoint (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_contactPoint (const e_contactPoint& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual e_contactPoint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_contactPoint&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_contactPoint_convert ();
  }

  protected:
  value
  _xsd_e_contactPoint_convert () const;

  public:
  static const char* const _xsd_e_contactPoint_literals_[2];
  static const value _xsd_e_contactPoint_indexes_[2];
};

class e_elementDir: public ::xml_schema::string
{
  public:
  enum value
  {
    cxx_,
    cxx_1
  };

  e_elementDir (value v);

  e_elementDir (const char* v);

  e_elementDir (const ::std::string& v);

  e_elementDir (const ::xml_schema::string& v);

  e_elementDir (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_elementDir (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_elementDir (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  e_elementDir (const e_elementDir& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual e_elementDir*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_elementDir&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_elementDir_convert ();
  }

  protected:
  value
  _xsd_e_elementDir_convert () const;

  public:
  static const char* const _xsd_e_elementDir_literals_[2];
  static const value _xsd_e_elementDir_indexes_[2];
};

class e_direction: public ::xml_schema::string
{
  public:
  enum value
  {
    same,
    opposite
  };

  e_direction (value v);

  e_direction (const char* v);

  e_direction (const ::std::string& v);

  e_direction (const ::xml_schema::string& v);

  e_direction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_direction (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_direction (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  e_direction (const e_direction& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual e_direction*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_direction&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_direction_convert ();
  }

  protected:
  value
  _xsd_e_direction_convert () const;

  public:
  static const char* const _xsd_e_direction_literals_[2];
  static const value _xsd_e_direction_indexes_[2];
};

class e_roadMarkRule: public ::xml_schema::string
{
  public:
  enum value
  {
    no_passing,
    caution,
    none
  };

  e_roadMarkRule (value v);

  e_roadMarkRule (const char* v);

  e_roadMarkRule (const ::std::string& v);

  e_roadMarkRule (const ::xml_schema::string& v);

  e_roadMarkRule (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_roadMarkRule (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_roadMarkRule (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  e_roadMarkRule (const e_roadMarkRule& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual e_roadMarkRule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_roadMarkRule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_roadMarkRule_convert ();
  }

  protected:
  value
  _xsd_e_roadMarkRule_convert () const;

  public:
  static const char* const _xsd_e_roadMarkRule_literals_[3];
  static const value _xsd_e_roadMarkRule_indexes_[3];
};

class e_orientation: public ::xml_schema::string
{
  public:
  enum value
  {
    cxx_,
    cxx_1,
    none
  };

  e_orientation (value v);

  e_orientation (const char* v);

  e_orientation (const ::std::string& v);

  e_orientation (const ::xml_schema::string& v);

  e_orientation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_orientation (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_orientation (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  e_orientation (const e_orientation& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual e_orientation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  e_orientation&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_e_orientation_convert ();
  }

  protected:
  value
  _xsd_e_orientation_convert () const;

  public:
  static const char* const _xsd_e_orientation_literals_[3];
  static const value _xsd_e_orientation_indexes_[3];
};

class OpenDRIVE: public ::xml_schema::type
{
  public:
  // header
  //
  typedef ::t_header header_type;
  typedef ::xsd::cxx::tree::traits< header_type, char > header_traits;

  const header_type&
  header () const;

  header_type&
  header ();

  void
  header (const header_type& x);

  void
  header (::std::unique_ptr< header_type > p);

  // road
  //
  typedef ::t_road road_type;
  typedef ::xsd::cxx::tree::sequence< road_type > road_sequence;
  typedef road_sequence::iterator road_iterator;
  typedef road_sequence::const_iterator road_const_iterator;
  typedef ::xsd::cxx::tree::traits< road_type, char > road_traits;

  const road_sequence&
  road () const;

  road_sequence&
  road ();

  void
  road (const road_sequence& s);

  // controller
  //
  typedef ::t_controller controller_type;
  typedef ::xsd::cxx::tree::sequence< controller_type > controller_sequence;
  typedef controller_sequence::iterator controller_iterator;
  typedef controller_sequence::const_iterator controller_const_iterator;
  typedef ::xsd::cxx::tree::traits< controller_type, char > controller_traits;

  const controller_sequence&
  controller () const;

  controller_sequence&
  controller ();

  void
  controller (const controller_sequence& s);

  // junction
  //
  typedef ::t_junction junction_type;
  typedef ::xsd::cxx::tree::sequence< junction_type > junction_sequence;
  typedef junction_sequence::iterator junction_iterator;
  typedef junction_sequence::const_iterator junction_const_iterator;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_sequence&
  junction () const;

  junction_sequence&
  junction ();

  void
  junction (const junction_sequence& s);

  // junctionGroup
  //
  typedef ::t_junctionGroup junctionGroup_type;
  typedef ::xsd::cxx::tree::sequence< junctionGroup_type > junctionGroup_sequence;
  typedef junctionGroup_sequence::iterator junctionGroup_iterator;
  typedef junctionGroup_sequence::const_iterator junctionGroup_const_iterator;
  typedef ::xsd::cxx::tree::traits< junctionGroup_type, char > junctionGroup_traits;

  const junctionGroup_sequence&
  junctionGroup () const;

  junctionGroup_sequence&
  junctionGroup ();

  void
  junctionGroup (const junctionGroup_sequence& s);

  // station
  //
  typedef ::t_station station_type;
  typedef ::xsd::cxx::tree::sequence< station_type > station_sequence;
  typedef station_sequence::iterator station_iterator;
  typedef station_sequence::const_iterator station_const_iterator;
  typedef ::xsd::cxx::tree::traits< station_type, char > station_traits;

  const station_sequence&
  station () const;

  station_sequence&
  station ();

  void
  station (const station_sequence& s);

  // userData
  //
  typedef ::t_userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::t_include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // dataQuality
  //
  typedef ::t_dataQuality dataQuality_type;
  typedef ::xsd::cxx::tree::optional< dataQuality_type > dataQuality_optional;
  typedef ::xsd::cxx::tree::traits< dataQuality_type, char > dataQuality_traits;

  const dataQuality_optional&
  dataQuality () const;

  dataQuality_optional&
  dataQuality ();

  void
  dataQuality (const dataQuality_type& x);

  void
  dataQuality (const dataQuality_optional& x);

  void
  dataQuality (::std::unique_ptr< dataQuality_type > p);

  // Constructors.
  //
  OpenDRIVE (const header_type&);

  OpenDRIVE (::std::unique_ptr< header_type >);

  OpenDRIVE (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  OpenDRIVE (const OpenDRIVE& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual OpenDRIVE*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OpenDRIVE&
  operator= (const OpenDRIVE& x);

  virtual 
  ~OpenDRIVE ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< header_type > header_;
  road_sequence road_;
  controller_sequence controller_;
  junction_sequence junction_;
  junctionGroup_sequence junctionGroup_;
  station_sequence station_;
  userData_sequence userData_;
  include_sequence include_;
  dataQuality_optional dataQuality_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const t_grEqZero&);

void
operator<< (::xercesc::DOMAttr&, const t_grEqZero&);

void
operator<< (::xml_schema::list_stream&,
            const t_grEqZero&);

void
operator<< (::xercesc::DOMElement&, const t_grZero&);

void
operator<< (::xercesc::DOMAttr&, const t_grZero&);

void
operator<< (::xml_schema::list_stream&,
            const t_grZero&);

void
operator<< (::xercesc::DOMElement&, const t_zeroOne&);

void
operator<< (::xercesc::DOMAttr&, const t_zeroOne&);

void
operator<< (::xml_schema::list_stream&,
            const t_zeroOne&);

void
operator<< (::xercesc::DOMElement&, const t_bool&);

void
operator<< (::xercesc::DOMAttr&, const t_bool&);

void
operator<< (::xml_schema::list_stream&,
            const t_bool&);

void
operator<< (::xercesc::DOMElement&, const t_yesNo&);

void
operator<< (::xercesc::DOMAttr&, const t_yesNo&);

void
operator<< (::xml_schema::list_stream&,
            const t_yesNo&);

void
operator<< (::xercesc::DOMElement&, const t_header_Version&);

void
operator<< (::xercesc::DOMAttr&, const t_header_Version&);

void
operator<< (::xml_schema::list_stream&,
            const t_header_Version&);

void
operator<< (::xercesc::DOMElement&, const t_maxSpeed&);

void
operator<< (::xercesc::DOMAttr&, const t_maxSpeed&);

void
operator<< (::xml_schema::list_stream&,
            const t_maxSpeed&);

void
operator<< (::xercesc::DOMElement&, const e_maxSpeedString&);

void
operator<< (::xercesc::DOMAttr&, const e_maxSpeedString&);

void
operator<< (::xml_schema::list_stream&,
            const e_maxSpeedString&);

void
operator<< (::xercesc::DOMElement&, const t_junction_id&);

void
operator<< (::xercesc::DOMAttr&, const t_junction_id&);

void
operator<< (::xml_schema::list_stream&,
            const t_junction_id&);

// Serialize to std::ostream.
//

void
OpenDRIVE_ (::std::ostream& os,
            const ::OpenDRIVE& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
OpenDRIVE_ (::std::ostream& os,
            const ::OpenDRIVE& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
OpenDRIVE_ (::std::ostream& os,
            const ::OpenDRIVE& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
OpenDRIVE_ (::xercesc::XMLFormatTarget& ft,
            const ::OpenDRIVE& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
OpenDRIVE_ (::xercesc::XMLFormatTarget& ft,
            const ::OpenDRIVE& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
OpenDRIVE_ (::xercesc::XMLFormatTarget& ft,
            const ::OpenDRIVE& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
OpenDRIVE_ (::xercesc::DOMDocument& d,
            const ::OpenDRIVE& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
OpenDRIVE_ (const ::OpenDRIVE& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const t_header&);

void
operator<< (::xercesc::DOMElement&, const t_header_GeoReference&);

void
operator<< (::xercesc::DOMElement&, const t_header_Offset&);

void
operator<< (::xercesc::DOMElement&, const t_road&);

void
operator<< (::xercesc::DOMElement&, const e_trafficRule&);

void
operator<< (::xercesc::DOMAttr&, const e_trafficRule&);

void
operator<< (::xml_schema::list_stream&,
            const e_trafficRule&);

void
operator<< (::xercesc::DOMElement&, const t_road_link&);

void
operator<< (::xercesc::DOMElement&, const t_road_link_predecessorSuccessor&);

void
operator<< (::xercesc::DOMElement&, const e_road_link_elementType&);

void
operator<< (::xercesc::DOMAttr&, const e_road_link_elementType&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_link_elementType&);

void
operator<< (::xercesc::DOMElement&, const t_road_link_neighbor&);

void
operator<< (::xercesc::DOMElement&, const e_road_link_neighbor_side&);

void
operator<< (::xercesc::DOMAttr&, const e_road_link_neighbor_side&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_link_neighbor_side&);

void
operator<< (::xercesc::DOMElement&, const t_road_type&);

void
operator<< (::xercesc::DOMElement&, const t_road_type_speed&);

void
operator<< (::xercesc::DOMElement&, const t_road_planView&);

void
operator<< (::xercesc::DOMElement&, const t_road_planView_geometry&);

void
operator<< (::xercesc::DOMElement&, const t_road_planView_geometry_line&);

void
operator<< (::xercesc::DOMElement&, const t_road_planView_geometry_spiral&);

void
operator<< (::xercesc::DOMElement&, const t_road_planView_geometry_arc&);

void
operator<< (::xercesc::DOMElement&, const t_road_planView_geometry_poly3&);

void
operator<< (::xercesc::DOMElement&, const t_road_planView_geometry_paramPoly3&);

void
operator<< (::xercesc::DOMElement&, const e_paramPoly3_pRange&);

void
operator<< (::xercesc::DOMAttr&, const e_paramPoly3_pRange&);

void
operator<< (::xml_schema::list_stream&,
            const e_paramPoly3_pRange&);

void
operator<< (::xercesc::DOMElement&, const t_road_elevationProfile&);

void
operator<< (::xercesc::DOMElement&, const t_road_elevationProfile_elevation&);

void
operator<< (::xercesc::DOMElement&, const t_road_lateralProfile&);

void
operator<< (::xercesc::DOMElement&, const t_road_lateralProfile_superelevation&);

void
operator<< (::xercesc::DOMElement&, const t_road_lateralProfile_crossfall&);

void
operator<< (::xercesc::DOMElement&, const e_road_lateralProfile_crossfall_side&);

void
operator<< (::xercesc::DOMAttr&, const e_road_lateralProfile_crossfall_side&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_lateralProfile_crossfall_side&);

void
operator<< (::xercesc::DOMElement&, const t_road_lateralProfile_shape&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneOffset&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_left&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_center&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_right&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_center_lane&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_left_lane&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_right_lane&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_link&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_width&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_border&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_roadMark&);

void
operator<< (::xercesc::DOMElement&, const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange&);

void
operator<< (::xercesc::DOMAttr&, const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_lanes_laneSection_lcr_lane_roadMark_laneChange&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_roadMark_sway&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_roadMark_type&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_roadMark_type_line&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_roadMark_explicit&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_material&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_visibility&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_speed&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_access&);

void
operator<< (::xercesc::DOMElement&, const e_road_lanes_laneSection_lr_lane_access_rule&);

void
operator<< (::xercesc::DOMAttr&, const e_road_lanes_laneSection_lr_lane_access_rule&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_lanes_laneSection_lr_lane_access_rule&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_height&);

void
operator<< (::xercesc::DOMElement&, const t_road_lanes_laneSection_lr_lane_rule&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_repeat&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_outlines&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_outlines_outline&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_outlines_outline_cornerRoad&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_outlines_outline_cornerLocal&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_material&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_laneValidity&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_parkingSpace&);

void
operator<< (::xercesc::DOMElement&, const e_road_objects_object_parkingSpace_access&);

void
operator<< (::xercesc::DOMAttr&, const e_road_objects_object_parkingSpace_access&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_objects_object_parkingSpace_access&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_markings&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_markings_marking&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_markings_marking_cornerReference&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_borders&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_object_borders_border&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_objectReference&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_tunnel&);

void
operator<< (::xercesc::DOMElement&, const t_road_objects_bridge&);

void
operator<< (::xercesc::DOMElement&, const t_road_signals&);

void
operator<< (::xercesc::DOMElement&, const t_road_signals_signal&);

void
operator<< (::xercesc::DOMElement&, const t_road_signals_signal_dependency&);

void
operator<< (::xercesc::DOMElement&, const t_road_signals_signal_reference&);

void
operator<< (::xercesc::DOMElement&, const e_road_signals_signal_reference_elementType&);

void
operator<< (::xercesc::DOMAttr&, const e_road_signals_signal_reference_elementType&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_signals_signal_reference_elementType&);

void
operator<< (::xercesc::DOMElement&, const t_road_signals_signal_positionRoad&);

void
operator<< (::xercesc::DOMElement&, const t_road_signals_signal_positionInertial&);

void
operator<< (::xercesc::DOMElement&, const t_road_signals_signalReference&);

void
operator<< (::xercesc::DOMElement&, const t_road_surface&);

void
operator<< (::xercesc::DOMElement&, const t_road_surface_CRG&);

void
operator<< (::xercesc::DOMElement&, const e_road_surface_CRG_purpose&);

void
operator<< (::xercesc::DOMAttr&, const e_road_surface_CRG_purpose&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_surface_CRG_purpose&);

void
operator<< (::xercesc::DOMElement&, const e_road_surface_CRG_mode&);

void
operator<< (::xercesc::DOMAttr&, const e_road_surface_CRG_mode&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_surface_CRG_mode&);

void
operator<< (::xercesc::DOMElement&, const t_road_railroad&);

void
operator<< (::xercesc::DOMElement&, const t_road_railroad_switch&);

void
operator<< (::xercesc::DOMElement&, const e_road_railroad_switch_position&);

void
operator<< (::xercesc::DOMAttr&, const e_road_railroad_switch_position&);

void
operator<< (::xml_schema::list_stream&,
            const e_road_railroad_switch_position&);

void
operator<< (::xercesc::DOMElement&, const t_road_railroad_switch_mainTrack&);

void
operator<< (::xercesc::DOMElement&, const t_road_railroad_switch_sideTrack&);

void
operator<< (::xercesc::DOMElement&, const t_road_railroad_switch_partner&);

void
operator<< (::xercesc::DOMElement&, const t_controller&);

void
operator<< (::xercesc::DOMElement&, const t_controller_control&);

void
operator<< (::xercesc::DOMElement&, const t_junction&);

void
operator<< (::xercesc::DOMElement&, const e_junction_type&);

void
operator<< (::xercesc::DOMAttr&, const e_junction_type&);

void
operator<< (::xml_schema::list_stream&,
            const e_junction_type&);

void
operator<< (::xercesc::DOMElement&, const t_junction_connection&);

void
operator<< (::xercesc::DOMElement&, const t_junction_predecessorSuccessor&);

void
operator<< (::xercesc::DOMElement&, const t_junction_connection_laneLink&);

void
operator<< (::xercesc::DOMElement&, const t_junction_priority&);

void
operator<< (::xercesc::DOMElement&, const t_junction_controller&);

void
operator<< (::xercesc::DOMElement&, const t_junction_surface&);

void
operator<< (::xercesc::DOMElement&, const t_junction_surface_CRG&);

void
operator<< (::xercesc::DOMElement&, const t_junctionGroup&);

void
operator<< (::xercesc::DOMElement&, const e_junctionGroup_type&);

void
operator<< (::xercesc::DOMAttr&, const e_junctionGroup_type&);

void
operator<< (::xml_schema::list_stream&,
            const e_junctionGroup_type&);

void
operator<< (::xercesc::DOMElement&, const t_junctionGroup_junctionReference&);

void
operator<< (::xercesc::DOMElement&, const t_station&);

void
operator<< (::xercesc::DOMElement&, const e_station_type&);

void
operator<< (::xercesc::DOMAttr&, const e_station_type&);

void
operator<< (::xml_schema::list_stream&,
            const e_station_type&);

void
operator<< (::xercesc::DOMElement&, const t_station_platform&);

void
operator<< (::xercesc::DOMElement&, const t_station_platform_segment&);

void
operator<< (::xercesc::DOMElement&, const e_station_platform_segment_side&);

void
operator<< (::xercesc::DOMAttr&, const e_station_platform_segment_side&);

void
operator<< (::xml_schema::list_stream&,
            const e_station_platform_segment_side&);

void
operator<< (::xercesc::DOMElement&, const t_userData&);

void
operator<< (::xercesc::DOMElement&, const t_include&);

void
operator<< (::xercesc::DOMElement&, const t_dataQuality&);

void
operator<< (::xercesc::DOMElement&, const t_dataQuality_Error&);

void
operator<< (::xercesc::DOMElement&, const t_dataQuality_RawData&);

void
operator<< (::xercesc::DOMElement&, const e_dataQuality_RawData_Source&);

void
operator<< (::xercesc::DOMAttr&, const e_dataQuality_RawData_Source&);

void
operator<< (::xml_schema::list_stream&,
            const e_dataQuality_RawData_Source&);

void
operator<< (::xercesc::DOMElement&, const e_dataQuality_RawData_PostProcessing&);

void
operator<< (::xercesc::DOMAttr&, const e_dataQuality_RawData_PostProcessing&);

void
operator<< (::xml_schema::list_stream&,
            const e_dataQuality_RawData_PostProcessing&);

void
operator<< (::xercesc::DOMElement&, const e_unitDistance&);

void
operator<< (::xercesc::DOMAttr&, const e_unitDistance&);

void
operator<< (::xml_schema::list_stream&,
            const e_unitDistance&);

void
operator<< (::xercesc::DOMElement&, const e_unitSpeed&);

void
operator<< (::xercesc::DOMAttr&, const e_unitSpeed&);

void
operator<< (::xml_schema::list_stream&,
            const e_unitSpeed&);

void
operator<< (::xercesc::DOMElement&, const e_unitMass&);

void
operator<< (::xercesc::DOMAttr&, const e_unitMass&);

void
operator<< (::xml_schema::list_stream&,
            const e_unitMass&);

void
operator<< (::xercesc::DOMElement&, const e_unitSlope&);

void
operator<< (::xercesc::DOMAttr&, const e_unitSlope&);

void
operator<< (::xml_schema::list_stream&,
            const e_unitSlope&);

void
operator<< (::xercesc::DOMElement&, const e_unit&);

void
operator<< (::xercesc::DOMAttr&, const e_unit&);

void
operator<< (::xml_schema::list_stream&,
            const e_unit&);

void
operator<< (::xercesc::DOMElement&, const e_roadType&);

void
operator<< (::xercesc::DOMAttr&, const e_roadType&);

void
operator<< (::xml_schema::list_stream&,
            const e_roadType&);

void
operator<< (::xercesc::DOMElement&, const e_roadMarkType&);

void
operator<< (::xercesc::DOMAttr&, const e_roadMarkType&);

void
operator<< (::xml_schema::list_stream&,
            const e_roadMarkType&);

void
operator<< (::xercesc::DOMElement&, const e_roadMarkWeight&);

void
operator<< (::xercesc::DOMAttr&, const e_roadMarkWeight&);

void
operator<< (::xml_schema::list_stream&,
            const e_roadMarkWeight&);

void
operator<< (::xercesc::DOMElement&, const e_roadMarkColor&);

void
operator<< (::xercesc::DOMAttr&, const e_roadMarkColor&);

void
operator<< (::xml_schema::list_stream&,
            const e_roadMarkColor&);

void
operator<< (::xercesc::DOMElement&, const e_laneType&);

void
operator<< (::xercesc::DOMAttr&, const e_laneType&);

void
operator<< (::xml_schema::list_stream&,
            const e_laneType&);

void
operator<< (::xercesc::DOMElement&, const e_objectType&);

void
operator<< (::xercesc::DOMAttr&, const e_objectType&);

void
operator<< (::xml_schema::list_stream&,
            const e_objectType&);

void
operator<< (::xercesc::DOMElement&, const e_tunnelType&);

void
operator<< (::xercesc::DOMAttr&, const e_tunnelType&);

void
operator<< (::xml_schema::list_stream&,
            const e_tunnelType&);

void
operator<< (::xercesc::DOMElement&, const e_bridgeType&);

void
operator<< (::xercesc::DOMAttr&, const e_bridgeType&);

void
operator<< (::xml_schema::list_stream&,
            const e_bridgeType&);

void
operator<< (::xercesc::DOMElement&, const e_accessRestrictionType&);

void
operator<< (::xercesc::DOMAttr&, const e_accessRestrictionType&);

void
operator<< (::xml_schema::list_stream&,
            const e_accessRestrictionType&);

void
operator<< (::xercesc::DOMElement&, const e_countryCode&);

void
operator<< (::xercesc::DOMAttr&, const e_countryCode&);

void
operator<< (::xml_schema::list_stream&,
            const e_countryCode&);

void
operator<< (::xercesc::DOMElement&, const e_countryCode_deprecated&);

void
operator<< (::xercesc::DOMAttr&, const e_countryCode_deprecated&);

void
operator<< (::xml_schema::list_stream&,
            const e_countryCode_deprecated&);

void
operator<< (::xercesc::DOMElement&, const e_countryCode_iso3166alpha3&);

void
operator<< (::xercesc::DOMAttr&, const e_countryCode_iso3166alpha3&);

void
operator<< (::xml_schema::list_stream&,
            const e_countryCode_iso3166alpha3&);

void
operator<< (::xercesc::DOMElement&, const e_sideType&);

void
operator<< (::xercesc::DOMAttr&, const e_sideType&);

void
operator<< (::xml_schema::list_stream&,
            const e_sideType&);

void
operator<< (::xercesc::DOMElement&, const e_outlineFillType&);

void
operator<< (::xercesc::DOMAttr&, const e_outlineFillType&);

void
operator<< (::xml_schema::list_stream&,
            const e_outlineFillType&);

void
operator<< (::xercesc::DOMElement&, const e_borderType&);

void
operator<< (::xercesc::DOMAttr&, const e_borderType&);

void
operator<< (::xml_schema::list_stream&,
            const e_borderType&);

void
operator<< (::xercesc::DOMElement&, const e_contactPoint&);

void
operator<< (::xercesc::DOMAttr&, const e_contactPoint&);

void
operator<< (::xml_schema::list_stream&,
            const e_contactPoint&);

void
operator<< (::xercesc::DOMElement&, const e_elementDir&);

void
operator<< (::xercesc::DOMAttr&, const e_elementDir&);

void
operator<< (::xml_schema::list_stream&,
            const e_elementDir&);

void
operator<< (::xercesc::DOMElement&, const e_direction&);

void
operator<< (::xercesc::DOMAttr&, const e_direction&);

void
operator<< (::xml_schema::list_stream&,
            const e_direction&);

void
operator<< (::xercesc::DOMElement&, const e_roadMarkRule&);

void
operator<< (::xercesc::DOMAttr&, const e_roadMarkRule&);

void
operator<< (::xml_schema::list_stream&,
            const e_roadMarkRule&);

void
operator<< (::xercesc::DOMElement&, const e_orientation&);

void
operator<< (::xercesc::DOMAttr&, const e_orientation&);

void
operator<< (::xml_schema::list_stream&,
            const e_orientation&);

void
operator<< (::xercesc::DOMElement&, const OpenDRIVE&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // OPEN_DRIVE_1_5M_H
