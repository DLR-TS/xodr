// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef SCHEMA_OPEN_DRIVE_1_4H_H
#define SCHEMA_OPEN_DRIVE_1_4H_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class elementType;
class t_max;
class contactPoint;
class side;
class direction;
class roadType;
class unit;
class pRange;
class crossfallSide;
class singleSide;
class laneType;
class roadmarkType;
class weight;
class color;
class restriction;
class laneChange;
class rule;
class orientation;
class tunnelType;
class bridgeType;
class parkingSpace_access;
class parkingSpacemarkingSide;
class dynamic;
class surfaceOrientation;
class mode;
class purpose;
class position;
class dir;
class junctionGroupType;
class stationType;
class userData;
class include;
class laneValidity;
class parkingSpace;
class lane;
class centerLane;
class OpenDRIVE;
class max_member;
class max_member1;
class marking;
class lane_link;
class width;
class border;
class roadMark;
class material;
class visibility;
class speed;
class access1;
class height;
class rule1;
class link1;
class roadMark1;
class header;
class road;
class controller;
class junction;
class junctionGroup;
class station;
class predecessor;
class successor;
class type;
class type1;
class link2;
class type2;
class planView;
class elevationProfile;
class lateralProfile;
class lanes;
class objects;
class signals;
class surface;
class railroad;
class control;
class connection;
class priority;
class controller1;
class junctionReference;
class platform;
class line;
class predecessor1;
class successor1;
class neighbor;
class speed1;
class geometry;
class elevation;
class superelevation;
class crossfall;
class shape;
class laneOffset;
class laneSection;
class object;
class objectReference;
class tunnel;
class bridge;
class t_signal;
class signalReference;
class CRG;
class switch_;
class laneLink;
class segment;
class line1;
class spiral;
class arc;
class poly3;
class paramPoly3;
class left;
class center;
class right;
class repeat;
class outline;
class material1;
class dependency;
class mainTrack;
class sideTrack;
class partner;
class cornerRoad;
class cornerLocal;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class elementType: public ::xml_schema::string
{
  public:
  enum value
  {
    road,
    junction
  };

  elementType (value v);

  elementType (const char* v);

  elementType (const ::std::string& v);

  elementType (const ::xml_schema::string& v);

  elementType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  elementType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  elementType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  elementType (const elementType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual elementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  elementType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_elementType_convert ();
  }

  protected:
  value
  _xsd_elementType_convert () const;

  public:
  static const char* const _xsd_elementType_literals_[2];
  static const value _xsd_elementType_indexes_[2];
};

class t_max: public ::xml_schema::string
{
  public:

  t_max (const char* v);

  t_max (const ::std::string& v);

  t_max (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  t_max (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  t_max (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  t_max (const t_max& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual t_max*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class contactPoint: public ::xml_schema::string
{
  public:
  enum value
  {
    start,
    end
  };

  contactPoint (value v);

  contactPoint (const char* v);

  contactPoint (const ::std::string& v);

  contactPoint (const ::xml_schema::string& v);

  contactPoint (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  contactPoint (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  contactPoint (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  contactPoint (const contactPoint& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual contactPoint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  contactPoint&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_contactPoint_convert ();
  }

  protected:
  value
  _xsd_contactPoint_convert () const;

  public:
  static const char* const _xsd_contactPoint_literals_[2];
  static const value _xsd_contactPoint_indexes_[2];
};

class side: public ::xml_schema::string
{
  public:
  enum value
  {
    left,
    right
  };

  side (value v);

  side (const char* v);

  side (const ::std::string& v);

  side (const ::xml_schema::string& v);

  side (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  side (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  side (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  side (const side& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual side*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  side&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_side_convert ();
  }

  protected:
  value
  _xsd_side_convert () const;

  public:
  static const char* const _xsd_side_literals_[2];
  static const value _xsd_side_indexes_[2];
};

class direction: public ::xml_schema::string
{
  public:
  enum value
  {
    same,
    opposite
  };

  direction (value v);

  direction (const char* v);

  direction (const ::std::string& v);

  direction (const ::xml_schema::string& v);

  direction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  direction (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  direction (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  direction (const direction& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual direction*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  direction&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_direction_convert ();
  }

  protected:
  value
  _xsd_direction_convert () const;

  public:
  static const char* const _xsd_direction_literals_[2];
  static const value _xsd_direction_indexes_[2];
};

class roadType: public ::xml_schema::string
{
  public:
  enum value
  {
    unknown,
    rural,
    motorway,
    town,
    lowSpeed,
    pedestrian,
    bicycle
  };

  roadType (value v);

  roadType (const char* v);

  roadType (const ::std::string& v);

  roadType (const ::xml_schema::string& v);

  roadType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  roadType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  roadType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  roadType (const roadType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual roadType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  roadType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_roadType_convert ();
  }

  protected:
  value
  _xsd_roadType_convert () const;

  public:
  static const char* const _xsd_roadType_literals_[7];
  static const value _xsd_roadType_indexes_[7];
};

class unit: public ::xml_schema::string
{
  public:
  enum value
  {
    m,
    km,
    ft,
    mile,
    m_s,
    mph,
    km_h,
    kg,
    t,
    cxx_
  };

  unit (value v);

  unit (const char* v);

  unit (const ::std::string& v);

  unit (const ::xml_schema::string& v);

  unit (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  unit (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  unit (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  unit (const unit& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual unit*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  unit&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_unit_convert ();
  }

  protected:
  value
  _xsd_unit_convert () const;

  public:
  static const char* const _xsd_unit_literals_[10];
  static const value _xsd_unit_indexes_[10];
};

class pRange: public ::xml_schema::string
{
  public:
  enum value
  {
    arcLength,
    normalized
  };

  pRange (value v);

  pRange (const char* v);

  pRange (const ::std::string& v);

  pRange (const ::xml_schema::string& v);

  pRange (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  pRange (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  pRange (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  pRange (const pRange& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual pRange*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  pRange&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_pRange_convert ();
  }

  protected:
  value
  _xsd_pRange_convert () const;

  public:
  static const char* const _xsd_pRange_literals_[2];
  static const value _xsd_pRange_indexes_[2];
};

class crossfallSide: public ::xml_schema::string
{
  public:
  enum value
  {
    left,
    right,
    both
  };

  crossfallSide (value v);

  crossfallSide (const char* v);

  crossfallSide (const ::std::string& v);

  crossfallSide (const ::xml_schema::string& v);

  crossfallSide (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  crossfallSide (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  crossfallSide (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  crossfallSide (const crossfallSide& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual crossfallSide*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  crossfallSide&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_crossfallSide_convert ();
  }

  protected:
  value
  _xsd_crossfallSide_convert () const;

  public:
  static const char* const _xsd_crossfallSide_literals_[3];
  static const value _xsd_crossfallSide_indexes_[3];
};

class singleSide: public ::xml_schema::string
{
  public:
  enum value
  {
    true_,
    false_
  };

  singleSide (value v);

  singleSide (const char* v);

  singleSide (const ::std::string& v);

  singleSide (const ::xml_schema::string& v);

  singleSide (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  singleSide (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  singleSide (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  singleSide (const singleSide& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual singleSide*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  singleSide&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_singleSide_convert ();
  }

  protected:
  value
  _xsd_singleSide_convert () const;

  public:
  static const char* const _xsd_singleSide_literals_[2];
  static const value _xsd_singleSide_indexes_[2];
};

class laneType: public ::xml_schema::string
{
  public:
  enum value
  {
    none,
    driving,
    stop,
    shoulder,
    biking,
    sidewalk,
    border,
    restricted,
    parking,
    bidirectional,
    median,
    special1,
    special2,
    special3,
    roadWorks,
    tram,
    rail,
    entry,
    exit,
    offRamp,
    onRamp
  };

  laneType (value v);

  laneType (const char* v);

  laneType (const ::std::string& v);

  laneType (const ::xml_schema::string& v);

  laneType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  laneType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  laneType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  laneType (const laneType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual laneType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_laneType_convert ();
  }

  protected:
  value
  _xsd_laneType_convert () const;

  public:
  static const char* const _xsd_laneType_literals_[21];
  static const value _xsd_laneType_indexes_[21];
};

class roadmarkType: public ::xml_schema::string
{
  public:
  enum value
  {
    none,
    solid,
    broken,
    solid_solid,
    solid_broken,
    broken_solid,
    broken_broken,
    botts_dots,
    grass,
    curb
  };

  roadmarkType (value v);

  roadmarkType (const char* v);

  roadmarkType (const ::std::string& v);

  roadmarkType (const ::xml_schema::string& v);

  roadmarkType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  roadmarkType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  roadmarkType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  roadmarkType (const roadmarkType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual roadmarkType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  roadmarkType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_roadmarkType_convert ();
  }

  protected:
  value
  _xsd_roadmarkType_convert () const;

  public:
  static const char* const _xsd_roadmarkType_literals_[10];
  static const value _xsd_roadmarkType_indexes_[10];
};

class weight: public ::xml_schema::string
{
  public:
  enum value
  {
    standard,
    bold
  };

  weight (value v);

  weight (const char* v);

  weight (const ::std::string& v);

  weight (const ::xml_schema::string& v);

  weight (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  weight (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  weight (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  weight (const weight& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual weight*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  weight&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_weight_convert ();
  }

  protected:
  value
  _xsd_weight_convert () const;

  public:
  static const char* const _xsd_weight_literals_[2];
  static const value _xsd_weight_indexes_[2];
};

class color: public ::xml_schema::string
{
  public:
  enum value
  {
    standard,
    blue,
    green,
    red,
    white,
    yellow
  };

  color (value v);

  color (const char* v);

  color (const ::std::string& v);

  color (const ::xml_schema::string& v);

  color (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  color (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  color (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  color (const color& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual color*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  color&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_color_convert ();
  }

  protected:
  value
  _xsd_color_convert () const;

  public:
  static const char* const _xsd_color_literals_[6];
  static const value _xsd_color_indexes_[6];
};

class restriction: public ::xml_schema::string
{
  public:
  enum value
  {
    simulator,
    autonomous_traffic,
    pedestrian,
    none
  };

  restriction (value v);

  restriction (const char* v);

  restriction (const ::std::string& v);

  restriction (const ::xml_schema::string& v);

  restriction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  restriction (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  restriction (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  restriction (const restriction& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual restriction*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  restriction&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_restriction_convert ();
  }

  protected:
  value
  _xsd_restriction_convert () const;

  public:
  static const char* const _xsd_restriction_literals_[4];
  static const value _xsd_restriction_indexes_[4];
};

class laneChange: public ::xml_schema::string
{
  public:
  enum value
  {
    increase,
    decrease,
    both,
    none
  };

  laneChange (value v);

  laneChange (const char* v);

  laneChange (const ::std::string& v);

  laneChange (const ::xml_schema::string& v);

  laneChange (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  laneChange (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  laneChange (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  laneChange (const laneChange& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual laneChange*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneChange&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_laneChange_convert ();
  }

  protected:
  value
  _xsd_laneChange_convert () const;

  public:
  static const char* const _xsd_laneChange_literals_[4];
  static const value _xsd_laneChange_indexes_[4];
};

class rule: public ::xml_schema::string
{
  public:
  enum value
  {
    no_passing,
    caution,
    none
  };

  rule (value v);

  rule (const char* v);

  rule (const ::std::string& v);

  rule (const ::xml_schema::string& v);

  rule (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  rule (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  rule (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  rule (const rule& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual rule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  rule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_rule_convert ();
  }

  protected:
  value
  _xsd_rule_convert () const;

  public:
  static const char* const _xsd_rule_literals_[3];
  static const value _xsd_rule_indexes_[3];
};

class orientation: public ::xml_schema::string
{
  public:
  enum value
  {
    cxx_,
    cxx_1,
    none
  };

  orientation (value v);

  orientation (const char* v);

  orientation (const ::std::string& v);

  orientation (const ::xml_schema::string& v);

  orientation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  orientation (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  orientation (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  orientation (const orientation& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual orientation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  orientation&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_orientation_convert ();
  }

  protected:
  value
  _xsd_orientation_convert () const;

  public:
  static const char* const _xsd_orientation_literals_[3];
  static const value _xsd_orientation_indexes_[3];
};

class tunnelType: public ::xml_schema::string
{
  public:
  enum value
  {
    standard,
    underpass
  };

  tunnelType (value v);

  tunnelType (const char* v);

  tunnelType (const ::std::string& v);

  tunnelType (const ::xml_schema::string& v);

  tunnelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  tunnelType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  tunnelType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  tunnelType (const tunnelType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual tunnelType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  tunnelType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_tunnelType_convert ();
  }

  protected:
  value
  _xsd_tunnelType_convert () const;

  public:
  static const char* const _xsd_tunnelType_literals_[2];
  static const value _xsd_tunnelType_indexes_[2];
};

class bridgeType: public ::xml_schema::string
{
  public:
  enum value
  {
    concrete,
    steel,
    brick,
    wood
  };

  bridgeType (value v);

  bridgeType (const char* v);

  bridgeType (const ::std::string& v);

  bridgeType (const ::xml_schema::string& v);

  bridgeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  bridgeType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  bridgeType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  bridgeType (const bridgeType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual bridgeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bridgeType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_bridgeType_convert ();
  }

  protected:
  value
  _xsd_bridgeType_convert () const;

  public:
  static const char* const _xsd_bridgeType_literals_[4];
  static const value _xsd_bridgeType_indexes_[4];
};

class parkingSpace_access: public ::xml_schema::string
{
  public:
  enum value
  {
    all,
    car,
    women,
    handicapped,
    bus,
    truck,
    electric,
    residents
  };

  parkingSpace_access (value v);

  parkingSpace_access (const char* v);

  parkingSpace_access (const ::std::string& v);

  parkingSpace_access (const ::xml_schema::string& v);

  parkingSpace_access (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  parkingSpace_access (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  parkingSpace_access (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  parkingSpace_access (const parkingSpace_access& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual parkingSpace_access*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  parkingSpace_access&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_parkingSpace_access_convert ();
  }

  protected:
  value
  _xsd_parkingSpace_access_convert () const;

  public:
  static const char* const _xsd_parkingSpace_access_literals_[8];
  static const value _xsd_parkingSpace_access_indexes_[8];
};

class parkingSpacemarkingSide: public ::xml_schema::string
{
  public:
  enum value
  {
    front,
    rear,
    left,
    right
  };

  parkingSpacemarkingSide (value v);

  parkingSpacemarkingSide (const char* v);

  parkingSpacemarkingSide (const ::std::string& v);

  parkingSpacemarkingSide (const ::xml_schema::string& v);

  parkingSpacemarkingSide (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  parkingSpacemarkingSide (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  parkingSpacemarkingSide (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  parkingSpacemarkingSide (const parkingSpacemarkingSide& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual parkingSpacemarkingSide*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  parkingSpacemarkingSide&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_parkingSpacemarkingSide_convert ();
  }

  protected:
  value
  _xsd_parkingSpacemarkingSide_convert () const;

  public:
  static const char* const _xsd_parkingSpacemarkingSide_literals_[4];
  static const value _xsd_parkingSpacemarkingSide_indexes_[4];
};

class dynamic: public ::xml_schema::string
{
  public:
  enum value
  {
    yes,
    no
  };

  dynamic (value v);

  dynamic (const char* v);

  dynamic (const ::std::string& v);

  dynamic (const ::xml_schema::string& v);

  dynamic (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  dynamic (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  dynamic (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  dynamic (const dynamic& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual dynamic*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  dynamic&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_dynamic_convert ();
  }

  protected:
  value
  _xsd_dynamic_convert () const;

  public:
  static const char* const _xsd_dynamic_literals_[2];
  static const value _xsd_dynamic_indexes_[2];
};

class surfaceOrientation: public ::xml_schema::string
{
  public:
  enum value
  {
    same,
    opposite
  };

  surfaceOrientation (value v);

  surfaceOrientation (const char* v);

  surfaceOrientation (const ::std::string& v);

  surfaceOrientation (const ::xml_schema::string& v);

  surfaceOrientation (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  surfaceOrientation (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  surfaceOrientation (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  surfaceOrientation (const surfaceOrientation& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual surfaceOrientation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  surfaceOrientation&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_surfaceOrientation_convert ();
  }

  protected:
  value
  _xsd_surfaceOrientation_convert () const;

  public:
  static const char* const _xsd_surfaceOrientation_literals_[2];
  static const value _xsd_surfaceOrientation_indexes_[2];
};

class mode: public ::xml_schema::string
{
  public:
  enum value
  {
    attached,
    attached0,
    genuine
  };

  mode (value v);

  mode (const char* v);

  mode (const ::std::string& v);

  mode (const ::xml_schema::string& v);

  mode (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  mode (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  mode (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  mode (const mode& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual mode*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  mode&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_mode_convert ();
  }

  protected:
  value
  _xsd_mode_convert () const;

  public:
  static const char* const _xsd_mode_literals_[3];
  static const value _xsd_mode_indexes_[3];
};

class purpose: public ::xml_schema::string
{
  public:
  enum value
  {
    elevation,
    friction
  };

  purpose (value v);

  purpose (const char* v);

  purpose (const ::std::string& v);

  purpose (const ::xml_schema::string& v);

  purpose (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  purpose (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  purpose (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  purpose (const purpose& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual purpose*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  purpose&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_purpose_convert ();
  }

  protected:
  value
  _xsd_purpose_convert () const;

  public:
  static const char* const _xsd_purpose_literals_[2];
  static const value _xsd_purpose_indexes_[2];
};

class position: public ::xml_schema::string
{
  public:
  enum value
  {
    dynamic,
    straight,
    turn
  };

  position (value v);

  position (const char* v);

  position (const ::std::string& v);

  position (const ::xml_schema::string& v);

  position (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  position (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  position (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  position (const position& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual position*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  position&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_position_convert ();
  }

  protected:
  value
  _xsd_position_convert () const;

  public:
  static const char* const _xsd_position_literals_[3];
  static const value _xsd_position_indexes_[3];
};

class dir: public ::xml_schema::string
{
  public:
  enum value
  {
    cxx_,
    cxx_1
  };

  dir (value v);

  dir (const char* v);

  dir (const ::std::string& v);

  dir (const ::xml_schema::string& v);

  dir (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  dir (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  dir (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  dir (const dir& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual dir*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  dir&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_dir_convert ();
  }

  protected:
  value
  _xsd_dir_convert () const;

  public:
  static const char* const _xsd_dir_literals_[2];
  static const value _xsd_dir_indexes_[2];
};

class junctionGroupType: public ::xml_schema::string
{
  public:
  enum value
  {
    roundabout,
    unknown
  };

  junctionGroupType (value v);

  junctionGroupType (const char* v);

  junctionGroupType (const ::std::string& v);

  junctionGroupType (const ::xml_schema::string& v);

  junctionGroupType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  junctionGroupType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  junctionGroupType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  junctionGroupType (const junctionGroupType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual junctionGroupType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  junctionGroupType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_junctionGroupType_convert ();
  }

  protected:
  value
  _xsd_junctionGroupType_convert () const;

  public:
  static const char* const _xsd_junctionGroupType_literals_[2];
  static const value _xsd_junctionGroupType_indexes_[2];
};

class stationType: public ::xml_schema::string
{
  public:
  enum value
  {
    small,
    medium,
    large
  };

  stationType (value v);

  stationType (const char* v);

  stationType (const ::std::string& v);

  stationType (const ::xml_schema::string& v);

  stationType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  stationType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  stationType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  stationType (const stationType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual stationType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  stationType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_stationType_convert ();
  }

  protected:
  value
  _xsd_stationType_convert () const;

  public:
  static const char* const _xsd_stationType_literals_[3];
  static const value _xsd_stationType_indexes_[3];
};

class userData: public ::xml_schema::type
{
  public:
  // code
  //
  typedef ::xml_schema::string code_type;
  typedef ::xsd::cxx::tree::optional< code_type > code_optional;
  typedef ::xsd::cxx::tree::traits< code_type, char > code_traits;

  const code_optional&
  code () const;

  code_optional&
  code ();

  void
  code (const code_type& x);

  void
  code (const code_optional& x);

  void
  code (::std::unique_ptr< code_type > p);

  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  void
  value (::std::unique_ptr< value_type > p);

  // Constructors.
  //
  userData ();

  userData (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  userData (const userData& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual userData*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  userData&
  operator= (const userData& x);

  virtual 
  ~userData ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  code_optional code_;
  value_optional value_;
};

class include: public ::xml_schema::type
{
  public:
  // file
  //
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::optional< file_type > file_optional;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_optional&
  file () const;

  file_optional&
  file ();

  void
  file (const file_type& x);

  void
  file (const file_optional& x);

  void
  file (::std::unique_ptr< file_type > p);

  // Constructors.
  //
  include ();

  include (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  include (const include& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual include*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  include&
  operator= (const include& x);

  virtual 
  ~include ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  file_optional file_;
};

class laneValidity: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // fromLane
  //
  typedef ::xml_schema::int_ fromLane_type;
  typedef ::xsd::cxx::tree::optional< fromLane_type > fromLane_optional;
  typedef ::xsd::cxx::tree::traits< fromLane_type, char > fromLane_traits;

  const fromLane_optional&
  fromLane () const;

  fromLane_optional&
  fromLane ();

  void
  fromLane (const fromLane_type& x);

  void
  fromLane (const fromLane_optional& x);

  // toLane
  //
  typedef ::xml_schema::int_ toLane_type;
  typedef ::xsd::cxx::tree::optional< toLane_type > toLane_optional;
  typedef ::xsd::cxx::tree::traits< toLane_type, char > toLane_traits;

  const toLane_optional&
  toLane () const;

  toLane_optional&
  toLane ();

  void
  toLane (const toLane_type& x);

  void
  toLane (const toLane_optional& x);

  // Constructors.
  //
  laneValidity ();

  laneValidity (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  laneValidity (const laneValidity& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual laneValidity*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneValidity&
  operator= (const laneValidity& x);

  virtual 
  ~laneValidity ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  fromLane_optional fromLane_;
  toLane_optional toLane_;
};

class parkingSpace: public ::xml_schema::type
{
  public:
  // marking
  //
  typedef ::marking marking_type;
  typedef ::xsd::cxx::tree::sequence< marking_type > marking_sequence;
  typedef marking_sequence::iterator marking_iterator;
  typedef marking_sequence::const_iterator marking_const_iterator;
  typedef ::xsd::cxx::tree::traits< marking_type, char > marking_traits;

  const marking_sequence&
  marking () const;

  marking_sequence&
  marking ();

  void
  marking (const marking_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // access
  //
  typedef ::parkingSpace_access access_type;
  typedef ::xsd::cxx::tree::optional< access_type > access_optional;
  typedef ::xsd::cxx::tree::traits< access_type, char > access_traits;

  const access_optional&
  parkingSpace_access () const;

  access_optional&
  parkingSpace_access ();

  void
  parkingSpace_access (const access_type& x);

  void
  parkingSpace_access (const access_optional& x);

  void
  parkingSpace_access (::std::unique_ptr< access_type > p);

  // restrictions
  //
  typedef ::xml_schema::string restrictions_type;
  typedef ::xsd::cxx::tree::optional< restrictions_type > restrictions_optional;
  typedef ::xsd::cxx::tree::traits< restrictions_type, char > restrictions_traits;

  const restrictions_optional&
  restrictions () const;

  restrictions_optional&
  restrictions ();

  void
  restrictions (const restrictions_type& x);

  void
  restrictions (const restrictions_optional& x);

  void
  restrictions (::std::unique_ptr< restrictions_type > p);

  // Constructors.
  //
  parkingSpace ();

  parkingSpace (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  parkingSpace (const parkingSpace& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual parkingSpace*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  parkingSpace&
  operator= (const parkingSpace& x);

  virtual 
  ~parkingSpace ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  marking_sequence marking_;
  userData_sequence userData_;
  include_sequence include_;
  access_optional parkingSpace_access_;
  restrictions_optional restrictions_;
};

class lane: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::lane_link link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_optional&
  lane_link () const;

  link_optional&
  lane_link ();

  void
  lane_link (const link_type& x);

  void
  lane_link (const link_optional& x);

  void
  lane_link (::std::unique_ptr< link_type > p);

  // width
  //
  typedef ::width width_type;
  typedef ::xsd::cxx::tree::sequence< width_type > width_sequence;
  typedef width_sequence::iterator width_iterator;
  typedef width_sequence::const_iterator width_const_iterator;
  typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

  const width_sequence&
  width () const;

  width_sequence&
  width ();

  void
  width (const width_sequence& s);

  // border
  //
  typedef ::border border_type;
  typedef ::xsd::cxx::tree::sequence< border_type > border_sequence;
  typedef border_sequence::iterator border_iterator;
  typedef border_sequence::const_iterator border_const_iterator;
  typedef ::xsd::cxx::tree::traits< border_type, char > border_traits;

  const border_sequence&
  border () const;

  border_sequence&
  border ();

  void
  border (const border_sequence& s);

  // roadMark
  //
  typedef ::roadMark roadMark_type;
  typedef ::xsd::cxx::tree::sequence< roadMark_type > roadMark_sequence;
  typedef roadMark_sequence::iterator roadMark_iterator;
  typedef roadMark_sequence::const_iterator roadMark_const_iterator;
  typedef ::xsd::cxx::tree::traits< roadMark_type, char > roadMark_traits;

  const roadMark_sequence&
  roadMark () const;

  roadMark_sequence&
  roadMark ();

  void
  roadMark (const roadMark_sequence& s);

  // material
  //
  typedef ::material material_type;
  typedef ::xsd::cxx::tree::sequence< material_type > material_sequence;
  typedef material_sequence::iterator material_iterator;
  typedef material_sequence::const_iterator material_const_iterator;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_sequence&
  material () const;

  material_sequence&
  material ();

  void
  material (const material_sequence& s);

  // visibility
  //
  typedef ::visibility visibility_type;
  typedef ::xsd::cxx::tree::sequence< visibility_type > visibility_sequence;
  typedef visibility_sequence::iterator visibility_iterator;
  typedef visibility_sequence::const_iterator visibility_const_iterator;
  typedef ::xsd::cxx::tree::traits< visibility_type, char > visibility_traits;

  const visibility_sequence&
  visibility () const;

  visibility_sequence&
  visibility ();

  void
  visibility (const visibility_sequence& s);

  // speed
  //
  typedef ::speed speed_type;
  typedef ::xsd::cxx::tree::sequence< speed_type > speed_sequence;
  typedef speed_sequence::iterator speed_iterator;
  typedef speed_sequence::const_iterator speed_const_iterator;
  typedef ::xsd::cxx::tree::traits< speed_type, char > speed_traits;

  const speed_sequence&
  speed () const;

  speed_sequence&
  speed ();

  void
  speed (const speed_sequence& s);

  // access
  //
  typedef ::access1 access_type;
  typedef ::xsd::cxx::tree::sequence< access_type > access_sequence;
  typedef access_sequence::iterator access_iterator;
  typedef access_sequence::const_iterator access_const_iterator;
  typedef ::xsd::cxx::tree::traits< access_type, char > access_traits;

  const access_sequence&
  parkingSpace_access () const;

  access_sequence&
  parkingSpace_access ();

  void
  parkingSpace_access (const access_sequence& s);

  // height
  //
  typedef ::height height_type;
  typedef ::xsd::cxx::tree::sequence< height_type > height_sequence;
  typedef height_sequence::iterator height_iterator;
  typedef height_sequence::const_iterator height_const_iterator;
  typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

  const height_sequence&
  height () const;

  height_sequence&
  height ();

  void
  height (const height_sequence& s);

  // rule
  //
  typedef ::rule1 rule_type;
  typedef ::xsd::cxx::tree::sequence< rule_type > rule_sequence;
  typedef rule_sequence::iterator rule_iterator;
  typedef rule_sequence::const_iterator rule_const_iterator;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_sequence&
  rule () const;

  rule_sequence&
  rule ();

  void
  rule (const rule_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // type
  //
  typedef ::laneType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // level
  //
  typedef ::singleSide level_type;
  typedef ::xsd::cxx::tree::optional< level_type > level_optional;
  typedef ::xsd::cxx::tree::traits< level_type, char > level_traits;

  const level_optional&
  level () const;

  level_optional&
  level ();

  void
  level (const level_type& x);

  void
  level (const level_optional& x);

  void
  level (::std::unique_ptr< level_type > p);

  // Constructors.
  //
  lane ();

  lane (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  lane (const lane& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual lane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  lane&
  operator= (const lane& x);

  virtual 
  ~lane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  link_optional lane_link_;
  width_sequence width_;
  border_sequence border_;
  roadMark_sequence roadMark_;
  material_sequence material_;
  visibility_sequence visibility_;
  speed_sequence speed_;
  access_sequence parkingSpace_access_;
  height_sequence height_;
  rule_sequence rule_;
  userData_sequence userData_;
  include_sequence include_;
  id_optional id_;
  type_optional type_;
  level_optional level_;
};

class centerLane: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::link1 link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_optional&
  lane_link () const;

  link_optional&
  lane_link ();

  void
  lane_link (const link_type& x);

  void
  lane_link (const link_optional& x);

  void
  lane_link (::std::unique_ptr< link_type > p);

  // roadMark
  //
  typedef ::roadMark1 roadMark_type;
  typedef ::xsd::cxx::tree::sequence< roadMark_type > roadMark_sequence;
  typedef roadMark_sequence::iterator roadMark_iterator;
  typedef roadMark_sequence::const_iterator roadMark_const_iterator;
  typedef ::xsd::cxx::tree::traits< roadMark_type, char > roadMark_traits;

  const roadMark_sequence&
  roadMark () const;

  roadMark_sequence&
  roadMark ();

  void
  roadMark (const roadMark_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // type
  //
  typedef ::laneType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // level
  //
  typedef ::singleSide level_type;
  typedef ::xsd::cxx::tree::optional< level_type > level_optional;
  typedef ::xsd::cxx::tree::traits< level_type, char > level_traits;

  const level_optional&
  level () const;

  level_optional&
  level ();

  void
  level (const level_type& x);

  void
  level (const level_optional& x);

  void
  level (::std::unique_ptr< level_type > p);

  // Constructors.
  //
  centerLane ();

  centerLane (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  centerLane (const centerLane& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual centerLane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  centerLane&
  operator= (const centerLane& x);

  virtual 
  ~centerLane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  link_optional lane_link_;
  roadMark_sequence roadMark_;
  userData_sequence userData_;
  include_sequence include_;
  id_optional id_;
  type_optional type_;
  level_optional level_;
};

class OpenDRIVE: public ::xml_schema::type
{
  public:
  // header
  //
  typedef ::header header_type;
  typedef ::xsd::cxx::tree::traits< header_type, char > header_traits;

  const header_type&
  header () const;

  header_type&
  header ();

  void
  header (const header_type& x);

  void
  header (::std::unique_ptr< header_type > p);

  // road
  //
  typedef ::road road_type;
  typedef ::xsd::cxx::tree::sequence< road_type > road_sequence;
  typedef road_sequence::iterator road_iterator;
  typedef road_sequence::const_iterator road_const_iterator;
  typedef ::xsd::cxx::tree::traits< road_type, char > road_traits;

  const road_sequence&
  road () const;

  road_sequence&
  road ();

  void
  road (const road_sequence& s);

  // controller
  //
  typedef ::controller controller_type;
  typedef ::xsd::cxx::tree::sequence< controller_type > controller_sequence;
  typedef controller_sequence::iterator controller_iterator;
  typedef controller_sequence::const_iterator controller_const_iterator;
  typedef ::xsd::cxx::tree::traits< controller_type, char > controller_traits;

  const controller_sequence&
  controller () const;

  controller_sequence&
  controller ();

  void
  controller (const controller_sequence& s);

  // junction
  //
  typedef ::junction junction_type;
  typedef ::xsd::cxx::tree::sequence< junction_type > junction_sequence;
  typedef junction_sequence::iterator junction_iterator;
  typedef junction_sequence::const_iterator junction_const_iterator;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_sequence&
  junction () const;

  junction_sequence&
  junction ();

  void
  junction (const junction_sequence& s);

  // junctionGroup
  //
  typedef ::junctionGroup junctionGroup_type;
  typedef ::xsd::cxx::tree::sequence< junctionGroup_type > junctionGroup_sequence;
  typedef junctionGroup_sequence::iterator junctionGroup_iterator;
  typedef junctionGroup_sequence::const_iterator junctionGroup_const_iterator;
  typedef ::xsd::cxx::tree::traits< junctionGroup_type, char > junctionGroup_traits;

  const junctionGroup_sequence&
  junctionGroup () const;

  junctionGroup_sequence&
  junctionGroup ();

  void
  junctionGroup (const junctionGroup_sequence& s);

  // station
  //
  typedef ::station station_type;
  typedef ::xsd::cxx::tree::sequence< station_type > station_sequence;
  typedef station_sequence::iterator station_iterator;
  typedef station_sequence::const_iterator station_const_iterator;
  typedef ::xsd::cxx::tree::traits< station_type, char > station_traits;

  const station_sequence&
  station () const;

  station_sequence&
  station ();

  void
  station (const station_sequence& s);

  // Constructors.
  //
  OpenDRIVE (const header_type&);

  OpenDRIVE (::std::unique_ptr< header_type >);

  OpenDRIVE (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  OpenDRIVE (const OpenDRIVE& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual OpenDRIVE*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OpenDRIVE&
  operator= (const OpenDRIVE& x);

  virtual 
  ~OpenDRIVE ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< header_type > header_;
  road_sequence road_;
  controller_sequence controller_;
  junction_sequence junction_;
  junctionGroup_sequence junctionGroup_;
  station_sequence station_;
};

class max_member: public ::xml_schema::string
{
  public:
  enum value
  {
    no_limit,
    undefined
  };

  max_member (value v);

  max_member (const char* v);

  max_member (const ::std::string& v);

  max_member (const ::xml_schema::string& v);

  max_member (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  max_member (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  max_member (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  max_member (const max_member& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual max_member*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  max_member&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_max_member_convert ();
  }

  protected:
  value
  _xsd_max_member_convert () const;

  public:
  static const char* const _xsd_max_member_literals_[2];
  static const value _xsd_max_member_indexes_[2];
};

class max_member1: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  // Constructors.
  //
  max_member1 (const ::xml_schema::integer&);

  max_member1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  max_member1 (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  max_member1 (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  max_member1 (const max_member1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual max_member1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~max_member1 ();
};

class marking: public ::xml_schema::type
{
  public:
  // side
  //
  typedef ::parkingSpacemarkingSide side_type;
  typedef ::xsd::cxx::tree::optional< side_type > side_optional;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_optional&
  side () const;

  side_optional&
  side ();

  void
  side (const side_type& x);

  void
  side (const side_optional& x);

  void
  side (::std::unique_ptr< side_type > p);

  // type
  //
  typedef ::roadmarkType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // color
  //
  typedef ::color color_type;
  typedef ::xsd::cxx::tree::optional< color_type > color_optional;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_optional&
  color () const;

  color_optional&
  color ();

  void
  color (const color_type& x);

  void
  color (const color_optional& x);

  void
  color (::std::unique_ptr< color_type > p);

  // Constructors.
  //
  marking ();

  marking (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  marking (const marking& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual marking*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  marking&
  operator= (const marking& x);

  virtual 
  ~marking ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  side_optional side_;
  type_optional type_;
  width_optional width_;
  color_optional color_;
};

class lane_link: public ::xml_schema::type
{
  public:
  // predecessor
  //
  typedef ::predecessor predecessor_type;
  typedef ::xsd::cxx::tree::optional< predecessor_type > predecessor_optional;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_optional&
  predecessor () const;

  predecessor_optional&
  predecessor ();

  void
  predecessor (const predecessor_type& x);

  void
  predecessor (const predecessor_optional& x);

  void
  predecessor (::std::unique_ptr< predecessor_type > p);

  // successor
  //
  typedef ::successor successor_type;
  typedef ::xsd::cxx::tree::optional< successor_type > successor_optional;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_optional&
  successor () const;

  successor_optional&
  successor ();

  void
  successor (const successor_type& x);

  void
  successor (const successor_optional& x);

  void
  successor (::std::unique_ptr< successor_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  lane_link ();

  lane_link (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  lane_link (const lane_link& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual lane_link*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  lane_link&
  operator= (const lane_link& x);

  virtual 
  ~lane_link ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  predecessor_optional predecessor_;
  successor_optional successor_;
  userData_sequence userData_;
  include_sequence include_;
};

class width: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  width ();

  width (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  width (const width& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual width*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  width&
  operator= (const width& x);

  virtual 
  ~width ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class border: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  border ();

  border (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  border (const border& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual border*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  border&
  operator= (const border& x);

  virtual 
  ~border ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class roadMark: public ::xml_schema::type
{
  public:
  // type
  //
  typedef ::type type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // type
  //
  typedef ::roadmarkType type1_type;
  typedef ::xsd::cxx::tree::optional< type1_type > type1_optional;
  typedef ::xsd::cxx::tree::traits< type1_type, char > type1_traits;

  const type1_optional&
  type1 () const;

  type1_optional&
  type1 ();

  void
  type1 (const type1_type& x);

  void
  type1 (const type1_optional& x);

  void
  type1 (::std::unique_ptr< type1_type > p);

  // weight
  //
  typedef ::weight weight_type;
  typedef ::xsd::cxx::tree::optional< weight_type > weight_optional;
  typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

  const weight_optional&
  weight () const;

  weight_optional&
  weight ();

  void
  weight (const weight_type& x);

  void
  weight (const weight_optional& x);

  void
  weight (::std::unique_ptr< weight_type > p);

  // color
  //
  typedef ::color color_type;
  typedef ::xsd::cxx::tree::optional< color_type > color_optional;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_optional&
  color () const;

  color_optional&
  color ();

  void
  color (const color_type& x);

  void
  color (const color_optional& x);

  void
  color (::std::unique_ptr< color_type > p);

  // material
  //
  typedef ::xml_schema::string material_type;
  typedef ::xsd::cxx::tree::optional< material_type > material_optional;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_optional&
  material () const;

  material_optional&
  material ();

  void
  material (const material_type& x);

  void
  material (const material_optional& x);

  void
  material (::std::unique_ptr< material_type > p);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // laneChange
  //
  typedef ::laneChange laneChange_type;
  typedef ::xsd::cxx::tree::optional< laneChange_type > laneChange_optional;
  typedef ::xsd::cxx::tree::traits< laneChange_type, char > laneChange_traits;

  const laneChange_optional&
  laneChange () const;

  laneChange_optional&
  laneChange ();

  void
  laneChange (const laneChange_type& x);

  void
  laneChange (const laneChange_optional& x);

  void
  laneChange (::std::unique_ptr< laneChange_type > p);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // Constructors.
  //
  roadMark ();

  roadMark (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  roadMark (const roadMark& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual roadMark*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  roadMark&
  operator= (const roadMark& x);

  virtual 
  ~roadMark ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  type_optional type_;
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  type1_optional type1_;
  weight_optional weight_;
  color_optional color_;
  material_optional material_;
  width_optional width_;
  laneChange_optional laneChange_;
  height_optional height_;
};

class material: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // surface
  //
  typedef ::xml_schema::string surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::unique_ptr< surface_type > p);

  // friction
  //
  typedef ::xml_schema::double_ friction_type;
  typedef ::xsd::cxx::tree::optional< friction_type > friction_optional;
  typedef ::xsd::cxx::tree::traits< friction_type, char, ::xsd::cxx::tree::schema_type::double_ > friction_traits;

  const friction_optional&
  friction () const;

  friction_optional&
  friction ();

  void
  friction (const friction_type& x);

  void
  friction (const friction_optional& x);

  // roughness
  //
  typedef ::xml_schema::double_ roughness_type;
  typedef ::xsd::cxx::tree::optional< roughness_type > roughness_optional;
  typedef ::xsd::cxx::tree::traits< roughness_type, char, ::xsd::cxx::tree::schema_type::double_ > roughness_traits;

  const roughness_optional&
  roughness () const;

  roughness_optional&
  roughness ();

  void
  roughness (const roughness_type& x);

  void
  roughness (const roughness_optional& x);

  // Constructors.
  //
  material ();

  material (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  material (const material& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual material*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  material&
  operator= (const material& x);

  virtual 
  ~material ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  surface_optional surface_;
  friction_optional friction_;
  roughness_optional roughness_;
};

class visibility: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // forward
  //
  typedef ::xml_schema::double_ forward_type;
  typedef ::xsd::cxx::tree::optional< forward_type > forward_optional;
  typedef ::xsd::cxx::tree::traits< forward_type, char, ::xsd::cxx::tree::schema_type::double_ > forward_traits;

  const forward_optional&
  forward () const;

  forward_optional&
  forward ();

  void
  forward (const forward_type& x);

  void
  forward (const forward_optional& x);

  // back
  //
  typedef ::xml_schema::double_ back_type;
  typedef ::xsd::cxx::tree::optional< back_type > back_optional;
  typedef ::xsd::cxx::tree::traits< back_type, char, ::xsd::cxx::tree::schema_type::double_ > back_traits;

  const back_optional&
  back () const;

  back_optional&
  back ();

  void
  back (const back_type& x);

  void
  back (const back_optional& x);

  // left
  //
  typedef ::xml_schema::double_ left_type;
  typedef ::xsd::cxx::tree::optional< left_type > left_optional;
  typedef ::xsd::cxx::tree::traits< left_type, char, ::xsd::cxx::tree::schema_type::double_ > left_traits;

  const left_optional&
  left () const;

  left_optional&
  left ();

  void
  left (const left_type& x);

  void
  left (const left_optional& x);

  // right
  //
  typedef ::xml_schema::double_ right_type;
  typedef ::xsd::cxx::tree::optional< right_type > right_optional;
  typedef ::xsd::cxx::tree::traits< right_type, char, ::xsd::cxx::tree::schema_type::double_ > right_traits;

  const right_optional&
  right () const;

  right_optional&
  right ();

  void
  right (const right_type& x);

  void
  right (const right_optional& x);

  // Constructors.
  //
  visibility ();

  visibility (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  visibility (const visibility& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual visibility*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  visibility&
  operator= (const visibility& x);

  virtual 
  ~visibility ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  forward_optional forward_;
  back_optional back_;
  left_optional left_;
  right_optional right_;
};

class speed: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // max
  //
  typedef ::xml_schema::double_ max_type;
  typedef ::xsd::cxx::tree::optional< max_type > max_optional;
  typedef ::xsd::cxx::tree::traits< max_type, char, ::xsd::cxx::tree::schema_type::double_ > max_traits;

  const max_optional&
  t_max () const;

  max_optional&
  t_max ();

  void
  t_max (const max_type& x);

  void
  t_max (const max_optional& x);

  // unit
  //
  typedef ::unit unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::unique_ptr< unit_type > p);

  // Constructors.
  //
  speed ();

  speed (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  speed (const speed& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual speed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  speed&
  operator= (const speed& x);

  virtual 
  ~speed ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  max_optional t_max_;
  unit_optional unit_;
};

class access1: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // restriction
  //
  typedef ::restriction restriction_type;
  typedef ::xsd::cxx::tree::optional< restriction_type > restriction_optional;
  typedef ::xsd::cxx::tree::traits< restriction_type, char > restriction_traits;

  const restriction_optional&
  restriction () const;

  restriction_optional&
  restriction ();

  void
  restriction (const restriction_type& x);

  void
  restriction (const restriction_optional& x);

  void
  restriction (::std::unique_ptr< restriction_type > p);

  // Constructors.
  //
  access1 ();

  access1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  access1 (const access1& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual access1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  access1&
  operator= (const access1& x);

  virtual 
  ~access1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  restriction_optional restriction_;
};

class height: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // inner
  //
  typedef ::xml_schema::double_ inner_type;
  typedef ::xsd::cxx::tree::optional< inner_type > inner_optional;
  typedef ::xsd::cxx::tree::traits< inner_type, char, ::xsd::cxx::tree::schema_type::double_ > inner_traits;

  const inner_optional&
  inner () const;

  inner_optional&
  inner ();

  void
  inner (const inner_type& x);

  void
  inner (const inner_optional& x);

  // outer
  //
  typedef ::xml_schema::double_ outer_type;
  typedef ::xsd::cxx::tree::optional< outer_type > outer_optional;
  typedef ::xsd::cxx::tree::traits< outer_type, char, ::xsd::cxx::tree::schema_type::double_ > outer_traits;

  const outer_optional&
  outer () const;

  outer_optional&
  outer ();

  void
  outer (const outer_type& x);

  void
  outer (const outer_optional& x);

  // Constructors.
  //
  height ();

  height (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  height (const height& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual height*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  height&
  operator= (const height& x);

  virtual 
  ~height ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  inner_optional inner_;
  outer_optional outer_;
};

class rule1: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  void
  value (::std::unique_ptr< value_type > p);

  // Constructors.
  //
  rule1 ();

  rule1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  rule1 (const rule1& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual rule1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  rule1&
  operator= (const rule1& x);

  virtual 
  ~rule1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  value_optional value_;
};

class link1: public ::xml_schema::type
{
  public:
  // predecessor
  //
  typedef ::predecessor predecessor_type;
  typedef ::xsd::cxx::tree::optional< predecessor_type > predecessor_optional;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_optional&
  predecessor () const;

  predecessor_optional&
  predecessor ();

  void
  predecessor (const predecessor_type& x);

  void
  predecessor (const predecessor_optional& x);

  void
  predecessor (::std::unique_ptr< predecessor_type > p);

  // successor
  //
  typedef ::successor successor_type;
  typedef ::xsd::cxx::tree::optional< successor_type > successor_optional;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_optional&
  successor () const;

  successor_optional&
  successor ();

  void
  successor (const successor_type& x);

  void
  successor (const successor_optional& x);

  void
  successor (::std::unique_ptr< successor_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  link1 ();

  link1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  link1 (const link1& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual link1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  link1&
  operator= (const link1& x);

  virtual 
  ~link1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  predecessor_optional predecessor_;
  successor_optional successor_;
  userData_sequence userData_;
  include_sequence include_;
};

class roadMark1: public ::xml_schema::type
{
  public:
  // type
  //
  typedef ::type1 type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // type
  //
  typedef ::roadmarkType type1_type;
  typedef ::xsd::cxx::tree::optional< type1_type > type1_optional;
  typedef ::xsd::cxx::tree::traits< type1_type, char > type1_traits;

  const type1_optional&
  type1 () const;

  type1_optional&
  type1 ();

  void
  type1 (const type1_type& x);

  void
  type1 (const type1_optional& x);

  void
  type1 (::std::unique_ptr< type1_type > p);

  // weight
  //
  typedef ::weight weight_type;
  typedef ::xsd::cxx::tree::optional< weight_type > weight_optional;
  typedef ::xsd::cxx::tree::traits< weight_type, char > weight_traits;

  const weight_optional&
  weight () const;

  weight_optional&
  weight ();

  void
  weight (const weight_type& x);

  void
  weight (const weight_optional& x);

  void
  weight (::std::unique_ptr< weight_type > p);

  // color
  //
  typedef ::color color_type;
  typedef ::xsd::cxx::tree::optional< color_type > color_optional;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_optional&
  color () const;

  color_optional&
  color ();

  void
  color (const color_type& x);

  void
  color (const color_optional& x);

  void
  color (::std::unique_ptr< color_type > p);

  // material
  //
  typedef ::xml_schema::string material_type;
  typedef ::xsd::cxx::tree::optional< material_type > material_optional;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_optional&
  material () const;

  material_optional&
  material ();

  void
  material (const material_type& x);

  void
  material (const material_optional& x);

  void
  material (::std::unique_ptr< material_type > p);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // laneChange
  //
  typedef ::laneChange laneChange_type;
  typedef ::xsd::cxx::tree::optional< laneChange_type > laneChange_optional;
  typedef ::xsd::cxx::tree::traits< laneChange_type, char > laneChange_traits;

  const laneChange_optional&
  laneChange () const;

  laneChange_optional&
  laneChange ();

  void
  laneChange (const laneChange_type& x);

  void
  laneChange (const laneChange_optional& x);

  void
  laneChange (::std::unique_ptr< laneChange_type > p);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // Constructors.
  //
  roadMark1 ();

  roadMark1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  roadMark1 (const roadMark1& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual roadMark1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  roadMark1&
  operator= (const roadMark1& x);

  virtual 
  ~roadMark1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  type_optional type_;
  userData_sequence userData_;
  include_sequence include_;
  sOffset_optional sOffset_;
  type1_optional type1_;
  weight_optional weight_;
  color_optional color_;
  material_optional material_;
  width_optional width_;
  laneChange_optional laneChange_;
  height_optional height_;
};

class header: public ::xml_schema::type
{
  public:
  // geoReference
  //
  typedef ::xml_schema::string geoReference_type;
  typedef ::xsd::cxx::tree::optional< geoReference_type > geoReference_optional;
  typedef ::xsd::cxx::tree::traits< geoReference_type, char > geoReference_traits;

  const geoReference_optional&
  geoReference () const;

  geoReference_optional&
  geoReference ();

  void
  geoReference (const geoReference_type& x);

  void
  geoReference (const geoReference_optional& x);

  void
  geoReference (::std::unique_ptr< geoReference_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // revMajor
  //
  typedef ::xml_schema::unsigned_short revMajor_type;
  typedef ::xsd::cxx::tree::optional< revMajor_type > revMajor_optional;
  typedef ::xsd::cxx::tree::traits< revMajor_type, char > revMajor_traits;

  const revMajor_optional&
  revMajor () const;

  revMajor_optional&
  revMajor ();

  void
  revMajor (const revMajor_type& x);

  void
  revMajor (const revMajor_optional& x);

  // revMinor
  //
  typedef ::xml_schema::unsigned_short revMinor_type;
  typedef ::xsd::cxx::tree::optional< revMinor_type > revMinor_optional;
  typedef ::xsd::cxx::tree::traits< revMinor_type, char > revMinor_traits;

  const revMinor_optional&
  revMinor () const;

  revMinor_optional&
  revMinor ();

  void
  revMinor (const revMinor_type& x);

  void
  revMinor (const revMinor_optional& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // version
  //
  typedef ::xml_schema::float_ version_type;
  typedef ::xsd::cxx::tree::optional< version_type > version_optional;
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  const version_optional&
  version () const;

  version_optional&
  version ();

  void
  version (const version_type& x);

  void
  version (const version_optional& x);

  // date
  //
  typedef ::xml_schema::string date_type;
  typedef ::xsd::cxx::tree::optional< date_type > date_optional;
  typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

  const date_optional&
  date () const;

  date_optional&
  date ();

  void
  date (const date_type& x);

  void
  date (const date_optional& x);

  void
  date (::std::unique_ptr< date_type > p);

  // north
  //
  typedef ::xml_schema::double_ north_type;
  typedef ::xsd::cxx::tree::optional< north_type > north_optional;
  typedef ::xsd::cxx::tree::traits< north_type, char, ::xsd::cxx::tree::schema_type::double_ > north_traits;

  const north_optional&
  north () const;

  north_optional&
  north ();

  void
  north (const north_type& x);

  void
  north (const north_optional& x);

  // south
  //
  typedef ::xml_schema::double_ south_type;
  typedef ::xsd::cxx::tree::optional< south_type > south_optional;
  typedef ::xsd::cxx::tree::traits< south_type, char, ::xsd::cxx::tree::schema_type::double_ > south_traits;

  const south_optional&
  south () const;

  south_optional&
  south ();

  void
  south (const south_type& x);

  void
  south (const south_optional& x);

  // east
  //
  typedef ::xml_schema::double_ east_type;
  typedef ::xsd::cxx::tree::optional< east_type > east_optional;
  typedef ::xsd::cxx::tree::traits< east_type, char, ::xsd::cxx::tree::schema_type::double_ > east_traits;

  const east_optional&
  east () const;

  east_optional&
  east ();

  void
  east (const east_type& x);

  void
  east (const east_optional& x);

  // west
  //
  typedef ::xml_schema::double_ west_type;
  typedef ::xsd::cxx::tree::optional< west_type > west_optional;
  typedef ::xsd::cxx::tree::traits< west_type, char, ::xsd::cxx::tree::schema_type::double_ > west_traits;

  const west_optional&
  west () const;

  west_optional&
  west ();

  void
  west (const west_type& x);

  void
  west (const west_optional& x);

  // vendor
  //
  typedef ::xml_schema::string vendor_type;
  typedef ::xsd::cxx::tree::optional< vendor_type > vendor_optional;
  typedef ::xsd::cxx::tree::traits< vendor_type, char > vendor_traits;

  const vendor_optional&
  vendor () const;

  vendor_optional&
  vendor ();

  void
  vendor (const vendor_type& x);

  void
  vendor (const vendor_optional& x);

  void
  vendor (::std::unique_ptr< vendor_type > p);

  // Constructors.
  //
  header ();

  header (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  header (const header& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual header*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  header&
  operator= (const header& x);

  virtual 
  ~header ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geoReference_optional geoReference_;
  userData_sequence userData_;
  include_sequence include_;
  revMajor_optional revMajor_;
  revMinor_optional revMinor_;
  name_optional name_;
  version_optional version_;
  date_optional date_;
  north_optional north_;
  south_optional south_;
  east_optional east_;
  west_optional west_;
  vendor_optional vendor_;
};

class road: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::link2 link_type;
  typedef ::xsd::cxx::tree::optional< link_type > link_optional;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_optional&
  lane_link () const;

  link_optional&
  lane_link ();

  void
  lane_link (const link_type& x);

  void
  lane_link (const link_optional& x);

  void
  lane_link (::std::unique_ptr< link_type > p);

  // type
  //
  typedef ::type2 type_type;
  typedef ::xsd::cxx::tree::sequence< type_type > type_sequence;
  typedef type_sequence::iterator type_iterator;
  typedef type_sequence::const_iterator type_const_iterator;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_sequence&
  type () const;

  type_sequence&
  type ();

  void
  type (const type_sequence& s);

  // planView
  //
  typedef ::planView planView_type;
  typedef ::xsd::cxx::tree::traits< planView_type, char > planView_traits;

  const planView_type&
  planView () const;

  planView_type&
  planView ();

  void
  planView (const planView_type& x);

  void
  planView (::std::unique_ptr< planView_type > p);

  // elevationProfile
  //
  typedef ::elevationProfile elevationProfile_type;
  typedef ::xsd::cxx::tree::optional< elevationProfile_type > elevationProfile_optional;
  typedef ::xsd::cxx::tree::traits< elevationProfile_type, char > elevationProfile_traits;

  const elevationProfile_optional&
  elevationProfile () const;

  elevationProfile_optional&
  elevationProfile ();

  void
  elevationProfile (const elevationProfile_type& x);

  void
  elevationProfile (const elevationProfile_optional& x);

  void
  elevationProfile (::std::unique_ptr< elevationProfile_type > p);

  // lateralProfile
  //
  typedef ::lateralProfile lateralProfile_type;
  typedef ::xsd::cxx::tree::optional< lateralProfile_type > lateralProfile_optional;
  typedef ::xsd::cxx::tree::traits< lateralProfile_type, char > lateralProfile_traits;

  const lateralProfile_optional&
  lateralProfile () const;

  lateralProfile_optional&
  lateralProfile ();

  void
  lateralProfile (const lateralProfile_type& x);

  void
  lateralProfile (const lateralProfile_optional& x);

  void
  lateralProfile (::std::unique_ptr< lateralProfile_type > p);

  // lanes
  //
  typedef ::lanes lanes_type;
  typedef ::xsd::cxx::tree::traits< lanes_type, char > lanes_traits;

  const lanes_type&
  lanes () const;

  lanes_type&
  lanes ();

  void
  lanes (const lanes_type& x);

  void
  lanes (::std::unique_ptr< lanes_type > p);

  // objects
  //
  typedef ::objects objects_type;
  typedef ::xsd::cxx::tree::optional< objects_type > objects_optional;
  typedef ::xsd::cxx::tree::traits< objects_type, char > objects_traits;

  const objects_optional&
  objects () const;

  objects_optional&
  objects ();

  void
  objects (const objects_type& x);

  void
  objects (const objects_optional& x);

  void
  objects (::std::unique_ptr< objects_type > p);

  // signals
  //
  typedef ::signals signals_type;
  typedef ::xsd::cxx::tree::optional< signals_type > signals_optional;
  typedef ::xsd::cxx::tree::traits< signals_type, char > signals_traits;

  const signals_optional&
  signals () const;

  signals_optional&
  signals ();

  void
  signals (const signals_type& x);

  void
  signals (const signals_optional& x);

  void
  signals (::std::unique_ptr< signals_type > p);

  // surface
  //
  typedef ::surface surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::unique_ptr< surface_type > p);

  // railroad
  //
  typedef ::railroad railroad_type;
  typedef ::xsd::cxx::tree::optional< railroad_type > railroad_optional;
  typedef ::xsd::cxx::tree::traits< railroad_type, char > railroad_traits;

  const railroad_optional&
  railroad () const;

  railroad_optional&
  railroad ();

  void
  railroad (const railroad_type& x);

  void
  railroad (const railroad_optional& x);

  void
  railroad (::std::unique_ptr< railroad_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // junction
  //
  typedef ::xml_schema::string junction_type;
  typedef ::xsd::cxx::tree::optional< junction_type > junction_optional;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_optional&
  junction () const;

  junction_optional&
  junction ();

  void
  junction (const junction_type& x);

  void
  junction (const junction_optional& x);

  void
  junction (::std::unique_ptr< junction_type > p);

  // Constructors.
  //
  road (const planView_type&,
        const lanes_type&);

  road (::std::unique_ptr< planView_type >,
        ::std::unique_ptr< lanes_type >);

  road (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  road (const road& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual road*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  road&
  operator= (const road& x);

  virtual 
  ~road ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  link_optional lane_link_;
  type_sequence type_;
  ::xsd::cxx::tree::one< planView_type > planView_;
  elevationProfile_optional elevationProfile_;
  lateralProfile_optional lateralProfile_;
  ::xsd::cxx::tree::one< lanes_type > lanes_;
  objects_optional objects_;
  signals_optional signals_;
  surface_optional surface_;
  railroad_optional railroad_;
  userData_sequence userData_;
  include_sequence include_;
  name_optional name_;
  length_optional length_;
  id_optional id_;
  junction_optional junction_;
};

class controller: public ::xml_schema::type
{
  public:
  // control
  //
  typedef ::control control_type;
  typedef ::xsd::cxx::tree::sequence< control_type > control_sequence;
  typedef control_sequence::iterator control_iterator;
  typedef control_sequence::const_iterator control_const_iterator;
  typedef ::xsd::cxx::tree::traits< control_type, char > control_traits;

  const control_sequence&
  control () const;

  control_sequence&
  control ();

  void
  control (const control_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // sequence
  //
  typedef ::xml_schema::int_ sequence_type;
  typedef ::xsd::cxx::tree::optional< sequence_type > sequence_optional;
  typedef ::xsd::cxx::tree::traits< sequence_type, char > sequence_traits;

  const sequence_optional&
  sequence () const;

  sequence_optional&
  sequence ();

  void
  sequence (const sequence_type& x);

  void
  sequence (const sequence_optional& x);

  // Constructors.
  //
  controller ();

  controller (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  controller (const controller& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual controller*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  controller&
  operator= (const controller& x);

  virtual 
  ~controller ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  control_sequence control_;
  userData_sequence userData_;
  include_sequence include_;
  id_optional id_;
  name_optional name_;
  sequence_optional sequence_;
};

class junction: public ::xml_schema::type
{
  public:
  // connection
  //
  typedef ::connection connection_type;
  typedef ::xsd::cxx::tree::sequence< connection_type > connection_sequence;
  typedef connection_sequence::iterator connection_iterator;
  typedef connection_sequence::const_iterator connection_const_iterator;
  typedef ::xsd::cxx::tree::traits< connection_type, char > connection_traits;

  const connection_sequence&
  connection () const;

  connection_sequence&
  connection ();

  void
  connection (const connection_sequence& s);

  // priority
  //
  typedef ::priority priority_type;
  typedef ::xsd::cxx::tree::sequence< priority_type > priority_sequence;
  typedef priority_sequence::iterator priority_iterator;
  typedef priority_sequence::const_iterator priority_const_iterator;
  typedef ::xsd::cxx::tree::traits< priority_type, char > priority_traits;

  const priority_sequence&
  priority () const;

  priority_sequence&
  priority ();

  void
  priority (const priority_sequence& s);

  // controller
  //
  typedef ::controller1 controller_type;
  typedef ::xsd::cxx::tree::sequence< controller_type > controller_sequence;
  typedef controller_sequence::iterator controller_iterator;
  typedef controller_sequence::const_iterator controller_const_iterator;
  typedef ::xsd::cxx::tree::traits< controller_type, char > controller_traits;

  const controller_sequence&
  controller () const;

  controller_sequence&
  controller ();

  void
  controller (const controller_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // Constructors.
  //
  junction ();

  junction (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  junction (const junction& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual junction*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  junction&
  operator= (const junction& x);

  virtual 
  ~junction ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  connection_sequence connection_;
  priority_sequence priority_;
  controller_sequence controller_;
  userData_sequence userData_;
  include_sequence include_;
  name_optional name_;
  id_optional id_;
};

class junctionGroup: public ::xml_schema::type
{
  public:
  // junctionReference
  //
  typedef ::junctionReference junctionReference_type;
  typedef ::xsd::cxx::tree::sequence< junctionReference_type > junctionReference_sequence;
  typedef junctionReference_sequence::iterator junctionReference_iterator;
  typedef junctionReference_sequence::const_iterator junctionReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< junctionReference_type, char > junctionReference_traits;

  const junctionReference_sequence&
  junctionReference () const;

  junctionReference_sequence&
  junctionReference ();

  void
  junctionReference (const junctionReference_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::junctionGroupType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  junctionGroup ();

  junctionGroup (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  junctionGroup (const junctionGroup& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual junctionGroup*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  junctionGroup&
  operator= (const junctionGroup& x);

  virtual 
  ~junctionGroup ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  junctionReference_sequence junctionReference_;
  userData_sequence userData_;
  include_sequence include_;
  name_optional name_;
  id_optional id_;
  type_optional type_;
};

class station: public ::xml_schema::type
{
  public:
  // platform
  //
  typedef ::platform platform_type;
  typedef ::xsd::cxx::tree::sequence< platform_type > platform_sequence;
  typedef platform_sequence::iterator platform_iterator;
  typedef platform_sequence::const_iterator platform_const_iterator;
  typedef ::xsd::cxx::tree::traits< platform_type, char > platform_traits;

  const platform_sequence&
  platform () const;

  platform_sequence&
  platform ();

  void
  platform (const platform_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::stationType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  station ();

  station (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  station (const station& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual station*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  station&
  operator= (const station& x);

  virtual 
  ~station ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  platform_sequence platform_;
  userData_sequence userData_;
  include_sequence include_;
  name_optional name_;
  id_optional id_;
  type_optional type_;
};

class predecessor: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // Constructors.
  //
  predecessor ();

  predecessor (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  predecessor (const predecessor& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual predecessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  predecessor&
  operator= (const predecessor& x);

  virtual 
  ~predecessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
};

class successor: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // Constructors.
  //
  successor ();

  successor (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  successor (const successor& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual successor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  successor&
  operator= (const successor& x);

  virtual 
  ~successor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
};

class type: public ::xml_schema::type
{
  public:
  // line
  //
  typedef ::line line_type;
  typedef ::xsd::cxx::tree::sequence< line_type > line_sequence;
  typedef line_sequence::iterator line_iterator;
  typedef line_sequence::const_iterator line_const_iterator;
  typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

  const line_sequence&
  line () const;

  line_sequence&
  line ();

  void
  line (const line_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // Constructors.
  //
  type ();

  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  type (const type& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  type&
  operator= (const type& x);

  virtual 
  ~type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  line_sequence line_;
  name_optional name_;
  width_optional width_;
};

class type1: public ::xml_schema::type
{
  public:
  // line
  //
  typedef ::line line_type;
  typedef ::xsd::cxx::tree::sequence< line_type > line_sequence;
  typedef line_sequence::iterator line_iterator;
  typedef line_sequence::const_iterator line_const_iterator;
  typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

  const line_sequence&
  line () const;

  line_sequence&
  line ();

  void
  line (const line_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // Constructors.
  //
  type1 ();

  type1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  type1 (const type1& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual type1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  type1&
  operator= (const type1& x);

  virtual 
  ~type1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  line_sequence line_;
  name_optional name_;
  width_optional width_;
};

class link2: public ::xml_schema::type
{
  public:
  // predecessor
  //
  typedef ::predecessor1 predecessor_type;
  typedef ::xsd::cxx::tree::optional< predecessor_type > predecessor_optional;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_optional&
  predecessor () const;

  predecessor_optional&
  predecessor ();

  void
  predecessor (const predecessor_type& x);

  void
  predecessor (const predecessor_optional& x);

  void
  predecessor (::std::unique_ptr< predecessor_type > p);

  // successor
  //
  typedef ::successor1 successor_type;
  typedef ::xsd::cxx::tree::optional< successor_type > successor_optional;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_optional&
  successor () const;

  successor_optional&
  successor ();

  void
  successor (const successor_type& x);

  void
  successor (const successor_optional& x);

  void
  successor (::std::unique_ptr< successor_type > p);

  // neighbor
  //
  typedef ::neighbor neighbor_type;
  typedef ::xsd::cxx::tree::sequence< neighbor_type > neighbor_sequence;
  typedef neighbor_sequence::iterator neighbor_iterator;
  typedef neighbor_sequence::const_iterator neighbor_const_iterator;
  typedef ::xsd::cxx::tree::traits< neighbor_type, char > neighbor_traits;

  const neighbor_sequence&
  neighbor () const;

  neighbor_sequence&
  neighbor ();

  void
  neighbor (const neighbor_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  link2 ();

  link2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  link2 (const link2& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual link2*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  link2&
  operator= (const link2& x);

  virtual 
  ~link2 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  predecessor_optional predecessor_;
  successor_optional successor_;
  neighbor_sequence neighbor_;
  userData_sequence userData_;
  include_sequence include_;
};

class type2: public ::xml_schema::type
{
  public:
  // speed
  //
  typedef ::speed1 speed_type;
  typedef ::xsd::cxx::tree::optional< speed_type > speed_optional;
  typedef ::xsd::cxx::tree::traits< speed_type, char > speed_traits;

  const speed_optional&
  speed () const;

  speed_optional&
  speed ();

  void
  speed (const speed_type& x);

  void
  speed (const speed_optional& x);

  void
  speed (::std::unique_ptr< speed_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // type
  //
  typedef ::roadType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  type2 ();

  type2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  type2 (const type2& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual type2*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  type2&
  operator= (const type2& x);

  virtual 
  ~type2 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  speed_optional speed_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  type_optional type_;
};

class planView: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::sequence< geometry_type > geometry_sequence;
  typedef geometry_sequence::iterator geometry_iterator;
  typedef geometry_sequence::const_iterator geometry_const_iterator;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_sequence&
  geometry () const;

  geometry_sequence&
  geometry ();

  void
  geometry (const geometry_sequence& s);

  // Constructors.
  //
  planView ();

  planView (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  planView (const planView& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual planView*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  planView&
  operator= (const planView& x);

  virtual 
  ~planView ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geometry_sequence geometry_;
};

class elevationProfile: public ::xml_schema::type
{
  public:
  // elevation
  //
  typedef ::elevation elevation_type;
  typedef ::xsd::cxx::tree::sequence< elevation_type > elevation_sequence;
  typedef elevation_sequence::iterator elevation_iterator;
  typedef elevation_sequence::const_iterator elevation_const_iterator;
  typedef ::xsd::cxx::tree::traits< elevation_type, char > elevation_traits;

  const elevation_sequence&
  elevation () const;

  elevation_sequence&
  elevation ();

  void
  elevation (const elevation_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  elevationProfile ();

  elevationProfile (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  elevationProfile (const elevationProfile& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual elevationProfile*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  elevationProfile&
  operator= (const elevationProfile& x);

  virtual 
  ~elevationProfile ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  elevation_sequence elevation_;
  userData_sequence userData_;
  include_sequence include_;
};

class lateralProfile: public ::xml_schema::type
{
  public:
  // superelevation
  //
  typedef ::superelevation superelevation_type;
  typedef ::xsd::cxx::tree::sequence< superelevation_type > superelevation_sequence;
  typedef superelevation_sequence::iterator superelevation_iterator;
  typedef superelevation_sequence::const_iterator superelevation_const_iterator;
  typedef ::xsd::cxx::tree::traits< superelevation_type, char > superelevation_traits;

  const superelevation_sequence&
  superelevation () const;

  superelevation_sequence&
  superelevation ();

  void
  superelevation (const superelevation_sequence& s);

  // crossfall
  //
  typedef ::crossfall crossfall_type;
  typedef ::xsd::cxx::tree::sequence< crossfall_type > crossfall_sequence;
  typedef crossfall_sequence::iterator crossfall_iterator;
  typedef crossfall_sequence::const_iterator crossfall_const_iterator;
  typedef ::xsd::cxx::tree::traits< crossfall_type, char > crossfall_traits;

  const crossfall_sequence&
  crossfall () const;

  crossfall_sequence&
  crossfall ();

  void
  crossfall (const crossfall_sequence& s);

  // shape
  //
  typedef ::shape shape_type;
  typedef ::xsd::cxx::tree::sequence< shape_type > shape_sequence;
  typedef shape_sequence::iterator shape_iterator;
  typedef shape_sequence::const_iterator shape_const_iterator;
  typedef ::xsd::cxx::tree::traits< shape_type, char > shape_traits;

  const shape_sequence&
  shape () const;

  shape_sequence&
  shape ();

  void
  shape (const shape_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  lateralProfile ();

  lateralProfile (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  lateralProfile (const lateralProfile& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual lateralProfile*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  lateralProfile&
  operator= (const lateralProfile& x);

  virtual 
  ~lateralProfile ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  superelevation_sequence superelevation_;
  crossfall_sequence crossfall_;
  shape_sequence shape_;
  userData_sequence userData_;
  include_sequence include_;
};

class lanes: public ::xml_schema::type
{
  public:
  // laneOffset
  //
  typedef ::laneOffset laneOffset_type;
  typedef ::xsd::cxx::tree::sequence< laneOffset_type > laneOffset_sequence;
  typedef laneOffset_sequence::iterator laneOffset_iterator;
  typedef laneOffset_sequence::const_iterator laneOffset_const_iterator;
  typedef ::xsd::cxx::tree::traits< laneOffset_type, char > laneOffset_traits;

  const laneOffset_sequence&
  laneOffset () const;

  laneOffset_sequence&
  laneOffset ();

  void
  laneOffset (const laneOffset_sequence& s);

  // laneSection
  //
  typedef ::laneSection laneSection_type;
  typedef ::xsd::cxx::tree::sequence< laneSection_type > laneSection_sequence;
  typedef laneSection_sequence::iterator laneSection_iterator;
  typedef laneSection_sequence::const_iterator laneSection_const_iterator;
  typedef ::xsd::cxx::tree::traits< laneSection_type, char > laneSection_traits;

  const laneSection_sequence&
  laneSection () const;

  laneSection_sequence&
  laneSection ();

  void
  laneSection (const laneSection_sequence& s);

  // Constructors.
  //
  lanes ();

  lanes (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  lanes (const lanes& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual lanes*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  lanes&
  operator= (const lanes& x);

  virtual 
  ~lanes ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  laneOffset_sequence laneOffset_;
  laneSection_sequence laneSection_;
};

class objects: public ::xml_schema::type
{
  public:
  // object
  //
  typedef ::object object_type;
  typedef ::xsd::cxx::tree::sequence< object_type > object_sequence;
  typedef object_sequence::iterator object_iterator;
  typedef object_sequence::const_iterator object_const_iterator;
  typedef ::xsd::cxx::tree::traits< object_type, char > object_traits;

  const object_sequence&
  object () const;

  object_sequence&
  object ();

  void
  object (const object_sequence& s);

  // objectReference
  //
  typedef ::objectReference objectReference_type;
  typedef ::xsd::cxx::tree::sequence< objectReference_type > objectReference_sequence;
  typedef objectReference_sequence::iterator objectReference_iterator;
  typedef objectReference_sequence::const_iterator objectReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< objectReference_type, char > objectReference_traits;

  const objectReference_sequence&
  objectReference () const;

  objectReference_sequence&
  objectReference ();

  void
  objectReference (const objectReference_sequence& s);

  // tunnel
  //
  typedef ::tunnel tunnel_type;
  typedef ::xsd::cxx::tree::sequence< tunnel_type > tunnel_sequence;
  typedef tunnel_sequence::iterator tunnel_iterator;
  typedef tunnel_sequence::const_iterator tunnel_const_iterator;
  typedef ::xsd::cxx::tree::traits< tunnel_type, char > tunnel_traits;

  const tunnel_sequence&
  tunnel () const;

  tunnel_sequence&
  tunnel ();

  void
  tunnel (const tunnel_sequence& s);

  // bridge
  //
  typedef ::bridge bridge_type;
  typedef ::xsd::cxx::tree::sequence< bridge_type > bridge_sequence;
  typedef bridge_sequence::iterator bridge_iterator;
  typedef bridge_sequence::const_iterator bridge_const_iterator;
  typedef ::xsd::cxx::tree::traits< bridge_type, char > bridge_traits;

  const bridge_sequence&
  bridge () const;

  bridge_sequence&
  bridge ();

  void
  bridge (const bridge_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  objects ();

  objects (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  objects (const objects& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual objects*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  objects&
  operator= (const objects& x);

  virtual 
  ~objects ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  object_sequence object_;
  objectReference_sequence objectReference_;
  tunnel_sequence tunnel_;
  bridge_sequence bridge_;
  userData_sequence userData_;
  include_sequence include_;
};

class signals: public ::xml_schema::type
{
  public:
  // signal
  //
  typedef ::t_signal signal_type;
  typedef ::xsd::cxx::tree::sequence< signal_type > signal_sequence;
  typedef signal_sequence::iterator signal_iterator;
  typedef signal_sequence::const_iterator signal_const_iterator;
  typedef ::xsd::cxx::tree::traits< signal_type, char > signal_traits;

  const signal_sequence&
  t_signal () const;

  signal_sequence&
  t_signal ();

  void
  t_signal (const signal_sequence& s);

  // signalReference
  //
  typedef ::signalReference signalReference_type;
  typedef ::xsd::cxx::tree::sequence< signalReference_type > signalReference_sequence;
  typedef signalReference_sequence::iterator signalReference_iterator;
  typedef signalReference_sequence::const_iterator signalReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< signalReference_type, char > signalReference_traits;

  const signalReference_sequence&
  signalReference () const;

  signalReference_sequence&
  signalReference ();

  void
  signalReference (const signalReference_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  signals ();

  signals (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  signals (const signals& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual signals*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  signals&
  operator= (const signals& x);

  virtual 
  ~signals ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  signal_sequence t_signal_;
  signalReference_sequence signalReference_;
  userData_sequence userData_;
  include_sequence include_;
};

class surface: public ::xml_schema::type
{
  public:
  // CRG
  //
  typedef ::CRG CRG_type;
  typedef ::xsd::cxx::tree::sequence< CRG_type > CRG_sequence;
  typedef CRG_sequence::iterator CRG_iterator;
  typedef CRG_sequence::const_iterator CRG_const_iterator;
  typedef ::xsd::cxx::tree::traits< CRG_type, char > CRG_traits;

  const CRG_sequence&
  CRG () const;

  CRG_sequence&
  CRG ();

  void
  CRG (const CRG_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  surface ();

  surface (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  surface (const surface& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual surface*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  surface&
  operator= (const surface& x);

  virtual 
  ~surface ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  CRG_sequence CRG_;
  userData_sequence userData_;
  include_sequence include_;
};

class railroad: public ::xml_schema::type
{
  public:
  // switch
  //
  typedef ::switch_ switch_type;
  typedef ::xsd::cxx::tree::sequence< switch_type > switch_sequence;
  typedef switch_sequence::iterator switch_iterator;
  typedef switch_sequence::const_iterator switch_const_iterator;
  typedef ::xsd::cxx::tree::traits< switch_type, char > switch_traits;

  const switch_sequence&
  switch_ () const;

  switch_sequence&
  switch_ ();

  void
  switch_ (const switch_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  railroad ();

  railroad (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  railroad (const railroad& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual railroad*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  railroad&
  operator= (const railroad& x);

  virtual 
  ~railroad ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  switch_sequence switch__;
  userData_sequence userData_;
  include_sequence include_;
};

class control: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // signalId
  //
  typedef ::xml_schema::string signalId_type;
  typedef ::xsd::cxx::tree::optional< signalId_type > signalId_optional;
  typedef ::xsd::cxx::tree::traits< signalId_type, char > signalId_traits;

  const signalId_optional&
  signalId () const;

  signalId_optional&
  signalId ();

  void
  signalId (const signalId_type& x);

  void
  signalId (const signalId_optional& x);

  void
  signalId (::std::unique_ptr< signalId_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  control ();

  control (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  control (const control& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual control*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  control&
  operator= (const control& x);

  virtual 
  ~control ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  signalId_optional signalId_;
  type_optional type_;
};

class connection: public ::xml_schema::type
{
  public:
  // laneLink
  //
  typedef ::laneLink laneLink_type;
  typedef ::xsd::cxx::tree::sequence< laneLink_type > laneLink_sequence;
  typedef laneLink_sequence::iterator laneLink_iterator;
  typedef laneLink_sequence::const_iterator laneLink_const_iterator;
  typedef ::xsd::cxx::tree::traits< laneLink_type, char > laneLink_traits;

  const laneLink_sequence&
  laneLink () const;

  laneLink_sequence&
  laneLink ();

  void
  laneLink (const laneLink_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // incomingRoad
  //
  typedef ::xml_schema::string incomingRoad_type;
  typedef ::xsd::cxx::tree::optional< incomingRoad_type > incomingRoad_optional;
  typedef ::xsd::cxx::tree::traits< incomingRoad_type, char > incomingRoad_traits;

  const incomingRoad_optional&
  incomingRoad () const;

  incomingRoad_optional&
  incomingRoad ();

  void
  incomingRoad (const incomingRoad_type& x);

  void
  incomingRoad (const incomingRoad_optional& x);

  void
  incomingRoad (::std::unique_ptr< incomingRoad_type > p);

  // connectingRoad
  //
  typedef ::xml_schema::string connectingRoad_type;
  typedef ::xsd::cxx::tree::optional< connectingRoad_type > connectingRoad_optional;
  typedef ::xsd::cxx::tree::traits< connectingRoad_type, char > connectingRoad_traits;

  const connectingRoad_optional&
  connectingRoad () const;

  connectingRoad_optional&
  connectingRoad ();

  void
  connectingRoad (const connectingRoad_type& x);

  void
  connectingRoad (const connectingRoad_optional& x);

  void
  connectingRoad (::std::unique_ptr< connectingRoad_type > p);

  // contactPoint
  //
  typedef ::contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // Constructors.
  //
  connection ();

  connection (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  connection (const connection& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual connection*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  connection&
  operator= (const connection& x);

  virtual 
  ~connection ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  laneLink_sequence laneLink_;
  userData_sequence userData_;
  include_sequence include_;
  id_optional id_;
  incomingRoad_optional incomingRoad_;
  connectingRoad_optional connectingRoad_;
  contactPoint_optional contactPoint_;
};

class priority: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // high
  //
  typedef ::xml_schema::string high_type;
  typedef ::xsd::cxx::tree::optional< high_type > high_optional;
  typedef ::xsd::cxx::tree::traits< high_type, char > high_traits;

  const high_optional&
  high () const;

  high_optional&
  high ();

  void
  high (const high_type& x);

  void
  high (const high_optional& x);

  void
  high (::std::unique_ptr< high_type > p);

  // low
  //
  typedef ::xml_schema::string low_type;
  typedef ::xsd::cxx::tree::optional< low_type > low_optional;
  typedef ::xsd::cxx::tree::traits< low_type, char > low_traits;

  const low_optional&
  low () const;

  low_optional&
  low ();

  void
  low (const low_type& x);

  void
  low (const low_optional& x);

  void
  low (::std::unique_ptr< low_type > p);

  // Constructors.
  //
  priority ();

  priority (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  priority (const priority& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual priority*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  priority&
  operator= (const priority& x);

  virtual 
  ~priority ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  high_optional high_;
  low_optional low_;
};

class controller1: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // sequence
  //
  typedef ::xml_schema::int_ sequence_type;
  typedef ::xsd::cxx::tree::optional< sequence_type > sequence_optional;
  typedef ::xsd::cxx::tree::traits< sequence_type, char > sequence_traits;

  const sequence_optional&
  sequence () const;

  sequence_optional&
  sequence ();

  void
  sequence (const sequence_type& x);

  void
  sequence (const sequence_optional& x);

  // Constructors.
  //
  controller1 ();

  controller1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  controller1 (const controller1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual controller1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  controller1&
  operator= (const controller1& x);

  virtual 
  ~controller1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  id_optional id_;
  type_optional type_;
  sequence_optional sequence_;
};

class junctionReference: public ::xml_schema::type
{
  public:
  // junction
  //
  typedef ::xml_schema::string junction_type;
  typedef ::xsd::cxx::tree::optional< junction_type > junction_optional;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_optional&
  junction () const;

  junction_optional&
  junction ();

  void
  junction (const junction_type& x);

  void
  junction (const junction_optional& x);

  void
  junction (::std::unique_ptr< junction_type > p);

  // Constructors.
  //
  junctionReference ();

  junctionReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  junctionReference (const junctionReference& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual junctionReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  junctionReference&
  operator= (const junctionReference& x);

  virtual 
  ~junctionReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  junction_optional junction_;
};

class platform: public ::xml_schema::type
{
  public:
  // segment
  //
  typedef ::segment segment_type;
  typedef ::xsd::cxx::tree::sequence< segment_type > segment_sequence;
  typedef segment_sequence::iterator segment_iterator;
  typedef segment_sequence::const_iterator segment_const_iterator;
  typedef ::xsd::cxx::tree::traits< segment_type, char > segment_traits;

  const segment_sequence&
  segment () const;

  segment_sequence&
  segment ();

  void
  segment (const segment_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // Constructors.
  //
  platform ();

  platform (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  platform (const platform& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual platform*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  platform&
  operator= (const platform& x);

  virtual 
  ~platform ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  segment_sequence segment_;
  name_optional name_;
  id_optional id_;
};

class line: public ::xml_schema::type
{
  public:
  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // space
  //
  typedef ::xml_schema::double_ space_type;
  typedef ::xsd::cxx::tree::optional< space_type > space_optional;
  typedef ::xsd::cxx::tree::traits< space_type, char, ::xsd::cxx::tree::schema_type::double_ > space_traits;

  const space_optional&
  space () const;

  space_optional&
  space ();

  void
  space (const space_type& x);

  void
  space (const space_optional& x);

  // tOffset
  //
  typedef ::xml_schema::double_ tOffset_type;
  typedef ::xsd::cxx::tree::optional< tOffset_type > tOffset_optional;
  typedef ::xsd::cxx::tree::traits< tOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > tOffset_traits;

  const tOffset_optional&
  tOffset () const;

  tOffset_optional&
  tOffset ();

  void
  tOffset (const tOffset_type& x);

  void
  tOffset (const tOffset_optional& x);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // rule
  //
  typedef ::rule rule_type;
  typedef ::xsd::cxx::tree::optional< rule_type > rule_optional;
  typedef ::xsd::cxx::tree::traits< rule_type, char > rule_traits;

  const rule_optional&
  rule () const;

  rule_optional&
  rule ();

  void
  rule (const rule_type& x);

  void
  rule (const rule_optional& x);

  void
  rule (::std::unique_ptr< rule_type > p);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // Constructors.
  //
  line ();

  line (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  line (const line& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual line*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  line&
  operator= (const line& x);

  virtual 
  ~line ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  length_optional length_;
  space_optional space_;
  tOffset_optional tOffset_;
  sOffset_optional sOffset_;
  rule_optional rule_;
  width_optional width_;
};

class predecessor1: public ::xml_schema::type
{
  public:
  // elementType
  //
  typedef ::elementType elementType_type;
  typedef ::xsd::cxx::tree::optional< elementType_type > elementType_optional;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_optional&
  elementType () const;

  elementType_optional&
  elementType ();

  void
  elementType (const elementType_type& x);

  void
  elementType (const elementType_optional& x);

  void
  elementType (::std::unique_ptr< elementType_type > p);

  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::optional< elementId_type > elementId_optional;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_optional&
  elementId () const;

  elementId_optional&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (const elementId_optional& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // contactPoint
  //
  typedef ::contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // Constructors.
  //
  predecessor1 ();

  predecessor1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  predecessor1 (const predecessor1& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual predecessor1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  predecessor1&
  operator= (const predecessor1& x);

  virtual 
  ~predecessor1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  elementType_optional elementType_;
  elementId_optional elementId_;
  contactPoint_optional contactPoint_;
};

class successor1: public ::xml_schema::type
{
  public:
  // elementType
  //
  typedef ::elementType elementType_type;
  typedef ::xsd::cxx::tree::optional< elementType_type > elementType_optional;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_optional&
  elementType () const;

  elementType_optional&
  elementType ();

  void
  elementType (const elementType_type& x);

  void
  elementType (const elementType_optional& x);

  void
  elementType (::std::unique_ptr< elementType_type > p);

  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::optional< elementId_type > elementId_optional;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_optional&
  elementId () const;

  elementId_optional&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (const elementId_optional& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // contactPoint
  //
  typedef ::contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // Constructors.
  //
  successor1 ();

  successor1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  successor1 (const successor1& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual successor1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  successor1&
  operator= (const successor1& x);

  virtual 
  ~successor1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  elementType_optional elementType_;
  elementId_optional elementId_;
  contactPoint_optional contactPoint_;
};

class neighbor: public ::xml_schema::type
{
  public:
  // side
  //
  typedef ::side side_type;
  typedef ::xsd::cxx::tree::optional< side_type > side_optional;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_optional&
  side () const;

  side_optional&
  side ();

  void
  side (const side_type& x);

  void
  side (const side_optional& x);

  void
  side (::std::unique_ptr< side_type > p);

  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::optional< elementId_type > elementId_optional;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_optional&
  elementId () const;

  elementId_optional&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (const elementId_optional& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // direction
  //
  typedef ::direction direction_type;
  typedef ::xsd::cxx::tree::optional< direction_type > direction_optional;
  typedef ::xsd::cxx::tree::traits< direction_type, char > direction_traits;

  const direction_optional&
  direction () const;

  direction_optional&
  direction ();

  void
  direction (const direction_type& x);

  void
  direction (const direction_optional& x);

  void
  direction (::std::unique_ptr< direction_type > p);

  // Constructors.
  //
  neighbor ();

  neighbor (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  neighbor (const neighbor& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual neighbor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  neighbor&
  operator= (const neighbor& x);

  virtual 
  ~neighbor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  side_optional side_;
  elementId_optional elementId_;
  direction_optional direction_;
};

class speed1: public ::xml_schema::type
{
  public:
  // max
  //
  typedef ::t_max max_type;
  typedef ::xsd::cxx::tree::optional< max_type > max_optional;
  typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

  const max_optional&
  t_max () const;

  max_optional&
  t_max ();

  void
  t_max (const max_type& x);

  void
  t_max (const max_optional& x);

  void
  t_max (::std::unique_ptr< max_type > p);

  // unit
  //
  typedef ::unit unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::unique_ptr< unit_type > p);

  // Constructors.
  //
  speed1 ();

  speed1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  speed1 (const speed1& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual speed1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  speed1&
  operator= (const speed1& x);

  virtual 
  ~speed1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  max_optional t_max_;
  unit_optional unit_;
};

class geometry: public ::xml_schema::type
{
  public:
  // line
  //
  typedef ::line1 line_type;
  typedef ::xsd::cxx::tree::optional< line_type > line_optional;
  typedef ::xsd::cxx::tree::traits< line_type, char > line_traits;

  const line_optional&
  line () const;

  line_optional&
  line ();

  void
  line (const line_type& x);

  void
  line (const line_optional& x);

  void
  line (::std::unique_ptr< line_type > p);

  // spiral
  //
  typedef ::spiral spiral_type;
  typedef ::xsd::cxx::tree::optional< spiral_type > spiral_optional;
  typedef ::xsd::cxx::tree::traits< spiral_type, char > spiral_traits;

  const spiral_optional&
  spiral () const;

  spiral_optional&
  spiral ();

  void
  spiral (const spiral_type& x);

  void
  spiral (const spiral_optional& x);

  void
  spiral (::std::unique_ptr< spiral_type > p);

  // arc
  //
  typedef ::arc arc_type;
  typedef ::xsd::cxx::tree::optional< arc_type > arc_optional;
  typedef ::xsd::cxx::tree::traits< arc_type, char > arc_traits;

  const arc_optional&
  arc () const;

  arc_optional&
  arc ();

  void
  arc (const arc_type& x);

  void
  arc (const arc_optional& x);

  void
  arc (::std::unique_ptr< arc_type > p);

  // poly3
  //
  typedef ::poly3 poly3_type;
  typedef ::xsd::cxx::tree::optional< poly3_type > poly3_optional;
  typedef ::xsd::cxx::tree::traits< poly3_type, char > poly3_traits;

  const poly3_optional&
  poly3 () const;

  poly3_optional&
  poly3 ();

  void
  poly3 (const poly3_type& x);

  void
  poly3 (const poly3_optional& x);

  void
  poly3 (::std::unique_ptr< poly3_type > p);

  // paramPoly3
  //
  typedef ::paramPoly3 paramPoly3_type;
  typedef ::xsd::cxx::tree::optional< paramPoly3_type > paramPoly3_optional;
  typedef ::xsd::cxx::tree::traits< paramPoly3_type, char > paramPoly3_traits;

  const paramPoly3_optional&
  paramPoly3 () const;

  paramPoly3_optional&
  paramPoly3 ();

  void
  paramPoly3 (const paramPoly3_type& x);

  void
  paramPoly3 (const paramPoly3_optional& x);

  void
  paramPoly3 (::std::unique_ptr< paramPoly3_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::optional< x_type > x_optional;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_optional&
  x () const;

  x_optional&
  x ();

  void
  x (const x_type& x);

  void
  x (const x_optional& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::optional< y_type > y_optional;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_optional&
  y () const;

  y_optional&
  y ();

  void
  y (const y_type& x);

  void
  y (const y_optional& x);

  // hdg
  //
  typedef ::xml_schema::double_ hdg_type;
  typedef ::xsd::cxx::tree::optional< hdg_type > hdg_optional;
  typedef ::xsd::cxx::tree::traits< hdg_type, char, ::xsd::cxx::tree::schema_type::double_ > hdg_traits;

  const hdg_optional&
  hdg () const;

  hdg_optional&
  hdg ();

  void
  hdg (const hdg_type& x);

  void
  hdg (const hdg_optional& x);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // Constructors.
  //
  geometry ();

  geometry (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  geometry (const geometry& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual geometry*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  geometry&
  operator= (const geometry& x);

  virtual 
  ~geometry ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  line_optional line_;
  spiral_optional spiral_;
  arc_optional arc_;
  poly3_optional poly3_;
  paramPoly3_optional paramPoly3_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  x_optional x_;
  y_optional y_;
  hdg_optional hdg_;
  length_optional length_;
};

class elevation: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  elevation ();

  elevation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  elevation (const elevation& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual elevation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  elevation&
  operator= (const elevation& x);

  virtual 
  ~elevation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class superelevation: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  superelevation ();

  superelevation (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  superelevation (const superelevation& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual superelevation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  superelevation&
  operator= (const superelevation& x);

  virtual 
  ~superelevation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class crossfall: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // side
  //
  typedef ::crossfallSide side_type;
  typedef ::xsd::cxx::tree::optional< side_type > side_optional;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_optional&
  side () const;

  side_optional&
  side ();

  void
  side (const side_type& x);

  void
  side (const side_optional& x);

  void
  side (::std::unique_ptr< side_type > p);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  crossfall ();

  crossfall (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  crossfall (const crossfall& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual crossfall*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  crossfall&
  operator= (const crossfall& x);

  virtual 
  ~crossfall ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  side_optional side_;
  s_optional s_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class shape: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::optional< t_type > t_optional;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_optional&
  t () const;

  t_optional&
  t ();

  void
  t (const t_type& x);

  void
  t (const t_optional& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  shape ();

  shape (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  shape (const shape& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual shape*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  shape&
  operator= (const shape& x);

  virtual 
  ~shape ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  t_optional t_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class laneOffset: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  laneOffset ();

  laneOffset (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  laneOffset (const laneOffset& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual laneOffset*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneOffset&
  operator= (const laneOffset& x);

  virtual 
  ~laneOffset ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class laneSection: public ::xml_schema::type
{
  public:
  // left
  //
  typedef ::left left_type;
  typedef ::xsd::cxx::tree::optional< left_type > left_optional;
  typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

  const left_optional&
  left () const;

  left_optional&
  left ();

  void
  left (const left_type& x);

  void
  left (const left_optional& x);

  void
  left (::std::unique_ptr< left_type > p);

  // center
  //
  typedef ::center center_type;
  typedef ::xsd::cxx::tree::traits< center_type, char > center_traits;

  const center_type&
  center () const;

  center_type&
  center ();

  void
  center (const center_type& x);

  void
  center (::std::unique_ptr< center_type > p);

  // right
  //
  typedef ::right right_type;
  typedef ::xsd::cxx::tree::optional< right_type > right_optional;
  typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

  const right_optional&
  right () const;

  right_optional&
  right ();

  void
  right (const right_type& x);

  void
  right (const right_optional& x);

  void
  right (::std::unique_ptr< right_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // singleSide
  //
  typedef ::singleSide singleSide_type;
  typedef ::xsd::cxx::tree::optional< singleSide_type > singleSide_optional;
  typedef ::xsd::cxx::tree::traits< singleSide_type, char > singleSide_traits;

  const singleSide_optional&
  singleSide () const;

  singleSide_optional&
  singleSide ();

  void
  singleSide (const singleSide_type& x);

  void
  singleSide (const singleSide_optional& x);

  void
  singleSide (::std::unique_ptr< singleSide_type > p);

  // Constructors.
  //
  laneSection (const center_type&);

  laneSection (::std::unique_ptr< center_type >);

  laneSection (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  laneSection (const laneSection& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual laneSection*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneSection&
  operator= (const laneSection& x);

  virtual 
  ~laneSection ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  left_optional left_;
  ::xsd::cxx::tree::one< center_type > center_;
  right_optional right_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  singleSide_optional singleSide_;
};

class object: public ::xml_schema::type
{
  public:
  // repeat
  //
  typedef ::repeat repeat_type;
  typedef ::xsd::cxx::tree::sequence< repeat_type > repeat_sequence;
  typedef repeat_sequence::iterator repeat_iterator;
  typedef repeat_sequence::const_iterator repeat_const_iterator;
  typedef ::xsd::cxx::tree::traits< repeat_type, char > repeat_traits;

  const repeat_sequence&
  repeat () const;

  repeat_sequence&
  repeat ();

  void
  repeat (const repeat_sequence& s);

  // outline
  //
  typedef ::outline outline_type;
  typedef ::xsd::cxx::tree::optional< outline_type > outline_optional;
  typedef ::xsd::cxx::tree::traits< outline_type, char > outline_traits;

  const outline_optional&
  outline () const;

  outline_optional&
  outline ();

  void
  outline (const outline_type& x);

  void
  outline (const outline_optional& x);

  void
  outline (::std::unique_ptr< outline_type > p);

  // material
  //
  typedef ::material1 material_type;
  typedef ::xsd::cxx::tree::optional< material_type > material_optional;
  typedef ::xsd::cxx::tree::traits< material_type, char > material_traits;

  const material_optional&
  material () const;

  material_optional&
  material ();

  void
  material (const material_type& x);

  void
  material (const material_optional& x);

  void
  material (::std::unique_ptr< material_type > p);

  // validity
  //
  typedef ::laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // parkingSpace
  //
  typedef ::parkingSpace parkingSpace_type;
  typedef ::xsd::cxx::tree::optional< parkingSpace_type > parkingSpace_optional;
  typedef ::xsd::cxx::tree::traits< parkingSpace_type, char > parkingSpace_traits;

  const parkingSpace_optional&
  parkingSpace () const;

  parkingSpace_optional&
  parkingSpace ();

  void
  parkingSpace (const parkingSpace_type& x);

  void
  parkingSpace (const parkingSpace_optional& x);

  void
  parkingSpace (::std::unique_ptr< parkingSpace_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::optional< t_type > t_optional;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_optional&
  t () const;

  t_optional&
  t ();

  void
  t (const t_type& x);

  void
  t (const t_optional& x);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  // validLength
  //
  typedef ::xml_schema::double_ validLength_type;
  typedef ::xsd::cxx::tree::optional< validLength_type > validLength_optional;
  typedef ::xsd::cxx::tree::traits< validLength_type, char, ::xsd::cxx::tree::schema_type::double_ > validLength_traits;

  const validLength_optional&
  validLength () const;

  validLength_optional&
  validLength ();

  void
  validLength (const validLength_type& x);

  void
  validLength (const validLength_optional& x);

  // orientation
  //
  typedef ::orientation orientation_type;
  typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_optional&
  orientation () const;

  orientation_optional&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (const orientation_optional& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // radius
  //
  typedef ::xml_schema::double_ radius_type;
  typedef ::xsd::cxx::tree::optional< radius_type > radius_optional;
  typedef ::xsd::cxx::tree::traits< radius_type, char, ::xsd::cxx::tree::schema_type::double_ > radius_traits;

  const radius_optional&
  radius () const;

  radius_optional&
  radius ();

  void
  radius (const radius_type& x);

  void
  radius (const radius_optional& x);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // hdg
  //
  typedef ::xml_schema::double_ hdg_type;
  typedef ::xsd::cxx::tree::optional< hdg_type > hdg_optional;
  typedef ::xsd::cxx::tree::traits< hdg_type, char, ::xsd::cxx::tree::schema_type::double_ > hdg_traits;

  const hdg_optional&
  hdg () const;

  hdg_optional&
  hdg ();

  void
  hdg (const hdg_type& x);

  void
  hdg (const hdg_optional& x);

  // pitch
  //
  typedef ::xml_schema::double_ pitch_type;
  typedef ::xsd::cxx::tree::optional< pitch_type > pitch_optional;
  typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::double_ > pitch_traits;

  const pitch_optional&
  pitch () const;

  pitch_optional&
  pitch ();

  void
  pitch (const pitch_type& x);

  void
  pitch (const pitch_optional& x);

  // roll
  //
  typedef ::xml_schema::double_ roll_type;
  typedef ::xsd::cxx::tree::optional< roll_type > roll_optional;
  typedef ::xsd::cxx::tree::traits< roll_type, char, ::xsd::cxx::tree::schema_type::double_ > roll_traits;

  const roll_optional&
  roll () const;

  roll_optional&
  roll ();

  void
  roll (const roll_type& x);

  void
  roll (const roll_optional& x);

  // Constructors.
  //
  object ();

  object (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  object (const object& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual object*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  object&
  operator= (const object& x);

  virtual 
  ~object ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  repeat_sequence repeat_;
  outline_optional outline_;
  material_optional material_;
  validity_sequence validity_;
  parkingSpace_optional parkingSpace_;
  userData_sequence userData_;
  include_sequence include_;
  type_optional type_;
  name_optional name_;
  id_optional id_;
  s_optional s_;
  t_optional t_;
  zOffset_optional zOffset_;
  validLength_optional validLength_;
  orientation_optional orientation_;
  length_optional length_;
  width_optional width_;
  radius_optional radius_;
  height_optional height_;
  hdg_optional hdg_;
  pitch_optional pitch_;
  roll_optional roll_;
};

class objectReference: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::optional< t_type > t_optional;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_optional&
  t () const;

  t_optional&
  t ();

  void
  t (const t_type& x);

  void
  t (const t_optional& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  // validLength
  //
  typedef ::xml_schema::double_ validLength_type;
  typedef ::xsd::cxx::tree::optional< validLength_type > validLength_optional;
  typedef ::xsd::cxx::tree::traits< validLength_type, char, ::xsd::cxx::tree::schema_type::double_ > validLength_traits;

  const validLength_optional&
  validLength () const;

  validLength_optional&
  validLength ();

  void
  validLength (const validLength_type& x);

  void
  validLength (const validLength_optional& x);

  // orientation
  //
  typedef ::orientation orientation_type;
  typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_optional&
  orientation () const;

  orientation_optional&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (const orientation_optional& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // Constructors.
  //
  objectReference ();

  objectReference (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  objectReference (const objectReference& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual objectReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  objectReference&
  operator= (const objectReference& x);

  virtual 
  ~objectReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  t_optional t_;
  id_optional id_;
  zOffset_optional zOffset_;
  validLength_optional validLength_;
  orientation_optional orientation_;
};

class tunnel: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::tunnelType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // lighting
  //
  typedef ::xml_schema::double_ lighting_type;
  typedef ::xsd::cxx::tree::optional< lighting_type > lighting_optional;
  typedef ::xsd::cxx::tree::traits< lighting_type, char, ::xsd::cxx::tree::schema_type::double_ > lighting_traits;

  const lighting_optional&
  lighting () const;

  lighting_optional&
  lighting ();

  void
  lighting (const lighting_type& x);

  void
  lighting (const lighting_optional& x);

  // daylight
  //
  typedef ::xml_schema::double_ daylight_type;
  typedef ::xsd::cxx::tree::optional< daylight_type > daylight_optional;
  typedef ::xsd::cxx::tree::traits< daylight_type, char, ::xsd::cxx::tree::schema_type::double_ > daylight_traits;

  const daylight_optional&
  daylight () const;

  daylight_optional&
  daylight ();

  void
  daylight (const daylight_type& x);

  void
  daylight (const daylight_optional& x);

  // Constructors.
  //
  tunnel ();

  tunnel (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  tunnel (const tunnel& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual tunnel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  tunnel&
  operator= (const tunnel& x);

  virtual 
  ~tunnel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  length_optional length_;
  name_optional name_;
  id_optional id_;
  type_optional type_;
  lighting_optional lighting_;
  daylight_optional daylight_;
};

class bridge: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::bridgeType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  bridge ();

  bridge (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  bridge (const bridge& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual bridge*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  bridge&
  operator= (const bridge& x);

  virtual 
  ~bridge ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  length_optional length_;
  name_optional name_;
  id_optional id_;
  type_optional type_;
};

class t_signal: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // dependency
  //
  typedef ::dependency dependency_type;
  typedef ::xsd::cxx::tree::sequence< dependency_type > dependency_sequence;
  typedef dependency_sequence::iterator dependency_iterator;
  typedef dependency_sequence::const_iterator dependency_const_iterator;
  typedef ::xsd::cxx::tree::traits< dependency_type, char > dependency_traits;

  const dependency_sequence&
  dependency () const;

  dependency_sequence&
  dependency ();

  void
  dependency (const dependency_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::optional< t_type > t_optional;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_optional&
  t () const;

  t_optional&
  t ();

  void
  t (const t_type& x);

  void
  t (const t_optional& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // dynamic
  //
  typedef ::dynamic dynamic_type;
  typedef ::xsd::cxx::tree::optional< dynamic_type > dynamic_optional;
  typedef ::xsd::cxx::tree::traits< dynamic_type, char > dynamic_traits;

  const dynamic_optional&
  dynamic () const;

  dynamic_optional&
  dynamic ();

  void
  dynamic (const dynamic_type& x);

  void
  dynamic (const dynamic_optional& x);

  void
  dynamic (::std::unique_ptr< dynamic_type > p);

  // orientation
  //
  typedef ::orientation orientation_type;
  typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_optional&
  orientation () const;

  orientation_optional&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (const orientation_optional& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  // country
  //
  typedef ::xml_schema::string country_type;
  typedef ::xsd::cxx::tree::optional< country_type > country_optional;
  typedef ::xsd::cxx::tree::traits< country_type, char > country_traits;

  const country_optional&
  country () const;

  country_optional&
  country ();

  void
  country (const country_type& x);

  void
  country (const country_optional& x);

  void
  country (::std::unique_ptr< country_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // subtype
  //
  typedef ::xml_schema::string subtype_type;
  typedef ::xsd::cxx::tree::optional< subtype_type > subtype_optional;
  typedef ::xsd::cxx::tree::traits< subtype_type, char > subtype_traits;

  const subtype_optional&
  subtype () const;

  subtype_optional&
  subtype ();

  void
  subtype (const subtype_type& x);

  void
  subtype (const subtype_optional& x);

  void
  subtype (::std::unique_ptr< subtype_type > p);

  // value
  //
  typedef ::xml_schema::double_ value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  // unit
  //
  typedef ::unit unit_type;
  typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
  typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

  const unit_optional&
  unit () const;

  unit_optional&
  unit ();

  void
  unit (const unit_type& x);

  void
  unit (const unit_optional& x);

  void
  unit (::std::unique_ptr< unit_type > p);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // width
  //
  typedef ::xml_schema::double_ width_type;
  typedef ::xsd::cxx::tree::optional< width_type > width_optional;
  typedef ::xsd::cxx::tree::traits< width_type, char, ::xsd::cxx::tree::schema_type::double_ > width_traits;

  const width_optional&
  width () const;

  width_optional&
  width ();

  void
  width (const width_type& x);

  void
  width (const width_optional& x);

  // text
  //
  typedef ::xml_schema::string text_type;
  typedef ::xsd::cxx::tree::optional< text_type > text_optional;
  typedef ::xsd::cxx::tree::traits< text_type, char > text_traits;

  const text_optional&
  text () const;

  text_optional&
  text ();

  void
  text (const text_type& x);

  void
  text (const text_optional& x);

  void
  text (::std::unique_ptr< text_type > p);

  // hOffset
  //
  typedef ::xml_schema::double_ hOffset_type;
  typedef ::xsd::cxx::tree::optional< hOffset_type > hOffset_optional;
  typedef ::xsd::cxx::tree::traits< hOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > hOffset_traits;

  const hOffset_optional&
  hOffset () const;

  hOffset_optional&
  hOffset ();

  void
  hOffset (const hOffset_type& x);

  void
  hOffset (const hOffset_optional& x);

  // pitch
  //
  typedef ::xml_schema::double_ pitch_type;
  typedef ::xsd::cxx::tree::optional< pitch_type > pitch_optional;
  typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::double_ > pitch_traits;

  const pitch_optional&
  pitch () const;

  pitch_optional&
  pitch ();

  void
  pitch (const pitch_type& x);

  void
  pitch (const pitch_optional& x);

  // roll
  //
  typedef ::xml_schema::double_ roll_type;
  typedef ::xsd::cxx::tree::optional< roll_type > roll_optional;
  typedef ::xsd::cxx::tree::traits< roll_type, char, ::xsd::cxx::tree::schema_type::double_ > roll_traits;

  const roll_optional&
  roll () const;

  roll_optional&
  roll ();

  void
  roll (const roll_type& x);

  void
  roll (const roll_optional& x);

  // Constructors.
  //
  t_signal ();

  t_signal (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  t_signal (const t_signal& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual t_signal*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  t_signal&
  operator= (const t_signal& x);

  virtual 
  ~t_signal ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  dependency_sequence dependency_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  t_optional t_;
  id_optional id_;
  name_optional name_;
  dynamic_optional dynamic_;
  orientation_optional orientation_;
  zOffset_optional zOffset_;
  country_optional country_;
  type_optional type_;
  subtype_optional subtype_;
  value_optional value_;
  unit_optional unit_;
  height_optional height_;
  width_optional width_;
  text_optional text_;
  hOffset_optional hOffset_;
  pitch_optional pitch_;
  roll_optional roll_;
};

class signalReference: public ::xml_schema::type
{
  public:
  // validity
  //
  typedef ::laneValidity validity_type;
  typedef ::xsd::cxx::tree::sequence< validity_type > validity_sequence;
  typedef validity_sequence::iterator validity_iterator;
  typedef validity_sequence::const_iterator validity_const_iterator;
  typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

  const validity_sequence&
  validity () const;

  validity_sequence&
  validity ();

  void
  validity (const validity_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::optional< t_type > t_optional;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_optional&
  t () const;

  t_optional&
  t ();

  void
  t (const t_type& x);

  void
  t (const t_optional& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // orientation
  //
  typedef ::orientation orientation_type;
  typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_optional&
  orientation () const;

  orientation_optional&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (const orientation_optional& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // Constructors.
  //
  signalReference ();

  signalReference (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  signalReference (const signalReference& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual signalReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  signalReference&
  operator= (const signalReference& x);

  virtual 
  ~signalReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  validity_sequence validity_;
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  t_optional t_;
  id_optional id_;
  orientation_optional orientation_;
};

class CRG: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // file
  //
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::optional< file_type > file_optional;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_optional&
  file () const;

  file_optional&
  file ();

  void
  file (const file_type& x);

  void
  file (const file_optional& x);

  void
  file (::std::unique_ptr< file_type > p);

  // sStart
  //
  typedef ::xml_schema::double_ sStart_type;
  typedef ::xsd::cxx::tree::optional< sStart_type > sStart_optional;
  typedef ::xsd::cxx::tree::traits< sStart_type, char, ::xsd::cxx::tree::schema_type::double_ > sStart_traits;

  const sStart_optional&
  sStart () const;

  sStart_optional&
  sStart ();

  void
  sStart (const sStart_type& x);

  void
  sStart (const sStart_optional& x);

  // sEnd
  //
  typedef ::xml_schema::double_ sEnd_type;
  typedef ::xsd::cxx::tree::optional< sEnd_type > sEnd_optional;
  typedef ::xsd::cxx::tree::traits< sEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > sEnd_traits;

  const sEnd_optional&
  sEnd () const;

  sEnd_optional&
  sEnd ();

  void
  sEnd (const sEnd_type& x);

  void
  sEnd (const sEnd_optional& x);

  // orientation
  //
  typedef ::surfaceOrientation orientation_type;
  typedef ::xsd::cxx::tree::optional< orientation_type > orientation_optional;
  typedef ::xsd::cxx::tree::traits< orientation_type, char > orientation_traits;

  const orientation_optional&
  orientation () const;

  orientation_optional&
  orientation ();

  void
  orientation (const orientation_type& x);

  void
  orientation (const orientation_optional& x);

  void
  orientation (::std::unique_ptr< orientation_type > p);

  // mode
  //
  typedef ::mode mode_type;
  typedef ::xsd::cxx::tree::optional< mode_type > mode_optional;
  typedef ::xsd::cxx::tree::traits< mode_type, char > mode_traits;

  const mode_optional&
  mode () const;

  mode_optional&
  mode ();

  void
  mode (const mode_type& x);

  void
  mode (const mode_optional& x);

  void
  mode (::std::unique_ptr< mode_type > p);

  // purpose
  //
  typedef ::purpose purpose_type;
  typedef ::xsd::cxx::tree::optional< purpose_type > purpose_optional;
  typedef ::xsd::cxx::tree::traits< purpose_type, char > purpose_traits;

  const purpose_optional&
  purpose () const;

  purpose_optional&
  purpose ();

  void
  purpose (const purpose_type& x);

  void
  purpose (const purpose_optional& x);

  void
  purpose (::std::unique_ptr< purpose_type > p);

  // sOffset
  //
  typedef ::xml_schema::double_ sOffset_type;
  typedef ::xsd::cxx::tree::optional< sOffset_type > sOffset_optional;
  typedef ::xsd::cxx::tree::traits< sOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > sOffset_traits;

  const sOffset_optional&
  sOffset () const;

  sOffset_optional&
  sOffset ();

  void
  sOffset (const sOffset_type& x);

  void
  sOffset (const sOffset_optional& x);

  // tOffset
  //
  typedef ::xml_schema::double_ tOffset_type;
  typedef ::xsd::cxx::tree::optional< tOffset_type > tOffset_optional;
  typedef ::xsd::cxx::tree::traits< tOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > tOffset_traits;

  const tOffset_optional&
  tOffset () const;

  tOffset_optional&
  tOffset ();

  void
  tOffset (const tOffset_type& x);

  void
  tOffset (const tOffset_optional& x);

  // zOffset
  //
  typedef ::xml_schema::double_ zOffset_type;
  typedef ::xsd::cxx::tree::optional< zOffset_type > zOffset_optional;
  typedef ::xsd::cxx::tree::traits< zOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffset_traits;

  const zOffset_optional&
  zOffset () const;

  zOffset_optional&
  zOffset ();

  void
  zOffset (const zOffset_type& x);

  void
  zOffset (const zOffset_optional& x);

  // zScale
  //
  typedef ::xml_schema::double_ zScale_type;
  typedef ::xsd::cxx::tree::optional< zScale_type > zScale_optional;
  typedef ::xsd::cxx::tree::traits< zScale_type, char, ::xsd::cxx::tree::schema_type::double_ > zScale_traits;

  const zScale_optional&
  zScale () const;

  zScale_optional&
  zScale ();

  void
  zScale (const zScale_type& x);

  void
  zScale (const zScale_optional& x);

  // hOffset
  //
  typedef ::xml_schema::double_ hOffset_type;
  typedef ::xsd::cxx::tree::optional< hOffset_type > hOffset_optional;
  typedef ::xsd::cxx::tree::traits< hOffset_type, char, ::xsd::cxx::tree::schema_type::double_ > hOffset_traits;

  const hOffset_optional&
  hOffset () const;

  hOffset_optional&
  hOffset ();

  void
  hOffset (const hOffset_type& x);

  void
  hOffset (const hOffset_optional& x);

  // Constructors.
  //
  CRG ();

  CRG (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  CRG (const CRG& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual CRG*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CRG&
  operator= (const CRG& x);

  virtual 
  ~CRG ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  file_optional file_;
  sStart_optional sStart_;
  sEnd_optional sEnd_;
  orientation_optional orientation_;
  mode_optional mode_;
  purpose_optional purpose_;
  sOffset_optional sOffset_;
  tOffset_optional tOffset_;
  zOffset_optional zOffset_;
  zScale_optional zScale_;
  hOffset_optional hOffset_;
};

class switch_: public ::xml_schema::type
{
  public:
  // mainTrack
  //
  typedef ::mainTrack mainTrack_type;
  typedef ::xsd::cxx::tree::traits< mainTrack_type, char > mainTrack_traits;

  const mainTrack_type&
  mainTrack () const;

  mainTrack_type&
  mainTrack ();

  void
  mainTrack (const mainTrack_type& x);

  void
  mainTrack (::std::unique_ptr< mainTrack_type > p);

  // sideTrack
  //
  typedef ::sideTrack sideTrack_type;
  typedef ::xsd::cxx::tree::traits< sideTrack_type, char > sideTrack_traits;

  const sideTrack_type&
  sideTrack () const;

  sideTrack_type&
  sideTrack ();

  void
  sideTrack (const sideTrack_type& x);

  void
  sideTrack (::std::unique_ptr< sideTrack_type > p);

  // partner
  //
  typedef ::partner partner_type;
  typedef ::xsd::cxx::tree::optional< partner_type > partner_optional;
  typedef ::xsd::cxx::tree::traits< partner_type, char > partner_traits;

  const partner_optional&
  partner () const;

  partner_optional&
  partner ();

  void
  partner (const partner_type& x);

  void
  partner (const partner_optional& x);

  void
  partner (::std::unique_ptr< partner_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // position
  //
  typedef ::position position_type;
  typedef ::xsd::cxx::tree::optional< position_type > position_optional;
  typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

  const position_optional&
  position () const;

  position_optional&
  position ();

  void
  position (const position_type& x);

  void
  position (const position_optional& x);

  void
  position (::std::unique_ptr< position_type > p);

  // Constructors.
  //
  switch_ (const mainTrack_type&,
           const sideTrack_type&);

  switch_ (::std::unique_ptr< mainTrack_type >,
           ::std::unique_ptr< sideTrack_type >);

  switch_ (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  switch_ (const switch_& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual switch_*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  switch_&
  operator= (const switch_& x);

  virtual 
  ~switch_ ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< mainTrack_type > mainTrack_;
  ::xsd::cxx::tree::one< sideTrack_type > sideTrack_;
  partner_optional partner_;
  userData_sequence userData_;
  include_sequence include_;
  name_optional name_;
  id_optional id_;
  position_optional position_;
};

class laneLink: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // from
  //
  typedef ::xml_schema::int_ from_type;
  typedef ::xsd::cxx::tree::optional< from_type > from_optional;
  typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

  const from_optional&
  from () const;

  from_optional&
  from ();

  void
  from (const from_type& x);

  void
  from (const from_optional& x);

  // to
  //
  typedef ::xml_schema::int_ to_type;
  typedef ::xsd::cxx::tree::optional< to_type > to_optional;
  typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

  const to_optional&
  to () const;

  to_optional&
  to ();

  void
  to (const to_type& x);

  void
  to (const to_optional& x);

  // Constructors.
  //
  laneLink ();

  laneLink (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  laneLink (const laneLink& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual laneLink*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneLink&
  operator= (const laneLink& x);

  virtual 
  ~laneLink ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  from_optional from_;
  to_optional to_;
};

class segment: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // roadId
  //
  typedef ::xml_schema::string roadId_type;
  typedef ::xsd::cxx::tree::optional< roadId_type > roadId_optional;
  typedef ::xsd::cxx::tree::traits< roadId_type, char > roadId_traits;

  const roadId_optional&
  roadId () const;

  roadId_optional&
  roadId ();

  void
  roadId (const roadId_type& x);

  void
  roadId (const roadId_optional& x);

  void
  roadId (::std::unique_ptr< roadId_type > p);

  // sStart
  //
  typedef ::xml_schema::double_ sStart_type;
  typedef ::xsd::cxx::tree::optional< sStart_type > sStart_optional;
  typedef ::xsd::cxx::tree::traits< sStart_type, char, ::xsd::cxx::tree::schema_type::double_ > sStart_traits;

  const sStart_optional&
  sStart () const;

  sStart_optional&
  sStart ();

  void
  sStart (const sStart_type& x);

  void
  sStart (const sStart_optional& x);

  // sEnd
  //
  typedef ::xml_schema::double_ sEnd_type;
  typedef ::xsd::cxx::tree::optional< sEnd_type > sEnd_optional;
  typedef ::xsd::cxx::tree::traits< sEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > sEnd_traits;

  const sEnd_optional&
  sEnd () const;

  sEnd_optional&
  sEnd ();

  void
  sEnd (const sEnd_type& x);

  void
  sEnd (const sEnd_optional& x);

  // side
  //
  typedef ::side side_type;
  typedef ::xsd::cxx::tree::optional< side_type > side_optional;
  typedef ::xsd::cxx::tree::traits< side_type, char > side_traits;

  const side_optional&
  side () const;

  side_optional&
  side ();

  void
  side (const side_type& x);

  void
  side (const side_optional& x);

  void
  side (::std::unique_ptr< side_type > p);

  // Constructors.
  //
  segment ();

  segment (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  segment (const segment& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual segment*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  segment&
  operator= (const segment& x);

  virtual 
  ~segment ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  roadId_optional roadId_;
  sStart_optional sStart_;
  sEnd_optional sEnd_;
  side_optional side_;
};

class line1: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  line1 ();

  line1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  line1 (const line1& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual line1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  line1&
  operator= (const line1& x);

  virtual 
  ~line1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
};

class spiral: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // curvStart
  //
  typedef ::xml_schema::double_ curvStart_type;
  typedef ::xsd::cxx::tree::optional< curvStart_type > curvStart_optional;
  typedef ::xsd::cxx::tree::traits< curvStart_type, char, ::xsd::cxx::tree::schema_type::double_ > curvStart_traits;

  const curvStart_optional&
  curvStart () const;

  curvStart_optional&
  curvStart ();

  void
  curvStart (const curvStart_type& x);

  void
  curvStart (const curvStart_optional& x);

  // curvEnd
  //
  typedef ::xml_schema::double_ curvEnd_type;
  typedef ::xsd::cxx::tree::optional< curvEnd_type > curvEnd_optional;
  typedef ::xsd::cxx::tree::traits< curvEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > curvEnd_traits;

  const curvEnd_optional&
  curvEnd () const;

  curvEnd_optional&
  curvEnd ();

  void
  curvEnd (const curvEnd_type& x);

  void
  curvEnd (const curvEnd_optional& x);

  // Constructors.
  //
  spiral ();

  spiral (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  spiral (const spiral& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual spiral*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  spiral&
  operator= (const spiral& x);

  virtual 
  ~spiral ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  curvStart_optional curvStart_;
  curvEnd_optional curvEnd_;
};

class arc: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // curvature
  //
  typedef ::xml_schema::double_ curvature_type;
  typedef ::xsd::cxx::tree::optional< curvature_type > curvature_optional;
  typedef ::xsd::cxx::tree::traits< curvature_type, char, ::xsd::cxx::tree::schema_type::double_ > curvature_traits;

  const curvature_optional&
  curvature () const;

  curvature_optional&
  curvature ();

  void
  curvature (const curvature_type& x);

  void
  curvature (const curvature_optional& x);

  // Constructors.
  //
  arc ();

  arc (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  arc (const arc& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual arc*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  arc&
  operator= (const arc& x);

  virtual 
  ~arc ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  curvature_optional curvature_;
};

class poly3: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // a
  //
  typedef ::xml_schema::double_ a_type;
  typedef ::xsd::cxx::tree::optional< a_type > a_optional;
  typedef ::xsd::cxx::tree::traits< a_type, char, ::xsd::cxx::tree::schema_type::double_ > a_traits;

  const a_optional&
  a () const;

  a_optional&
  a ();

  void
  a (const a_type& x);

  void
  a (const a_optional& x);

  // b
  //
  typedef ::xml_schema::double_ b_type;
  typedef ::xsd::cxx::tree::optional< b_type > b_optional;
  typedef ::xsd::cxx::tree::traits< b_type, char, ::xsd::cxx::tree::schema_type::double_ > b_traits;

  const b_optional&
  b () const;

  b_optional&
  b ();

  void
  b (const b_type& x);

  void
  b (const b_optional& x);

  // c
  //
  typedef ::xml_schema::double_ c_type;
  typedef ::xsd::cxx::tree::optional< c_type > c_optional;
  typedef ::xsd::cxx::tree::traits< c_type, char, ::xsd::cxx::tree::schema_type::double_ > c_traits;

  const c_optional&
  c () const;

  c_optional&
  c ();

  void
  c (const c_type& x);

  void
  c (const c_optional& x);

  // d
  //
  typedef ::xml_schema::double_ d_type;
  typedef ::xsd::cxx::tree::optional< d_type > d_optional;
  typedef ::xsd::cxx::tree::traits< d_type, char, ::xsd::cxx::tree::schema_type::double_ > d_traits;

  const d_optional&
  d () const;

  d_optional&
  d ();

  void
  d (const d_type& x);

  void
  d (const d_optional& x);

  // Constructors.
  //
  poly3 ();

  poly3 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  poly3 (const poly3& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual poly3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  poly3&
  operator= (const poly3& x);

  virtual 
  ~poly3 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  a_optional a_;
  b_optional b_;
  c_optional c_;
  d_optional d_;
};

class paramPoly3: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // aU
  //
  typedef ::xml_schema::double_ aU_type;
  typedef ::xsd::cxx::tree::optional< aU_type > aU_optional;
  typedef ::xsd::cxx::tree::traits< aU_type, char, ::xsd::cxx::tree::schema_type::double_ > aU_traits;

  const aU_optional&
  aU () const;

  aU_optional&
  aU ();

  void
  aU (const aU_type& x);

  void
  aU (const aU_optional& x);

  // bU
  //
  typedef ::xml_schema::double_ bU_type;
  typedef ::xsd::cxx::tree::optional< bU_type > bU_optional;
  typedef ::xsd::cxx::tree::traits< bU_type, char, ::xsd::cxx::tree::schema_type::double_ > bU_traits;

  const bU_optional&
  bU () const;

  bU_optional&
  bU ();

  void
  bU (const bU_type& x);

  void
  bU (const bU_optional& x);

  // cU
  //
  typedef ::xml_schema::double_ cU_type;
  typedef ::xsd::cxx::tree::optional< cU_type > cU_optional;
  typedef ::xsd::cxx::tree::traits< cU_type, char, ::xsd::cxx::tree::schema_type::double_ > cU_traits;

  const cU_optional&
  cU () const;

  cU_optional&
  cU ();

  void
  cU (const cU_type& x);

  void
  cU (const cU_optional& x);

  // dU
  //
  typedef ::xml_schema::double_ dU_type;
  typedef ::xsd::cxx::tree::optional< dU_type > dU_optional;
  typedef ::xsd::cxx::tree::traits< dU_type, char, ::xsd::cxx::tree::schema_type::double_ > dU_traits;

  const dU_optional&
  dU () const;

  dU_optional&
  dU ();

  void
  dU (const dU_type& x);

  void
  dU (const dU_optional& x);

  // aV
  //
  typedef ::xml_schema::double_ aV_type;
  typedef ::xsd::cxx::tree::optional< aV_type > aV_optional;
  typedef ::xsd::cxx::tree::traits< aV_type, char, ::xsd::cxx::tree::schema_type::double_ > aV_traits;

  const aV_optional&
  aV () const;

  aV_optional&
  aV ();

  void
  aV (const aV_type& x);

  void
  aV (const aV_optional& x);

  // bV
  //
  typedef ::xml_schema::double_ bV_type;
  typedef ::xsd::cxx::tree::optional< bV_type > bV_optional;
  typedef ::xsd::cxx::tree::traits< bV_type, char, ::xsd::cxx::tree::schema_type::double_ > bV_traits;

  const bV_optional&
  bV () const;

  bV_optional&
  bV ();

  void
  bV (const bV_type& x);

  void
  bV (const bV_optional& x);

  // cV
  //
  typedef ::xml_schema::double_ cV_type;
  typedef ::xsd::cxx::tree::optional< cV_type > cV_optional;
  typedef ::xsd::cxx::tree::traits< cV_type, char, ::xsd::cxx::tree::schema_type::double_ > cV_traits;

  const cV_optional&
  cV () const;

  cV_optional&
  cV ();

  void
  cV (const cV_type& x);

  void
  cV (const cV_optional& x);

  // dV
  //
  typedef ::xml_schema::double_ dV_type;
  typedef ::xsd::cxx::tree::optional< dV_type > dV_optional;
  typedef ::xsd::cxx::tree::traits< dV_type, char, ::xsd::cxx::tree::schema_type::double_ > dV_traits;

  const dV_optional&
  dV () const;

  dV_optional&
  dV ();

  void
  dV (const dV_type& x);

  void
  dV (const dV_optional& x);

  // pRange
  //
  typedef ::pRange pRange_type;
  typedef ::xsd::cxx::tree::optional< pRange_type > pRange_optional;
  typedef ::xsd::cxx::tree::traits< pRange_type, char > pRange_traits;

  const pRange_optional&
  pRange () const;

  pRange_optional&
  pRange ();

  void
  pRange (const pRange_type& x);

  void
  pRange (const pRange_optional& x);

  void
  pRange (::std::unique_ptr< pRange_type > p);

  // Constructors.
  //
  paramPoly3 ();

  paramPoly3 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  paramPoly3 (const paramPoly3& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual paramPoly3*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  paramPoly3&
  operator= (const paramPoly3& x);

  virtual 
  ~paramPoly3 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  aU_optional aU_;
  bU_optional bU_;
  cU_optional cU_;
  dU_optional dU_;
  aV_optional aV_;
  bV_optional bV_;
  cV_optional cV_;
  dV_optional dV_;
  pRange_optional pRange_;
};

class left: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::lane lane_type;
  typedef ::xsd::cxx::tree::sequence< lane_type > lane_sequence;
  typedef lane_sequence::iterator lane_iterator;
  typedef lane_sequence::const_iterator lane_const_iterator;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_sequence&
  lane () const;

  lane_sequence&
  lane ();

  void
  lane (const lane_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  left ();

  left (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  left (const left& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual left*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  left&
  operator= (const left& x);

  virtual 
  ~left ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lane_sequence lane_;
  userData_sequence userData_;
  include_sequence include_;
};

class center: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::centerLane lane_type;
  typedef ::xsd::cxx::tree::optional< lane_type > lane_optional;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_optional&
  lane () const;

  lane_optional&
  lane ();

  void
  lane (const lane_type& x);

  void
  lane (const lane_optional& x);

  void
  lane (::std::unique_ptr< lane_type > p);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  center ();

  center (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  center (const center& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual center*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  center&
  operator= (const center& x);

  virtual 
  ~center ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lane_optional lane_;
  userData_sequence userData_;
  include_sequence include_;
};

class right: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::lane lane_type;
  typedef ::xsd::cxx::tree::sequence< lane_type > lane_sequence;
  typedef lane_sequence::iterator lane_iterator;
  typedef lane_sequence::const_iterator lane_const_iterator;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_sequence&
  lane () const;

  lane_sequence&
  lane ();

  void
  lane (const lane_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  right ();

  right (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  right (const right& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual right*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  right&
  operator= (const right& x);

  virtual 
  ~right ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lane_sequence lane_;
  userData_sequence userData_;
  include_sequence include_;
};

class repeat: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // distance
  //
  typedef ::xml_schema::double_ distance_type;
  typedef ::xsd::cxx::tree::optional< distance_type > distance_optional;
  typedef ::xsd::cxx::tree::traits< distance_type, char, ::xsd::cxx::tree::schema_type::double_ > distance_traits;

  const distance_optional&
  distance () const;

  distance_optional&
  distance ();

  void
  distance (const distance_type& x);

  void
  distance (const distance_optional& x);

  // tStart
  //
  typedef ::xml_schema::double_ tStart_type;
  typedef ::xsd::cxx::tree::optional< tStart_type > tStart_optional;
  typedef ::xsd::cxx::tree::traits< tStart_type, char, ::xsd::cxx::tree::schema_type::double_ > tStart_traits;

  const tStart_optional&
  tStart () const;

  tStart_optional&
  tStart ();

  void
  tStart (const tStart_type& x);

  void
  tStart (const tStart_optional& x);

  // tEnd
  //
  typedef ::xml_schema::double_ tEnd_type;
  typedef ::xsd::cxx::tree::optional< tEnd_type > tEnd_optional;
  typedef ::xsd::cxx::tree::traits< tEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > tEnd_traits;

  const tEnd_optional&
  tEnd () const;

  tEnd_optional&
  tEnd ();

  void
  tEnd (const tEnd_type& x);

  void
  tEnd (const tEnd_optional& x);

  // widthStart
  //
  typedef ::xml_schema::double_ widthStart_type;
  typedef ::xsd::cxx::tree::optional< widthStart_type > widthStart_optional;
  typedef ::xsd::cxx::tree::traits< widthStart_type, char, ::xsd::cxx::tree::schema_type::double_ > widthStart_traits;

  const widthStart_optional&
  widthStart () const;

  widthStart_optional&
  widthStart ();

  void
  widthStart (const widthStart_type& x);

  void
  widthStart (const widthStart_optional& x);

  // widthEnd
  //
  typedef ::xml_schema::double_ widthEnd_type;
  typedef ::xsd::cxx::tree::optional< widthEnd_type > widthEnd_optional;
  typedef ::xsd::cxx::tree::traits< widthEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > widthEnd_traits;

  const widthEnd_optional&
  widthEnd () const;

  widthEnd_optional&
  widthEnd ();

  void
  widthEnd (const widthEnd_type& x);

  void
  widthEnd (const widthEnd_optional& x);

  // heightStart
  //
  typedef ::xml_schema::double_ heightStart_type;
  typedef ::xsd::cxx::tree::optional< heightStart_type > heightStart_optional;
  typedef ::xsd::cxx::tree::traits< heightStart_type, char, ::xsd::cxx::tree::schema_type::double_ > heightStart_traits;

  const heightStart_optional&
  heightStart () const;

  heightStart_optional&
  heightStart ();

  void
  heightStart (const heightStart_type& x);

  void
  heightStart (const heightStart_optional& x);

  // heightEnd
  //
  typedef ::xml_schema::double_ heightEnd_type;
  typedef ::xsd::cxx::tree::optional< heightEnd_type > heightEnd_optional;
  typedef ::xsd::cxx::tree::traits< heightEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > heightEnd_traits;

  const heightEnd_optional&
  heightEnd () const;

  heightEnd_optional&
  heightEnd ();

  void
  heightEnd (const heightEnd_type& x);

  void
  heightEnd (const heightEnd_optional& x);

  // zOffsetStart
  //
  typedef ::xml_schema::double_ zOffsetStart_type;
  typedef ::xsd::cxx::tree::optional< zOffsetStart_type > zOffsetStart_optional;
  typedef ::xsd::cxx::tree::traits< zOffsetStart_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffsetStart_traits;

  const zOffsetStart_optional&
  zOffsetStart () const;

  zOffsetStart_optional&
  zOffsetStart ();

  void
  zOffsetStart (const zOffsetStart_type& x);

  void
  zOffsetStart (const zOffsetStart_optional& x);

  // zOffsetEnd
  //
  typedef ::xml_schema::double_ zOffsetEnd_type;
  typedef ::xsd::cxx::tree::optional< zOffsetEnd_type > zOffsetEnd_optional;
  typedef ::xsd::cxx::tree::traits< zOffsetEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > zOffsetEnd_traits;

  const zOffsetEnd_optional&
  zOffsetEnd () const;

  zOffsetEnd_optional&
  zOffsetEnd ();

  void
  zOffsetEnd (const zOffsetEnd_type& x);

  void
  zOffsetEnd (const zOffsetEnd_optional& x);

  // Constructors.
  //
  repeat ();

  repeat (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  repeat (const repeat& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual repeat*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  repeat&
  operator= (const repeat& x);

  virtual 
  ~repeat ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  length_optional length_;
  distance_optional distance_;
  tStart_optional tStart_;
  tEnd_optional tEnd_;
  widthStart_optional widthStart_;
  widthEnd_optional widthEnd_;
  heightStart_optional heightStart_;
  heightEnd_optional heightEnd_;
  zOffsetStart_optional zOffsetStart_;
  zOffsetEnd_optional zOffsetEnd_;
};

class outline: public ::xml_schema::type
{
  public:
  // cornerRoad
  //
  typedef ::cornerRoad cornerRoad_type;
  typedef ::xsd::cxx::tree::sequence< cornerRoad_type > cornerRoad_sequence;
  typedef cornerRoad_sequence::iterator cornerRoad_iterator;
  typedef cornerRoad_sequence::const_iterator cornerRoad_const_iterator;
  typedef ::xsd::cxx::tree::traits< cornerRoad_type, char > cornerRoad_traits;

  const cornerRoad_sequence&
  cornerRoad () const;

  cornerRoad_sequence&
  cornerRoad ();

  void
  cornerRoad (const cornerRoad_sequence& s);

  // cornerLocal
  //
  typedef ::cornerLocal cornerLocal_type;
  typedef ::xsd::cxx::tree::sequence< cornerLocal_type > cornerLocal_sequence;
  typedef cornerLocal_sequence::iterator cornerLocal_iterator;
  typedef cornerLocal_sequence::const_iterator cornerLocal_const_iterator;
  typedef ::xsd::cxx::tree::traits< cornerLocal_type, char > cornerLocal_traits;

  const cornerLocal_sequence&
  cornerLocal () const;

  cornerLocal_sequence&
  cornerLocal ();

  void
  cornerLocal (const cornerLocal_sequence& s);

  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // Constructors.
  //
  outline ();

  outline (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  outline (const outline& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual outline*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  outline&
  operator= (const outline& x);

  virtual 
  ~outline ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  cornerRoad_sequence cornerRoad_;
  cornerLocal_sequence cornerLocal_;
  userData_sequence userData_;
  include_sequence include_;
};

class material1: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // surface
  //
  typedef ::xml_schema::string surface_type;
  typedef ::xsd::cxx::tree::optional< surface_type > surface_optional;
  typedef ::xsd::cxx::tree::traits< surface_type, char > surface_traits;

  const surface_optional&
  surface () const;

  surface_optional&
  surface ();

  void
  surface (const surface_type& x);

  void
  surface (const surface_optional& x);

  void
  surface (::std::unique_ptr< surface_type > p);

  // friction
  //
  typedef ::xml_schema::double_ friction_type;
  typedef ::xsd::cxx::tree::optional< friction_type > friction_optional;
  typedef ::xsd::cxx::tree::traits< friction_type, char, ::xsd::cxx::tree::schema_type::double_ > friction_traits;

  const friction_optional&
  friction () const;

  friction_optional&
  friction ();

  void
  friction (const friction_type& x);

  void
  friction (const friction_optional& x);

  // roughness
  //
  typedef ::xml_schema::double_ roughness_type;
  typedef ::xsd::cxx::tree::optional< roughness_type > roughness_optional;
  typedef ::xsd::cxx::tree::traits< roughness_type, char, ::xsd::cxx::tree::schema_type::double_ > roughness_traits;

  const roughness_optional&
  roughness () const;

  roughness_optional&
  roughness ();

  void
  roughness (const roughness_type& x);

  void
  roughness (const roughness_optional& x);

  // Constructors.
  //
  material1 ();

  material1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  material1 (const material1& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual material1*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  material1&
  operator= (const material1& x);

  virtual 
  ~material1 ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  surface_optional surface_;
  friction_optional friction_;
  roughness_optional roughness_;
};

class dependency: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // type
  //
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  dependency ();

  dependency (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  dependency (const dependency& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual dependency*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  dependency&
  operator= (const dependency& x);

  virtual 
  ~dependency ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  id_optional id_;
  type_optional type_;
};

class mainTrack: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // dir
  //
  typedef ::dir dir_type;
  typedef ::xsd::cxx::tree::optional< dir_type > dir_optional;
  typedef ::xsd::cxx::tree::traits< dir_type, char > dir_traits;

  const dir_optional&
  dir () const;

  dir_optional&
  dir ();

  void
  dir (const dir_type& x);

  void
  dir (const dir_optional& x);

  void
  dir (::std::unique_ptr< dir_type > p);

  // Constructors.
  //
  mainTrack ();

  mainTrack (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  mainTrack (const mainTrack& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual mainTrack*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  mainTrack&
  operator= (const mainTrack& x);

  virtual 
  ~mainTrack ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  s_optional s_;
  dir_optional dir_;
};

class sideTrack: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // dir
  //
  typedef ::dir dir_type;
  typedef ::xsd::cxx::tree::optional< dir_type > dir_optional;
  typedef ::xsd::cxx::tree::traits< dir_type, char > dir_traits;

  const dir_optional&
  dir () const;

  dir_optional&
  dir ();

  void
  dir (const dir_type& x);

  void
  dir (const dir_optional& x);

  void
  dir (::std::unique_ptr< dir_type > p);

  // Constructors.
  //
  sideTrack ();

  sideTrack (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  sideTrack (const sideTrack& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual sideTrack*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  sideTrack&
  operator= (const sideTrack& x);

  virtual 
  ~sideTrack ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  s_optional s_;
  dir_optional dir_;
};

class partner: public ::xml_schema::type
{
  public:
  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // Constructors.
  //
  partner ();

  partner (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  partner (const partner& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual partner*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  partner&
  operator= (const partner& x);

  virtual 
  ~partner ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  name_optional name_;
  id_optional id_;
};

class cornerRoad: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // s
  //
  typedef ::xml_schema::double_ s_type;
  typedef ::xsd::cxx::tree::optional< s_type > s_optional;
  typedef ::xsd::cxx::tree::traits< s_type, char, ::xsd::cxx::tree::schema_type::double_ > s_traits;

  const s_optional&
  s () const;

  s_optional&
  s ();

  void
  s (const s_type& x);

  void
  s (const s_optional& x);

  // t
  //
  typedef ::xml_schema::double_ t_type;
  typedef ::xsd::cxx::tree::optional< t_type > t_optional;
  typedef ::xsd::cxx::tree::traits< t_type, char, ::xsd::cxx::tree::schema_type::double_ > t_traits;

  const t_optional&
  t () const;

  t_optional&
  t ();

  void
  t (const t_type& x);

  void
  t (const t_optional& x);

  // dz
  //
  typedef ::xml_schema::double_ dz_type;
  typedef ::xsd::cxx::tree::optional< dz_type > dz_optional;
  typedef ::xsd::cxx::tree::traits< dz_type, char, ::xsd::cxx::tree::schema_type::double_ > dz_traits;

  const dz_optional&
  dz () const;

  dz_optional&
  dz ();

  void
  dz (const dz_type& x);

  void
  dz (const dz_optional& x);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // Constructors.
  //
  cornerRoad ();

  cornerRoad (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  cornerRoad (const cornerRoad& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual cornerRoad*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  cornerRoad&
  operator= (const cornerRoad& x);

  virtual 
  ~cornerRoad ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  s_optional s_;
  t_optional t_;
  dz_optional dz_;
  height_optional height_;
};

class cornerLocal: public ::xml_schema::type
{
  public:
  // userData
  //
  typedef ::userData userData_type;
  typedef ::xsd::cxx::tree::sequence< userData_type > userData_sequence;
  typedef userData_sequence::iterator userData_iterator;
  typedef userData_sequence::const_iterator userData_const_iterator;
  typedef ::xsd::cxx::tree::traits< userData_type, char > userData_traits;

  const userData_sequence&
  userData () const;

  userData_sequence&
  userData ();

  void
  userData (const userData_sequence& s);

  // include
  //
  typedef ::include include_type;
  typedef ::xsd::cxx::tree::sequence< include_type > include_sequence;
  typedef include_sequence::iterator include_iterator;
  typedef include_sequence::const_iterator include_const_iterator;
  typedef ::xsd::cxx::tree::traits< include_type, char > include_traits;

  const include_sequence&
  include () const;

  include_sequence&
  include ();

  void
  include (const include_sequence& s);

  // u
  //
  typedef ::xml_schema::double_ u_type;
  typedef ::xsd::cxx::tree::optional< u_type > u_optional;
  typedef ::xsd::cxx::tree::traits< u_type, char, ::xsd::cxx::tree::schema_type::double_ > u_traits;

  const u_optional&
  u () const;

  u_optional&
  u ();

  void
  u (const u_type& x);

  void
  u (const u_optional& x);

  // v
  //
  typedef ::xml_schema::double_ v_type;
  typedef ::xsd::cxx::tree::optional< v_type > v_optional;
  typedef ::xsd::cxx::tree::traits< v_type, char, ::xsd::cxx::tree::schema_type::double_ > v_traits;

  const v_optional&
  v () const;

  v_optional&
  v ();

  void
  v (const v_type& x);

  void
  v (const v_optional& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::optional< z_type > z_optional;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_optional&
  z () const;

  z_optional&
  z ();

  void
  z (const z_type& x);

  void
  z (const z_optional& x);

  // height
  //
  typedef ::xml_schema::double_ height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char, ::xsd::cxx::tree::schema_type::double_ > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // Constructors.
  //
  cornerLocal ();

  cornerLocal (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  cornerLocal (const cornerLocal& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual cornerLocal*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  cornerLocal&
  operator= (const cornerLocal& x);

  virtual 
  ~cornerLocal ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  userData_sequence userData_;
  include_sequence include_;
  u_optional u_;
  v_optional v_;
  z_optional z_;
  height_optional height_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SCHEMA_OPEN_DRIVE_1_4H_H
